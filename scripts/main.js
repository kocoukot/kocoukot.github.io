(() => {
  "use strict";
  var e = {
      147: (e, t, n) => {
        n.d(t, { Z: () => d });
        var i = n(81),
          r = n.n(i),
          s = n(645),
          a = n.n(s),
          o = n(667),
          l = n.n(o),
          c = new URL(n(954), n.b),
          u = a()(r()),
          h = l()(c);
        u.push([
          e.id,
          "/**\n * Swiper 8.3.0\n * Most modern mobile touch slider and framework with hardware accelerated transitions\n * https://swiperjs.com\n *\n * Copyright 2014-2022 Vladimir Kharlampidi\n *\n * Released under the MIT License\n *\n * Released on: July 6, 2022\n */\n\n@font-face{font-family:swiper-icons;src:url(" +
            h +
            ");font-weight:400;font-style:normal}:root{--swiper-theme-color:#007aff}.swiper{margin-left:auto;margin-right:auto;position:relative;overflow:hidden;list-style:none;padding:0;z-index:1}.swiper-vertical>.swiper-wrapper{flex-direction:column}.swiper-wrapper{position:relative;width:100%;height:100%;z-index:1;display:flex;transition-property:transform;box-sizing:content-box}.swiper-android .swiper-slide,.swiper-wrapper{transform:translate3d(0px,0,0)}.swiper-pointer-events{touch-action:pan-y}.swiper-pointer-events.swiper-vertical{touch-action:pan-x}.swiper-slide{flex-shrink:0;width:100%;height:100%;position:relative;transition-property:transform}.swiper-slide-invisible-blank{visibility:hidden}.swiper-autoheight,.swiper-autoheight .swiper-slide{height:auto}.swiper-autoheight .swiper-wrapper{align-items:flex-start;transition-property:transform,height}.swiper-backface-hidden .swiper-slide{transform:translateZ(0);-webkit-backface-visibility:hidden;backface-visibility:hidden}.swiper-3d,.swiper-3d.swiper-css-mode .swiper-wrapper{perspective:1200px}.swiper-3d .swiper-cube-shadow,.swiper-3d .swiper-slide,.swiper-3d .swiper-slide-shadow,.swiper-3d .swiper-slide-shadow-bottom,.swiper-3d .swiper-slide-shadow-left,.swiper-3d .swiper-slide-shadow-right,.swiper-3d .swiper-slide-shadow-top,.swiper-3d .swiper-wrapper{transform-style:preserve-3d}.swiper-3d .swiper-slide-shadow,.swiper-3d .swiper-slide-shadow-bottom,.swiper-3d .swiper-slide-shadow-left,.swiper-3d .swiper-slide-shadow-right,.swiper-3d .swiper-slide-shadow-top{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:10}.swiper-3d .swiper-slide-shadow{background:rgba(0,0,0,.15)}.swiper-3d .swiper-slide-shadow-left{background-image:linear-gradient(to left,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-3d .swiper-slide-shadow-right{background-image:linear-gradient(to right,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-3d .swiper-slide-shadow-top{background-image:linear-gradient(to top,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-3d .swiper-slide-shadow-bottom{background-image:linear-gradient(to bottom,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-css-mode>.swiper-wrapper{overflow:auto;scrollbar-width:none;-ms-overflow-style:none}.swiper-css-mode>.swiper-wrapper::-webkit-scrollbar{display:none}.swiper-css-mode>.swiper-wrapper>.swiper-slide{scroll-snap-align:start start}.swiper-horizontal.swiper-css-mode>.swiper-wrapper{scroll-snap-type:x mandatory}.swiper-vertical.swiper-css-mode>.swiper-wrapper{scroll-snap-type:y mandatory}.swiper-centered>.swiper-wrapper::before{content:'';flex-shrink:0;order:9999}.swiper-centered.swiper-horizontal>.swiper-wrapper>.swiper-slide:first-child{margin-inline-start:var(--swiper-centered-offset-before)}.swiper-centered.swiper-horizontal>.swiper-wrapper::before{height:100%;min-height:1px;width:var(--swiper-centered-offset-after)}.swiper-centered.swiper-vertical>.swiper-wrapper>.swiper-slide:first-child{margin-block-start:var(--swiper-centered-offset-before)}.swiper-centered.swiper-vertical>.swiper-wrapper::before{width:100%;min-width:1px;height:var(--swiper-centered-offset-after)}.swiper-centered>.swiper-wrapper>.swiper-slide{scroll-snap-align:center center}",
          "",
        ]);
        const d = u;
      },
      645: (e) => {
        e.exports = function (e) {
          var t = [];
          return (
            (t.toString = function () {
              return this.map(function (t) {
                var n = "",
                  i = void 0 !== t[5];
                return (
                  t[4] && (n += "@supports (".concat(t[4], ") {")),
                  t[2] && (n += "@media ".concat(t[2], " {")),
                  i &&
                    (n += "@layer".concat(
                      t[5].length > 0 ? " ".concat(t[5]) : "",
                      " {"
                    )),
                  (n += e(t)),
                  i && (n += "}"),
                  t[2] && (n += "}"),
                  t[4] && (n += "}"),
                  n
                );
              }).join("");
            }),
            (t.i = function (e, n, i, r, s) {
              "string" == typeof e && (e = [[null, e, void 0]]);
              var a = {};
              if (i)
                for (var o = 0; o < this.length; o++) {
                  var l = this[o][0];
                  null != l && (a[l] = !0);
                }
              for (var c = 0; c < e.length; c++) {
                var u = [].concat(e[c]);
                (i && a[u[0]]) ||
                  (void 0 !== s &&
                    (void 0 === u[5] ||
                      (u[1] = "@layer"
                        .concat(u[5].length > 0 ? " ".concat(u[5]) : "", " {")
                        .concat(u[1], "}")),
                    (u[5] = s)),
                  n &&
                    (u[2]
                      ? ((u[1] = "@media "
                          .concat(u[2], " {")
                          .concat(u[1], "}")),
                        (u[2] = n))
                      : (u[2] = n)),
                  r &&
                    (u[4]
                      ? ((u[1] = "@supports ("
                          .concat(u[4], ") {")
                          .concat(u[1], "}")),
                        (u[4] = r))
                      : (u[4] = "".concat(r))),
                  t.push(u));
              }
            }),
            t
          );
        };
      },
      667: (e) => {
        e.exports = function (e, t) {
          return (
            t || (t = {}),
            e
              ? ((e = String(e.__esModule ? e.default : e)),
                /^['"].*['"]$/.test(e) && (e = e.slice(1, -1)),
                t.hash && (e += t.hash),
                /["'() \t\n]|(%20)/.test(e) || t.needQuotes
                  ? '"'.concat(
                      e.replace(/"/g, '\\"').replace(/\n/g, "\\n"),
                      '"'
                    )
                  : e)
              : e
          );
        };
      },
      81: (e) => {
        e.exports = function (e) {
          return e[1];
        };
      },
      379: (e) => {
        var t = [];
        function n(e) {
          for (var n = -1, i = 0; i < t.length; i++)
            if (t[i].identifier === e) {
              n = i;
              break;
            }
          return n;
        }
        function i(e, i) {
          for (var s = {}, a = [], o = 0; o < e.length; o++) {
            var l = e[o],
              c = i.base ? l[0] + i.base : l[0],
              u = s[c] || 0,
              h = "".concat(c, " ").concat(u);
            s[c] = u + 1;
            var d = n(h),
              p = {
                css: l[1],
                media: l[2],
                sourceMap: l[3],
                supports: l[4],
                layer: l[5],
              };
            if (-1 !== d) t[d].references++, t[d].updater(p);
            else {
              var f = r(p, i);
              (i.byIndex = o),
                t.splice(o, 0, { identifier: h, updater: f, references: 1 });
            }
            a.push(h);
          }
          return a;
        }
        function r(e, t) {
          var n = t.domAPI(t);
          return (
            n.update(e),
            function (t) {
              if (t) {
                if (
                  t.css === e.css &&
                  t.media === e.media &&
                  t.sourceMap === e.sourceMap &&
                  t.supports === e.supports &&
                  t.layer === e.layer
                )
                  return;
                n.update((e = t));
              } else n.remove();
            }
          );
        }
        e.exports = function (e, r) {
          var s = i((e = e || []), (r = r || {}));
          return function (e) {
            e = e || [];
            for (var a = 0; a < s.length; a++) {
              var o = n(s[a]);
              t[o].references--;
            }
            for (var l = i(e, r), c = 0; c < s.length; c++) {
              var u = n(s[c]);
              0 === t[u].references && (t[u].updater(), t.splice(u, 1));
            }
            s = l;
          };
        };
      },
      569: (e) => {
        var t = {};
        e.exports = function (e, n) {
          var i = (function (e) {
            if (void 0 === t[e]) {
              var n = document.querySelector(e);
              if (
                window.HTMLIFrameElement &&
                n instanceof window.HTMLIFrameElement
              )
                try {
                  n = n.contentDocument.head;
                } catch (e) {
                  n = null;
                }
              t[e] = n;
            }
            return t[e];
          })(e);
          if (!i)
            throw new Error(
              "Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid."
            );
          i.appendChild(n);
        };
      },
      216: (e) => {
        e.exports = function (e) {
          var t = document.createElement("style");
          return e.setAttributes(t, e.attributes), e.insert(t, e.options), t;
        };
      },
      565: (e, t, n) => {
        e.exports = function (e) {
          var t = n.nc;
          t && e.setAttribute("nonce", t);
        };
      },
      795: (e) => {
        e.exports = function (e) {
          var t = e.insertStyleElement(e);
          return {
            update: function (n) {
              !(function (e, t, n) {
                var i = "";
                n.supports && (i += "@supports (".concat(n.supports, ") {")),
                  n.media && (i += "@media ".concat(n.media, " {"));
                var r = void 0 !== n.layer;
                r &&
                  (i += "@layer".concat(
                    n.layer.length > 0 ? " ".concat(n.layer) : "",
                    " {"
                  )),
                  (i += n.css),
                  r && (i += "}"),
                  n.media && (i += "}"),
                  n.supports && (i += "}");
                var s = n.sourceMap;
                s &&
                  "undefined" != typeof btoa &&
                  (i +=
                    "\n/*# sourceMappingURL=data:application/json;base64,".concat(
                      btoa(unescape(encodeURIComponent(JSON.stringify(s)))),
                      " */"
                    )),
                  t.styleTagTransform(i, e, t.options);
              })(t, e, n);
            },
            remove: function () {
              !(function (e) {
                if (null === e.parentNode) return !1;
                e.parentNode.removeChild(e);
              })(t);
            },
          };
        };
      },
      589: (e) => {
        e.exports = function (e, t) {
          if (t.styleSheet) t.styleSheet.cssText = e;
          else {
            for (; t.firstChild; ) t.removeChild(t.firstChild);
            t.appendChild(document.createTextNode(e));
          }
        };
      },
      954: (e) => {
        e.exports =
          "data:application/font-woff;charset=utf-8;base64, d09GRgABAAAAAAZgABAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAGRAAAABoAAAAci6qHkUdERUYAAAWgAAAAIwAAACQAYABXR1BPUwAABhQAAAAuAAAANuAY7+xHU1VCAAAFxAAAAFAAAABm2fPczU9TLzIAAAHcAAAASgAAAGBP9V5RY21hcAAAAkQAAACIAAABYt6F0cBjdnQgAAACzAAAAAQAAAAEABEBRGdhc3AAAAWYAAAACAAAAAj//wADZ2x5ZgAAAywAAADMAAAD2MHtryVoZWFkAAABbAAAADAAAAA2E2+eoWhoZWEAAAGcAAAAHwAAACQC9gDzaG10eAAAAigAAAAZAAAArgJkABFsb2NhAAAC0AAAAFoAAABaFQAUGG1heHAAAAG8AAAAHwAAACAAcABAbmFtZQAAA/gAAAE5AAACXvFdBwlwb3N0AAAFNAAAAGIAAACE5s74hXjaY2BkYGAAYpf5Hu/j+W2+MnAzMYDAzaX6QjD6/4//Bxj5GA8AuRwMYGkAPywL13jaY2BkYGA88P8Agx4j+/8fQDYfA1AEBWgDAIB2BOoAeNpjYGRgYNBh4GdgYgABEMnIABJzYNADCQAACWgAsQB42mNgYfzCOIGBlYGB0YcxjYGBwR1Kf2WQZGhhYGBiYGVmgAFGBiQQkOaawtDAoMBQxXjg/wEGPcYDDA4wNUA2CCgwsAAAO4EL6gAAeNpj2M0gyAACqxgGNWBkZ2D4/wMA+xkDdgAAAHjaY2BgYGaAYBkGRgYQiAHyGMF8FgYHIM3DwMHABGQrMOgyWDLEM1T9/w8UBfEMgLzE////P/5//f/V/xv+r4eaAAeMbAxwIUYmIMHEgKYAYjUcsDAwsLKxc3BycfPw8jEQA/gZBASFhEVExcQlJKWkZWTl5BUUlZRVVNXUNTQZBgMAAMR+E+gAEQFEAAAAKgAqACoANAA+AEgAUgBcAGYAcAB6AIQAjgCYAKIArAC2AMAAygDUAN4A6ADyAPwBBgEQARoBJAEuATgBQgFMAVYBYAFqAXQBfgGIAZIBnAGmAbIBzgHsAAB42u2NMQ6CUAyGW568x9AneYYgm4MJbhKFaExIOAVX8ApewSt4Bic4AfeAid3VOBixDxfPYEza5O+Xfi04YADggiUIULCuEJK8VhO4bSvpdnktHI5QCYtdi2sl8ZnXaHlqUrNKzdKcT8cjlq+rwZSvIVczNiezsfnP/uznmfPFBNODM2K7MTQ45YEAZqGP81AmGGcF3iPqOop0r1SPTaTbVkfUe4HXj97wYE+yNwWYxwWu4v1ugWHgo3S1XdZEVqWM7ET0cfnLGxWfkgR42o2PvWrDMBSFj/IHLaF0zKjRgdiVMwScNRAoWUoH78Y2icB/yIY09An6AH2Bdu/UB+yxopYshQiEvnvu0dURgDt8QeC8PDw7Fpji3fEA4z/PEJ6YOB5hKh4dj3EvXhxPqH/SKUY3rJ7srZ4FZnh1PMAtPhwP6fl2PMJMPDgeQ4rY8YT6Gzao0eAEA409DuggmTnFnOcSCiEiLMgxCiTI6Cq5DZUd3Qmp10vO0LaLTd2cjN4fOumlc7lUYbSQcZFkutRG7g6JKZKy0RmdLY680CDnEJ+UMkpFFe1RN7nxdVpXrC4aTtnaurOnYercZg2YVmLN/d/gczfEimrE/fs/bOuq29Zmn8tloORaXgZgGa78yO9/cnXm2BpaGvq25Dv9S4E9+5SIc9PqupJKhYFSSl47+Qcr1mYNAAAAeNptw0cKwkAAAMDZJA8Q7OUJvkLsPfZ6zFVERPy8qHh2YER+3i/BP83vIBLLySsoKimrqKqpa2hp6+jq6RsYGhmbmJqZSy0sraxtbO3sHRydnEMU4uR6yx7JJXveP7WrDycAAAAAAAH//wACeNpjYGRgYOABYhkgZgJCZgZNBkYGLQZtIJsFLMYAAAw3ALgAeNolizEKgDAQBCchRbC2sFER0YD6qVQiBCv/H9ezGI6Z5XBAw8CBK/m5iQQVauVbXLnOrMZv2oLdKFa8Pjuru2hJzGabmOSLzNMzvutpB3N42mNgZGBg4GKQYzBhYMxJLMlj4GBgAYow/P/PAJJhLM6sSoWKfWCAAwDAjgbRAAB42mNgYGBkAIIbCZo5IPrmUn0hGA0AO8EFTQAA";
      },
    },
    t = {};
  function n(i) {
    var r = t[i];
    if (void 0 !== r) return r.exports;
    var s = (t[i] = { id: i, exports: {} });
    return e[i](s, s.exports, n), s.exports;
  }
  (n.m = e),
    (n.n = (e) => {
      var t = e && e.__esModule ? () => e.default : () => e;
      return n.d(t, { a: t }), t;
    }),
    (n.d = (e, t) => {
      for (var i in t)
        n.o(t, i) &&
          !n.o(e, i) &&
          Object.defineProperty(e, i, { enumerable: !0, get: t[i] });
    }),
    (n.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t)),
    (n.b = document.baseURI || self.location.href),
    (n.nc = void 0),
    (() => {
      const e = (function () {
          function e(e) {
            this.screens = [];
            var t = this.getParsedScreens(e),
              n = t.screens,
              i = t.index;
            (this.currentScreenIndex = i),
              (this.screens = n),
              (this.currentScreen = this.getCurrentScreen()),
              this.initializeObserver();
          }
          return (
            (e.prototype.next = function () {
              this.isCanBeChanged(1) &&
                this.screens.length - 1 !== this.currentScreenIndex &&
                ((this.currentScreenIndex += 1),
                this.currentScreen.hide(),
                (this.currentScreen = this.getCurrentScreen()),
                this.currentScreen.show());
            }),
            (e.prototype.previous = function () {
              this.isCanBeChanged(-1) &&
                0 !== this.currentScreenIndex &&
                ((this.currentScreenIndex -= 1),
                this.currentScreen.hide(),
                (this.currentScreen = this.getCurrentScreen()),
                this.currentScreen.show());
            }),
            (e.prototype.isCanBeChanged = function (e) {
              return this.currentScreen.isCanBeChanged(e);
            }),
            (e.prototype.getCurrentScreen = function () {
              return this.screens[this.currentScreenIndex];
            }),
            (e.prototype.getParsedScreens = function (e) {
              var t = this;
              return {
                screens: e.map(function (e) {
                  return new e.screen(t);
                }),
                index:
                  e.findIndex(function (e) {
                    return e.current;
                  }) || 0,
              };
            }),
            (e.prototype.initializeObserver = function () {
              var e = this,
                t = this.screens.reduce(function (e, t, n) {
                  return e.push(t.getRoot()), e;
                }, []);
              (this.observer = new IntersectionObserver(
                function (n, i) {
                  n.forEach(function (n, i) {
                    if (n.isIntersecting) {
                      var r = n.target;
                      e.currentScreen.hide(),
                        (e.currentScreenIndex = t.indexOf(r)),
                        (e.currentScreen = e.screens[e.currentScreenIndex]),
                        e.currentScreen.show();
                    }
                  });
                },
                { threshold: 0.4 }
              )),
                t.forEach(function (t) {
                  var n;
                  return null === (n = e.observer) || void 0 === n
                    ? void 0
                    : n.observe(t);
                });
            }),
            e
          );
        })(),
        t = (function () {
          function e(e) {
            (this.isCurrent = !1), (this.screenController = e);
          }
          return (
            (e.prototype.show = function () {
              this.root.classList.add("visible"), (this.isCurrent = !0);
            }),
            (e.prototype.hide = function () {
              this.root.classList.remove("visible"), (this.isCurrent = !1);
            }),
            (e.prototype.getRoot = function () {
              return this.root;
            }),
            e
          );
        })();
      var i = function (e, t, n, i) {
          return new (n || (n = Promise))(function (r, s) {
            function a(e) {
              try {
                l(i.next(e));
              } catch (e) {
                s(e);
              }
            }
            function o(e) {
              try {
                l(i.throw(e));
              } catch (e) {
                s(e);
              }
            }
            function l(e) {
              var t;
              e.done
                ? r(e.value)
                : ((t = e.value),
                  t instanceof n
                    ? t
                    : new n(function (e) {
                        e(t);
                      })).then(a, o);
            }
            l((i = i.apply(e, t || [])).next());
          });
        },
        r = function (e, t) {
          var n,
            i,
            r,
            s,
            a = {
              label: 0,
              sent: function () {
                if (1 & r[0]) throw r[1];
                return r[1];
              },
              trys: [],
              ops: [],
            };
          return (
            (s = { next: o(0), throw: o(1), return: o(2) }),
            "function" == typeof Symbol &&
              (s[Symbol.iterator] = function () {
                return this;
              }),
            s
          );
          function o(s) {
            return function (o) {
              return (function (s) {
                if (n) throw new TypeError("Generator is already executing.");
                for (; a; )
                  try {
                    if (
                      ((n = 1),
                      i &&
                        (r =
                          2 & s[0]
                            ? i.return
                            : s[0]
                            ? i.throw || ((r = i.return) && r.call(i), 0)
                            : i.next) &&
                        !(r = r.call(i, s[1])).done)
                    )
                      return r;
                    switch (((i = 0), r && (s = [2 & s[0], r.value]), s[0])) {
                      case 0:
                      case 1:
                        r = s;
                        break;
                      case 4:
                        return a.label++, { value: s[1], done: !1 };
                      case 5:
                        a.label++, (i = s[1]), (s = [0]);
                        continue;
                      case 7:
                        (s = a.ops.pop()), a.trys.pop();
                        continue;
                      default:
                        if (
                          !(
                            (r = (r = a.trys).length > 0 && r[r.length - 1]) ||
                            (6 !== s[0] && 2 !== s[0])
                          )
                        ) {
                          a = 0;
                          continue;
                        }
                        if (
                          3 === s[0] &&
                          (!r || (s[1] > r[0] && s[1] < r[3]))
                        ) {
                          a.label = s[1];
                          break;
                        }
                        if (6 === s[0] && a.label < r[1]) {
                          (a.label = r[1]), (r = s);
                          break;
                        }
                        if (r && a.label < r[2]) {
                          (a.label = r[2]), a.ops.push(s);
                          break;
                        }
                        r[2] && a.ops.pop(), a.trys.pop();
                        continue;
                    }
                    s = t.call(e, a);
                  } catch (e) {
                    (s = [6, e]), (i = 0);
                  } finally {
                    n = r = 0;
                  }
                if (5 & s[0]) throw s[1];
                return { value: s[0] ? s[1] : void 0, done: !0 };
              })([s, o]);
            };
          }
        };
      const s = (function () {
          function e(e) {
            (this.isPrinting = !1), (this.root = e);
          }
          return (
            (e.prototype.changeTo = function (e) {
              return i(this, void 0, void 0, function () {
                var t = this;
                return r(this, function (n) {
                  return [
                    2,
                    new Promise(function (n, s) {
                      return i(t, void 0, void 0, function () {
                        var t = this;
                        return r(this, function (s) {
                          switch (s.label) {
                            case 0:
                              return this.isPrinting
                                ? [2]
                                : ((this.isPrinting = !0), [4, this.clear()]);
                            case 1:
                              return (
                                s.sent(),
                                setTimeout(function () {
                                  return i(t, void 0, void 0, function () {
                                    return r(this, function (t) {
                                      switch (t.label) {
                                        case 0:
                                          return [4, this.type(e)];
                                        case 1:
                                          return (
                                            t.sent(),
                                            (this.isPrinting = !1),
                                            n(null),
                                            [2]
                                          );
                                      }
                                    });
                                  });
                                }, 40),
                                [2]
                              );
                          }
                        });
                      });
                    }),
                  ];
                });
              });
            }),
            (e.prototype.clear = function () {
              var e = this;
              return new Promise(function (t, n) {
                for (
                  var i = e.root.innerHTML,
                    r = i.length,
                    s = function (n) {
                      setTimeout(function () {
                        (e.root.innerHTML = i.slice(0, r - n)),
                          n === r && t(null);
                      }, 40 * n);
                    },
                    a = 0;
                  a <= r;
                  a++
                )
                  s(a);
              });
            }),
            (e.prototype.type = function (e) {
              return i(this, void 0, void 0, function () {
                var t = this;
                return r(this, function (n) {
                  return [
                    2,
                    new Promise(function (n, i) {
                      e.split("").forEach(function (i, r) {
                        setTimeout(function () {
                          (t.root.innerHTML += i),
                            r === e.length - 1 && n(null);
                        }, 40 * r);
                      });
                    }),
                  ];
                });
              });
            }),
            (e.prototype.forceClear = function () {
              this.root.innerHTML = "";
            }),
            (e.prototype.getIsPrinting = function () {
              return this.isPrinting;
            }),
            e
          );
        })(),
        a = 100,
        o = 301,
        l = 302,
        c = 306,
        u = 1e3,
        h = 1001,
        d = 1002,
        p = 1003,
        f = 1006,
        m = 1008,
        g = 1009,
        v = 1014,
        _ = 1015,
        x = 1016,
        y = 1020,
        b = 1023,
        w = 1026,
        S = 1027,
        M = 33776,
        E = 33777,
        T = 33778,
        A = 33779,
        C = 2300,
        L = 2301,
        P = 2302,
        D = 3e3,
        k = 3001,
        R = "srgb",
        I = "srgb-linear",
        F = 7680,
        O = "300 es",
        N = 1035;
      class z {
        addEventListener(e, t) {
          void 0 === this._listeners && (this._listeners = {});
          const n = this._listeners;
          void 0 === n[e] && (n[e] = []),
            -1 === n[e].indexOf(t) && n[e].push(t);
        }
        hasEventListener(e, t) {
          if (void 0 === this._listeners) return !1;
          const n = this._listeners;
          return void 0 !== n[e] && -1 !== n[e].indexOf(t);
        }
        removeEventListener(e, t) {
          if (void 0 === this._listeners) return;
          const n = this._listeners[e];
          if (void 0 !== n) {
            const e = n.indexOf(t);
            -1 !== e && n.splice(e, 1);
          }
        }
        dispatchEvent(e) {
          if (void 0 === this._listeners) return;
          const t = this._listeners[e.type];
          if (void 0 !== t) {
            e.target = this;
            const n = t.slice(0);
            for (let t = 0, i = n.length; t < i; t++) n[t].call(this, e);
            e.target = null;
          }
        }
      }
      const B = [
          "00",
          "01",
          "02",
          "03",
          "04",
          "05",
          "06",
          "07",
          "08",
          "09",
          "0a",
          "0b",
          "0c",
          "0d",
          "0e",
          "0f",
          "10",
          "11",
          "12",
          "13",
          "14",
          "15",
          "16",
          "17",
          "18",
          "19",
          "1a",
          "1b",
          "1c",
          "1d",
          "1e",
          "1f",
          "20",
          "21",
          "22",
          "23",
          "24",
          "25",
          "26",
          "27",
          "28",
          "29",
          "2a",
          "2b",
          "2c",
          "2d",
          "2e",
          "2f",
          "30",
          "31",
          "32",
          "33",
          "34",
          "35",
          "36",
          "37",
          "38",
          "39",
          "3a",
          "3b",
          "3c",
          "3d",
          "3e",
          "3f",
          "40",
          "41",
          "42",
          "43",
          "44",
          "45",
          "46",
          "47",
          "48",
          "49",
          "4a",
          "4b",
          "4c",
          "4d",
          "4e",
          "4f",
          "50",
          "51",
          "52",
          "53",
          "54",
          "55",
          "56",
          "57",
          "58",
          "59",
          "5a",
          "5b",
          "5c",
          "5d",
          "5e",
          "5f",
          "60",
          "61",
          "62",
          "63",
          "64",
          "65",
          "66",
          "67",
          "68",
          "69",
          "6a",
          "6b",
          "6c",
          "6d",
          "6e",
          "6f",
          "70",
          "71",
          "72",
          "73",
          "74",
          "75",
          "76",
          "77",
          "78",
          "79",
          "7a",
          "7b",
          "7c",
          "7d",
          "7e",
          "7f",
          "80",
          "81",
          "82",
          "83",
          "84",
          "85",
          "86",
          "87",
          "88",
          "89",
          "8a",
          "8b",
          "8c",
          "8d",
          "8e",
          "8f",
          "90",
          "91",
          "92",
          "93",
          "94",
          "95",
          "96",
          "97",
          "98",
          "99",
          "9a",
          "9b",
          "9c",
          "9d",
          "9e",
          "9f",
          "a0",
          "a1",
          "a2",
          "a3",
          "a4",
          "a5",
          "a6",
          "a7",
          "a8",
          "a9",
          "aa",
          "ab",
          "ac",
          "ad",
          "ae",
          "af",
          "b0",
          "b1",
          "b2",
          "b3",
          "b4",
          "b5",
          "b6",
          "b7",
          "b8",
          "b9",
          "ba",
          "bb",
          "bc",
          "bd",
          "be",
          "bf",
          "c0",
          "c1",
          "c2",
          "c3",
          "c4",
          "c5",
          "c6",
          "c7",
          "c8",
          "c9",
          "ca",
          "cb",
          "cc",
          "cd",
          "ce",
          "cf",
          "d0",
          "d1",
          "d2",
          "d3",
          "d4",
          "d5",
          "d6",
          "d7",
          "d8",
          "d9",
          "da",
          "db",
          "dc",
          "dd",
          "de",
          "df",
          "e0",
          "e1",
          "e2",
          "e3",
          "e4",
          "e5",
          "e6",
          "e7",
          "e8",
          "e9",
          "ea",
          "eb",
          "ec",
          "ed",
          "ee",
          "ef",
          "f0",
          "f1",
          "f2",
          "f3",
          "f4",
          "f5",
          "f6",
          "f7",
          "f8",
          "f9",
          "fa",
          "fb",
          "fc",
          "fd",
          "fe",
          "ff",
        ],
        U = Math.PI / 180,
        V = 180 / Math.PI;
      function G() {
        const e = (4294967295 * Math.random()) | 0,
          t = (4294967295 * Math.random()) | 0,
          n = (4294967295 * Math.random()) | 0,
          i = (4294967295 * Math.random()) | 0;
        return (
          B[255 & e] +
          B[(e >> 8) & 255] +
          B[(e >> 16) & 255] +
          B[(e >> 24) & 255] +
          "-" +
          B[255 & t] +
          B[(t >> 8) & 255] +
          "-" +
          B[((t >> 16) & 15) | 64] +
          B[(t >> 24) & 255] +
          "-" +
          B[(63 & n) | 128] +
          B[(n >> 8) & 255] +
          "-" +
          B[(n >> 16) & 255] +
          B[(n >> 24) & 255] +
          B[255 & i] +
          B[(i >> 8) & 255] +
          B[(i >> 16) & 255] +
          B[(i >> 24) & 255]
        ).toLowerCase();
      }
      function H(e, t, n) {
        return Math.max(t, Math.min(n, e));
      }
      function W(e, t, n) {
        return (1 - n) * e + n * t;
      }
      function j(e) {
        return 0 == (e & (e - 1)) && 0 !== e;
      }
      function q(e) {
        return Math.pow(2, Math.floor(Math.log(e) / Math.LN2));
      }
      class X {
        constructor(e = 0, t = 0) {
          (X.prototype.isVector2 = !0), (this.x = e), (this.y = t);
        }
        get width() {
          return this.x;
        }
        set width(e) {
          this.x = e;
        }
        get height() {
          return this.y;
        }
        set height(e) {
          this.y = e;
        }
        set(e, t) {
          return (this.x = e), (this.y = t), this;
        }
        setScalar(e) {
          return (this.x = e), (this.y = e), this;
        }
        setX(e) {
          return (this.x = e), this;
        }
        setY(e) {
          return (this.y = e), this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y);
        }
        copy(e) {
          return (this.x = e.x), (this.y = e.y), this;
        }
        add(e, t) {
          return void 0 !== t
            ? (console.warn(
                "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(e, t))
            : ((this.x += e.x), (this.y += e.y), this);
        }
        addScalar(e) {
          return (this.x += e), (this.y += e), this;
        }
        addVectors(e, t) {
          return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
        }
        addScaledVector(e, t) {
          return (this.x += e.x * t), (this.y += e.y * t), this;
        }
        sub(e, t) {
          return void 0 !== t
            ? (console.warn(
                "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(e, t))
            : ((this.x -= e.x), (this.y -= e.y), this);
        }
        subScalar(e) {
          return (this.x -= e), (this.y -= e), this;
        }
        subVectors(e, t) {
          return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
        }
        multiply(e) {
          return (this.x *= e.x), (this.y *= e.y), this;
        }
        multiplyScalar(e) {
          return (this.x *= e), (this.y *= e), this;
        }
        divide(e) {
          return (this.x /= e.x), (this.y /= e.y), this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        applyMatrix3(e) {
          const t = this.x,
            n = this.y,
            i = e.elements;
          return (
            (this.x = i[0] * t + i[3] * n + i[6]),
            (this.y = i[1] * t + i[4] * n + i[7]),
            this
          );
        }
        min(e) {
          return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            this
          );
        }
        max(e) {
          return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            this
          );
        }
        clamp(e, t) {
          return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            this
          );
        }
        clampScalar(e, t) {
          return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            this
          );
        }
        clampLength(e, t) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(e, Math.min(t, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
          );
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            this
          );
        }
        negate() {
          return (this.x = -this.x), (this.y = -this.y), this;
        }
        dot(e) {
          return this.x * e.x + this.y * e.y;
        }
        cross(e) {
          return this.x * e.y - this.y * e.x;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        angle() {
          return Math.atan2(-this.y, -this.x) + Math.PI;
        }
        distanceTo(e) {
          return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
          const t = this.x - e.x,
            n = this.y - e.y;
          return t * t + n * n;
        }
        manhattanDistanceTo(e) {
          return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return (
            (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this
          );
        }
        lerpVectors(e, t, n) {
          return (
            (this.x = e.x + (t.x - e.x) * n),
            (this.y = e.y + (t.y - e.y) * n),
            this
          );
        }
        equals(e) {
          return e.x === this.x && e.y === this.y;
        }
        fromArray(e, t = 0) {
          return (this.x = e[t]), (this.y = e[t + 1]), this;
        }
        toArray(e = [], t = 0) {
          return (e[t] = this.x), (e[t + 1] = this.y), e;
        }
        fromBufferAttribute(e, t, n) {
          return (
            void 0 !== n &&
              console.warn(
                "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = e.getX(t)),
            (this.y = e.getY(t)),
            this
          );
        }
        rotateAround(e, t) {
          const n = Math.cos(t),
            i = Math.sin(t),
            r = this.x - e.x,
            s = this.y - e.y;
          return (
            (this.x = r * n - s * i + e.x), (this.y = r * i + s * n + e.y), this
          );
        }
        random() {
          return (this.x = Math.random()), (this.y = Math.random()), this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y;
        }
      }
      class Y {
        constructor() {
          (Y.prototype.isMatrix3 = !0),
            (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
            arguments.length > 0 &&
              console.error(
                "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
              );
        }
        set(e, t, n, i, r, s, a, o, l) {
          const c = this.elements;
          return (
            (c[0] = e),
            (c[1] = i),
            (c[2] = a),
            (c[3] = t),
            (c[4] = r),
            (c[5] = o),
            (c[6] = n),
            (c[7] = s),
            (c[8] = l),
            this
          );
        }
        identity() {
          return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        }
        copy(e) {
          const t = this.elements,
            n = e.elements;
          return (
            (t[0] = n[0]),
            (t[1] = n[1]),
            (t[2] = n[2]),
            (t[3] = n[3]),
            (t[4] = n[4]),
            (t[5] = n[5]),
            (t[6] = n[6]),
            (t[7] = n[7]),
            (t[8] = n[8]),
            this
          );
        }
        extractBasis(e, t, n) {
          return (
            e.setFromMatrix3Column(this, 0),
            t.setFromMatrix3Column(this, 1),
            n.setFromMatrix3Column(this, 2),
            this
          );
        }
        setFromMatrix4(e) {
          const t = e.elements;
          return (
            this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
            this
          );
        }
        multiply(e) {
          return this.multiplyMatrices(this, e);
        }
        premultiply(e) {
          return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
          const n = e.elements,
            i = t.elements,
            r = this.elements,
            s = n[0],
            a = n[3],
            o = n[6],
            l = n[1],
            c = n[4],
            u = n[7],
            h = n[2],
            d = n[5],
            p = n[8],
            f = i[0],
            m = i[3],
            g = i[6],
            v = i[1],
            _ = i[4],
            x = i[7],
            y = i[2],
            b = i[5],
            w = i[8];
          return (
            (r[0] = s * f + a * v + o * y),
            (r[3] = s * m + a * _ + o * b),
            (r[6] = s * g + a * x + o * w),
            (r[1] = l * f + c * v + u * y),
            (r[4] = l * m + c * _ + u * b),
            (r[7] = l * g + c * x + u * w),
            (r[2] = h * f + d * v + p * y),
            (r[5] = h * m + d * _ + p * b),
            (r[8] = h * g + d * x + p * w),
            this
          );
        }
        multiplyScalar(e) {
          const t = this.elements;
          return (
            (t[0] *= e),
            (t[3] *= e),
            (t[6] *= e),
            (t[1] *= e),
            (t[4] *= e),
            (t[7] *= e),
            (t[2] *= e),
            (t[5] *= e),
            (t[8] *= e),
            this
          );
        }
        determinant() {
          const e = this.elements,
            t = e[0],
            n = e[1],
            i = e[2],
            r = e[3],
            s = e[4],
            a = e[5],
            o = e[6],
            l = e[7],
            c = e[8];
          return (
            t * s * c -
            t * a * l -
            n * r * c +
            n * a * o +
            i * r * l -
            i * s * o
          );
        }
        invert() {
          const e = this.elements,
            t = e[0],
            n = e[1],
            i = e[2],
            r = e[3],
            s = e[4],
            a = e[5],
            o = e[6],
            l = e[7],
            c = e[8],
            u = c * s - a * l,
            h = a * o - c * r,
            d = l * r - s * o,
            p = t * u + n * h + i * d;
          if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
          const f = 1 / p;
          return (
            (e[0] = u * f),
            (e[1] = (i * l - c * n) * f),
            (e[2] = (a * n - i * s) * f),
            (e[3] = h * f),
            (e[4] = (c * t - i * o) * f),
            (e[5] = (i * r - a * t) * f),
            (e[6] = d * f),
            (e[7] = (n * o - l * t) * f),
            (e[8] = (s * t - n * r) * f),
            this
          );
        }
        transpose() {
          let e;
          const t = this.elements;
          return (
            (e = t[1]),
            (t[1] = t[3]),
            (t[3] = e),
            (e = t[2]),
            (t[2] = t[6]),
            (t[6] = e),
            (e = t[5]),
            (t[5] = t[7]),
            (t[7] = e),
            this
          );
        }
        getNormalMatrix(e) {
          return this.setFromMatrix4(e).invert().transpose();
        }
        transposeIntoArray(e) {
          const t = this.elements;
          return (
            (e[0] = t[0]),
            (e[1] = t[3]),
            (e[2] = t[6]),
            (e[3] = t[1]),
            (e[4] = t[4]),
            (e[5] = t[7]),
            (e[6] = t[2]),
            (e[7] = t[5]),
            (e[8] = t[8]),
            this
          );
        }
        setUvTransform(e, t, n, i, r, s, a) {
          const o = Math.cos(r),
            l = Math.sin(r);
          return (
            this.set(
              n * o,
              n * l,
              -n * (o * s + l * a) + s + e,
              -i * l,
              i * o,
              -i * (-l * s + o * a) + a + t,
              0,
              0,
              1
            ),
            this
          );
        }
        scale(e, t) {
          const n = this.elements;
          return (
            (n[0] *= e),
            (n[3] *= e),
            (n[6] *= e),
            (n[1] *= t),
            (n[4] *= t),
            (n[7] *= t),
            this
          );
        }
        rotate(e) {
          const t = Math.cos(e),
            n = Math.sin(e),
            i = this.elements,
            r = i[0],
            s = i[3],
            a = i[6],
            o = i[1],
            l = i[4],
            c = i[7];
          return (
            (i[0] = t * r + n * o),
            (i[3] = t * s + n * l),
            (i[6] = t * a + n * c),
            (i[1] = -n * r + t * o),
            (i[4] = -n * s + t * l),
            (i[7] = -n * a + t * c),
            this
          );
        }
        translate(e, t) {
          const n = this.elements;
          return (
            (n[0] += e * n[2]),
            (n[3] += e * n[5]),
            (n[6] += e * n[8]),
            (n[1] += t * n[2]),
            (n[4] += t * n[5]),
            (n[7] += t * n[8]),
            this
          );
        }
        equals(e) {
          const t = this.elements,
            n = e.elements;
          for (let e = 0; e < 9; e++) if (t[e] !== n[e]) return !1;
          return !0;
        }
        fromArray(e, t = 0) {
          for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
          return this;
        }
        toArray(e = [], t = 0) {
          const n = this.elements;
          return (
            (e[t] = n[0]),
            (e[t + 1] = n[1]),
            (e[t + 2] = n[2]),
            (e[t + 3] = n[3]),
            (e[t + 4] = n[4]),
            (e[t + 5] = n[5]),
            (e[t + 6] = n[6]),
            (e[t + 7] = n[7]),
            (e[t + 8] = n[8]),
            e
          );
        }
        clone() {
          return new this.constructor().fromArray(this.elements);
        }
      }
      function Z(e) {
        for (let t = e.length - 1; t >= 0; --t) if (e[t] > 65535) return !0;
        return !1;
      }
      function $(e) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", e);
      }
      function K(e) {
        return e < 0.04045
          ? 0.0773993808 * e
          : Math.pow(0.9478672986 * e + 0.0521327014, 2.4);
      }
      function J(e) {
        return e < 0.0031308 ? 12.92 * e : 1.055 * Math.pow(e, 0.41666) - 0.055;
      }
      Int8Array,
        Uint8Array,
        Uint8ClampedArray,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array;
      const Q = { [R]: { [I]: K }, [I]: { [R]: J } },
        ee = {
          legacyMode: !0,
          get workingColorSpace() {
            return I;
          },
          set workingColorSpace(e) {
            console.warn(
              "THREE.ColorManagement: .workingColorSpace is readonly."
            );
          },
          convert: function (e, t, n) {
            if (this.legacyMode || t === n || !t || !n) return e;
            if (Q[t] && void 0 !== Q[t][n]) {
              const i = Q[t][n];
              return (e.r = i(e.r)), (e.g = i(e.g)), (e.b = i(e.b)), e;
            }
            throw new Error("Unsupported color space conversion.");
          },
          fromWorkingColorSpace: function (e, t) {
            return this.convert(e, this.workingColorSpace, t);
          },
          toWorkingColorSpace: function (e, t) {
            return this.convert(e, t, this.workingColorSpace);
          },
        },
        te = {
          aliceblue: 15792383,
          antiquewhite: 16444375,
          aqua: 65535,
          aquamarine: 8388564,
          azure: 15794175,
          beige: 16119260,
          bisque: 16770244,
          black: 0,
          blanchedalmond: 16772045,
          blue: 255,
          blueviolet: 9055202,
          brown: 10824234,
          burlywood: 14596231,
          cadetblue: 6266528,
          chartreuse: 8388352,
          chocolate: 13789470,
          coral: 16744272,
          cornflowerblue: 6591981,
          cornsilk: 16775388,
          crimson: 14423100,
          cyan: 65535,
          darkblue: 139,
          darkcyan: 35723,
          darkgoldenrod: 12092939,
          darkgray: 11119017,
          darkgreen: 25600,
          darkgrey: 11119017,
          darkkhaki: 12433259,
          darkmagenta: 9109643,
          darkolivegreen: 5597999,
          darkorange: 16747520,
          darkorchid: 10040012,
          darkred: 9109504,
          darksalmon: 15308410,
          darkseagreen: 9419919,
          darkslateblue: 4734347,
          darkslategray: 3100495,
          darkslategrey: 3100495,
          darkturquoise: 52945,
          darkviolet: 9699539,
          deeppink: 16716947,
          deepskyblue: 49151,
          dimgray: 6908265,
          dimgrey: 6908265,
          dodgerblue: 2003199,
          firebrick: 11674146,
          floralwhite: 16775920,
          forestgreen: 2263842,
          fuchsia: 16711935,
          gainsboro: 14474460,
          ghostwhite: 16316671,
          gold: 16766720,
          goldenrod: 14329120,
          gray: 8421504,
          green: 32768,
          greenyellow: 11403055,
          grey: 8421504,
          honeydew: 15794160,
          hotpink: 16738740,
          indianred: 13458524,
          indigo: 4915330,
          ivory: 16777200,
          khaki: 15787660,
          lavender: 15132410,
          lavenderblush: 16773365,
          lawngreen: 8190976,
          lemonchiffon: 16775885,
          lightblue: 11393254,
          lightcoral: 15761536,
          lightcyan: 14745599,
          lightgoldenrodyellow: 16448210,
          lightgray: 13882323,
          lightgreen: 9498256,
          lightgrey: 13882323,
          lightpink: 16758465,
          lightsalmon: 16752762,
          lightseagreen: 2142890,
          lightskyblue: 8900346,
          lightslategray: 7833753,
          lightslategrey: 7833753,
          lightsteelblue: 11584734,
          lightyellow: 16777184,
          lime: 65280,
          limegreen: 3329330,
          linen: 16445670,
          magenta: 16711935,
          maroon: 8388608,
          mediumaquamarine: 6737322,
          mediumblue: 205,
          mediumorchid: 12211667,
          mediumpurple: 9662683,
          mediumseagreen: 3978097,
          mediumslateblue: 8087790,
          mediumspringgreen: 64154,
          mediumturquoise: 4772300,
          mediumvioletred: 13047173,
          midnightblue: 1644912,
          mintcream: 16121850,
          mistyrose: 16770273,
          moccasin: 16770229,
          navajowhite: 16768685,
          navy: 128,
          oldlace: 16643558,
          olive: 8421376,
          olivedrab: 7048739,
          orange: 16753920,
          orangered: 16729344,
          orchid: 14315734,
          palegoldenrod: 15657130,
          palegreen: 10025880,
          paleturquoise: 11529966,
          palevioletred: 14381203,
          papayawhip: 16773077,
          peachpuff: 16767673,
          peru: 13468991,
          pink: 16761035,
          plum: 14524637,
          powderblue: 11591910,
          purple: 8388736,
          rebeccapurple: 6697881,
          red: 16711680,
          rosybrown: 12357519,
          royalblue: 4286945,
          saddlebrown: 9127187,
          salmon: 16416882,
          sandybrown: 16032864,
          seagreen: 3050327,
          seashell: 16774638,
          sienna: 10506797,
          silver: 12632256,
          skyblue: 8900331,
          slateblue: 6970061,
          slategray: 7372944,
          slategrey: 7372944,
          snow: 16775930,
          springgreen: 65407,
          steelblue: 4620980,
          tan: 13808780,
          teal: 32896,
          thistle: 14204888,
          tomato: 16737095,
          turquoise: 4251856,
          violet: 15631086,
          wheat: 16113331,
          white: 16777215,
          whitesmoke: 16119285,
          yellow: 16776960,
          yellowgreen: 10145074,
        },
        ne = { r: 0, g: 0, b: 0 },
        ie = { h: 0, s: 0, l: 0 },
        re = { h: 0, s: 0, l: 0 };
      function se(e, t, n) {
        return (
          n < 0 && (n += 1),
          n > 1 && (n -= 1),
          n < 1 / 6
            ? e + 6 * (t - e) * n
            : n < 0.5
            ? t
            : n < 2 / 3
            ? e + 6 * (t - e) * (2 / 3 - n)
            : e
        );
      }
      function ae(e, t) {
        return (t.r = e.r), (t.g = e.g), (t.b = e.b), t;
      }
      class oe {
        constructor(e, t, n) {
          return (
            (this.isColor = !0),
            (this.r = 1),
            (this.g = 1),
            (this.b = 1),
            void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n)
          );
        }
        set(e) {
          return (
            e && e.isColor
              ? this.copy(e)
              : "number" == typeof e
              ? this.setHex(e)
              : "string" == typeof e && this.setStyle(e),
            this
          );
        }
        setScalar(e) {
          return (this.r = e), (this.g = e), (this.b = e), this;
        }
        setHex(e, t = "srgb") {
          return (
            (e = Math.floor(e)),
            (this.r = ((e >> 16) & 255) / 255),
            (this.g = ((e >> 8) & 255) / 255),
            (this.b = (255 & e) / 255),
            ee.toWorkingColorSpace(this, t),
            this
          );
        }
        setRGB(e, t, n, i = "srgb-linear") {
          return (
            (this.r = e),
            (this.g = t),
            (this.b = n),
            ee.toWorkingColorSpace(this, i),
            this
          );
        }
        setHSL(e, t, n, i = "srgb-linear") {
          if (
            ((e = ((e % (r = 1)) + r) % r),
            (t = H(t, 0, 1)),
            (n = H(n, 0, 1)),
            0 === t)
          )
            this.r = this.g = this.b = n;
          else {
            const i = n <= 0.5 ? n * (1 + t) : n + t - n * t,
              r = 2 * n - i;
            (this.r = se(r, i, e + 1 / 3)),
              (this.g = se(r, i, e)),
              (this.b = se(r, i, e - 1 / 3));
          }
          var r;
          return ee.toWorkingColorSpace(this, i), this;
        }
        setStyle(e, t = "srgb") {
          function n(t) {
            void 0 !== t &&
              parseFloat(t) < 1 &&
              console.warn(
                "THREE.Color: Alpha component of " + e + " will be ignored."
              );
          }
          let i;
          if ((i = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e))) {
            let e;
            const r = i[1],
              s = i[2];
            switch (r) {
              case "rgb":
              case "rgba":
                if (
                  (e =
                    /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      s
                    ))
                )
                  return (
                    (this.r = Math.min(255, parseInt(e[1], 10)) / 255),
                    (this.g = Math.min(255, parseInt(e[2], 10)) / 255),
                    (this.b = Math.min(255, parseInt(e[3], 10)) / 255),
                    ee.toWorkingColorSpace(this, t),
                    n(e[4]),
                    this
                  );
                if (
                  (e =
                    /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      s
                    ))
                )
                  return (
                    (this.r = Math.min(100, parseInt(e[1], 10)) / 100),
                    (this.g = Math.min(100, parseInt(e[2], 10)) / 100),
                    (this.b = Math.min(100, parseInt(e[3], 10)) / 100),
                    ee.toWorkingColorSpace(this, t),
                    n(e[4]),
                    this
                  );
                break;
              case "hsl":
              case "hsla":
                if (
                  (e =
                    /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      s
                    ))
                ) {
                  const i = parseFloat(e[1]) / 360,
                    r = parseInt(e[2], 10) / 100,
                    s = parseInt(e[3], 10) / 100;
                  return n(e[4]), this.setHSL(i, r, s, t);
                }
            }
          } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(e))) {
            const e = i[1],
              n = e.length;
            if (3 === n)
              return (
                (this.r = parseInt(e.charAt(0) + e.charAt(0), 16) / 255),
                (this.g = parseInt(e.charAt(1) + e.charAt(1), 16) / 255),
                (this.b = parseInt(e.charAt(2) + e.charAt(2), 16) / 255),
                ee.toWorkingColorSpace(this, t),
                this
              );
            if (6 === n)
              return (
                (this.r = parseInt(e.charAt(0) + e.charAt(1), 16) / 255),
                (this.g = parseInt(e.charAt(2) + e.charAt(3), 16) / 255),
                (this.b = parseInt(e.charAt(4) + e.charAt(5), 16) / 255),
                ee.toWorkingColorSpace(this, t),
                this
              );
          }
          return e && e.length > 0 ? this.setColorName(e, t) : this;
        }
        setColorName(e, t = "srgb") {
          const n = te[e.toLowerCase()];
          return (
            void 0 !== n
              ? this.setHex(n, t)
              : console.warn("THREE.Color: Unknown color " + e),
            this
          );
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b);
        }
        copy(e) {
          return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
        }
        copySRGBToLinear(e) {
          return (this.r = K(e.r)), (this.g = K(e.g)), (this.b = K(e.b)), this;
        }
        copyLinearToSRGB(e) {
          return (this.r = J(e.r)), (this.g = J(e.g)), (this.b = J(e.b)), this;
        }
        convertSRGBToLinear() {
          return this.copySRGBToLinear(this), this;
        }
        convertLinearToSRGB() {
          return this.copyLinearToSRGB(this), this;
        }
        getHex(e = "srgb") {
          return (
            ee.fromWorkingColorSpace(ae(this, ne), e),
            (H(255 * ne.r, 0, 255) << 16) ^
              (H(255 * ne.g, 0, 255) << 8) ^
              (H(255 * ne.b, 0, 255) << 0)
          );
        }
        getHexString(e = "srgb") {
          return ("000000" + this.getHex(e).toString(16)).slice(-6);
        }
        getHSL(e, t = "srgb-linear") {
          ee.fromWorkingColorSpace(ae(this, ne), t);
          const n = ne.r,
            i = ne.g,
            r = ne.b,
            s = Math.max(n, i, r),
            a = Math.min(n, i, r);
          let o, l;
          const c = (a + s) / 2;
          if (a === s) (o = 0), (l = 0);
          else {
            const e = s - a;
            switch (((l = c <= 0.5 ? e / (s + a) : e / (2 - s - a)), s)) {
              case n:
                o = (i - r) / e + (i < r ? 6 : 0);
                break;
              case i:
                o = (r - n) / e + 2;
                break;
              case r:
                o = (n - i) / e + 4;
            }
            o /= 6;
          }
          return (e.h = o), (e.s = l), (e.l = c), e;
        }
        getRGB(e, t = "srgb-linear") {
          return (
            ee.fromWorkingColorSpace(ae(this, ne), t),
            (e.r = ne.r),
            (e.g = ne.g),
            (e.b = ne.b),
            e
          );
        }
        getStyle(e = "srgb") {
          return (
            ee.fromWorkingColorSpace(ae(this, ne), e),
            e !== R
              ? `color(${e} ${ne.r} ${ne.g} ${ne.b})`
              : `rgb(${(255 * ne.r) | 0},${(255 * ne.g) | 0},${
                  (255 * ne.b) | 0
                })`
          );
        }
        offsetHSL(e, t, n) {
          return (
            this.getHSL(ie),
            (ie.h += e),
            (ie.s += t),
            (ie.l += n),
            this.setHSL(ie.h, ie.s, ie.l),
            this
          );
        }
        add(e) {
          return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
        }
        addColors(e, t) {
          return (
            (this.r = e.r + t.r),
            (this.g = e.g + t.g),
            (this.b = e.b + t.b),
            this
          );
        }
        addScalar(e) {
          return (this.r += e), (this.g += e), (this.b += e), this;
        }
        sub(e) {
          return (
            (this.r = Math.max(0, this.r - e.r)),
            (this.g = Math.max(0, this.g - e.g)),
            (this.b = Math.max(0, this.b - e.b)),
            this
          );
        }
        multiply(e) {
          return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
        }
        multiplyScalar(e) {
          return (this.r *= e), (this.g *= e), (this.b *= e), this;
        }
        lerp(e, t) {
          return (
            (this.r += (e.r - this.r) * t),
            (this.g += (e.g - this.g) * t),
            (this.b += (e.b - this.b) * t),
            this
          );
        }
        lerpColors(e, t, n) {
          return (
            (this.r = e.r + (t.r - e.r) * n),
            (this.g = e.g + (t.g - e.g) * n),
            (this.b = e.b + (t.b - e.b) * n),
            this
          );
        }
        lerpHSL(e, t) {
          this.getHSL(ie), e.getHSL(re);
          const n = W(ie.h, re.h, t),
            i = W(ie.s, re.s, t),
            r = W(ie.l, re.l, t);
          return this.setHSL(n, i, r), this;
        }
        equals(e) {
          return e.r === this.r && e.g === this.g && e.b === this.b;
        }
        fromArray(e, t = 0) {
          return (
            (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this
          );
        }
        toArray(e = [], t = 0) {
          return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
        }
        fromBufferAttribute(e, t) {
          return (
            (this.r = e.getX(t)),
            (this.g = e.getY(t)),
            (this.b = e.getZ(t)),
            !0 === e.normalized &&
              ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
            this
          );
        }
        toJSON() {
          return this.getHex();
        }
        *[Symbol.iterator]() {
          yield this.r, yield this.g, yield this.b;
        }
      }
      let le;
      oe.NAMES = te;
      class ce {
        static getDataURL(e) {
          if (/^data:/i.test(e.src)) return e.src;
          if ("undefined" == typeof HTMLCanvasElement) return e.src;
          let t;
          if (e instanceof HTMLCanvasElement) t = e;
          else {
            void 0 === le && (le = $("canvas")),
              (le.width = e.width),
              (le.height = e.height);
            const n = le.getContext("2d");
            e instanceof ImageData
              ? n.putImageData(e, 0, 0)
              : n.drawImage(e, 0, 0, e.width, e.height),
              (t = le);
          }
          return t.width > 2048 || t.height > 2048
            ? (console.warn(
                "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
                e
              ),
              t.toDataURL("image/jpeg", 0.6))
            : t.toDataURL("image/png");
        }
        static sRGBToLinear(e) {
          if (
            ("undefined" != typeof HTMLImageElement &&
              e instanceof HTMLImageElement) ||
            ("undefined" != typeof HTMLCanvasElement &&
              e instanceof HTMLCanvasElement) ||
            ("undefined" != typeof ImageBitmap && e instanceof ImageBitmap)
          ) {
            const t = $("canvas");
            (t.width = e.width), (t.height = e.height);
            const n = t.getContext("2d");
            n.drawImage(e, 0, 0, e.width, e.height);
            const i = n.getImageData(0, 0, e.width, e.height),
              r = i.data;
            for (let e = 0; e < r.length; e++) r[e] = 255 * K(r[e] / 255);
            return n.putImageData(i, 0, 0), t;
          }
          if (e.data) {
            const t = e.data.slice(0);
            for (let e = 0; e < t.length; e++)
              t instanceof Uint8Array || t instanceof Uint8ClampedArray
                ? (t[e] = Math.floor(255 * K(t[e] / 255)))
                : (t[e] = K(t[e]));
            return { data: t, width: e.width, height: e.height };
          }
          return (
            console.warn(
              "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
            ),
            e
          );
        }
      }
      class ue {
        constructor(e = null) {
          (this.isSource = !0),
            (this.uuid = G()),
            (this.data = e),
            (this.version = 0);
        }
        set needsUpdate(e) {
          !0 === e && this.version++;
        }
        toJSON(e) {
          const t = void 0 === e || "string" == typeof e;
          if (!t && void 0 !== e.images[this.uuid]) return e.images[this.uuid];
          const n = { uuid: this.uuid, url: "" },
            i = this.data;
          if (null !== i) {
            let e;
            if (Array.isArray(i)) {
              e = [];
              for (let t = 0, n = i.length; t < n; t++)
                i[t].isDataTexture ? e.push(he(i[t].image)) : e.push(he(i[t]));
            } else e = he(i);
            n.url = e;
          }
          return t || (e.images[this.uuid] = n), n;
        }
      }
      function he(e) {
        return ("undefined" != typeof HTMLImageElement &&
          e instanceof HTMLImageElement) ||
          ("undefined" != typeof HTMLCanvasElement &&
            e instanceof HTMLCanvasElement) ||
          ("undefined" != typeof ImageBitmap && e instanceof ImageBitmap)
          ? ce.getDataURL(e)
          : e.data
          ? {
              data: Array.from(e.data),
              width: e.width,
              height: e.height,
              type: e.data.constructor.name,
            }
          : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
      }
      let de = 0;
      class pe extends z {
        constructor(
          e = pe.DEFAULT_IMAGE,
          t = pe.DEFAULT_MAPPING,
          n = 1001,
          i = 1001,
          r = 1006,
          s = 1008,
          a = 1023,
          o = 1009,
          l = 1,
          c = 3e3
        ) {
          super(),
            (this.isTexture = !0),
            Object.defineProperty(this, "id", { value: de++ }),
            (this.uuid = G()),
            (this.name = ""),
            (this.source = new ue(e)),
            (this.mipmaps = []),
            (this.mapping = t),
            (this.wrapS = n),
            (this.wrapT = i),
            (this.magFilter = r),
            (this.minFilter = s),
            (this.anisotropy = l),
            (this.format = a),
            (this.internalFormat = null),
            (this.type = o),
            (this.offset = new X(0, 0)),
            (this.repeat = new X(1, 1)),
            (this.center = new X(0, 0)),
            (this.rotation = 0),
            (this.matrixAutoUpdate = !0),
            (this.matrix = new Y()),
            (this.generateMipmaps = !0),
            (this.premultiplyAlpha = !1),
            (this.flipY = !0),
            (this.unpackAlignment = 4),
            (this.encoding = c),
            (this.userData = {}),
            (this.version = 0),
            (this.onUpdate = null),
            (this.isRenderTargetTexture = !1),
            (this.needsPMREMUpdate = !1);
        }
        get image() {
          return this.source.data;
        }
        set image(e) {
          this.source.data = e;
        }
        updateMatrix() {
          this.matrix.setUvTransform(
            this.offset.x,
            this.offset.y,
            this.repeat.x,
            this.repeat.y,
            this.rotation,
            this.center.x,
            this.center.y
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return (
            (this.name = e.name),
            (this.source = e.source),
            (this.mipmaps = e.mipmaps.slice(0)),
            (this.mapping = e.mapping),
            (this.wrapS = e.wrapS),
            (this.wrapT = e.wrapT),
            (this.magFilter = e.magFilter),
            (this.minFilter = e.minFilter),
            (this.anisotropy = e.anisotropy),
            (this.format = e.format),
            (this.internalFormat = e.internalFormat),
            (this.type = e.type),
            this.offset.copy(e.offset),
            this.repeat.copy(e.repeat),
            this.center.copy(e.center),
            (this.rotation = e.rotation),
            (this.matrixAutoUpdate = e.matrixAutoUpdate),
            this.matrix.copy(e.matrix),
            (this.generateMipmaps = e.generateMipmaps),
            (this.premultiplyAlpha = e.premultiplyAlpha),
            (this.flipY = e.flipY),
            (this.unpackAlignment = e.unpackAlignment),
            (this.encoding = e.encoding),
            (this.userData = JSON.parse(JSON.stringify(e.userData))),
            (this.needsUpdate = !0),
            this
          );
        }
        toJSON(e) {
          const t = void 0 === e || "string" == typeof e;
          if (!t && void 0 !== e.textures[this.uuid])
            return e.textures[this.uuid];
          const n = {
            metadata: {
              version: 4.5,
              type: "Texture",
              generator: "Texture.toJSON",
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment,
          };
          return (
            "{}" !== JSON.stringify(this.userData) &&
              (n.userData = this.userData),
            t || (e.textures[this.uuid] = n),
            n
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        transformUv(e) {
          if (300 !== this.mapping) return e;
          if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
            switch (this.wrapS) {
              case u:
                e.x = e.x - Math.floor(e.x);
                break;
              case h:
                e.x = e.x < 0 ? 0 : 1;
                break;
              case d:
                1 === Math.abs(Math.floor(e.x) % 2)
                  ? (e.x = Math.ceil(e.x) - e.x)
                  : (e.x = e.x - Math.floor(e.x));
            }
          if (e.y < 0 || e.y > 1)
            switch (this.wrapT) {
              case u:
                e.y = e.y - Math.floor(e.y);
                break;
              case h:
                e.y = e.y < 0 ? 0 : 1;
                break;
              case d:
                1 === Math.abs(Math.floor(e.y) % 2)
                  ? (e.y = Math.ceil(e.y) - e.y)
                  : (e.y = e.y - Math.floor(e.y));
            }
          return this.flipY && (e.y = 1 - e.y), e;
        }
        set needsUpdate(e) {
          !0 === e && (this.version++, (this.source.needsUpdate = !0));
        }
      }
      (pe.DEFAULT_IMAGE = null), (pe.DEFAULT_MAPPING = 300);
      class fe {
        constructor(e = 0, t = 0, n = 0, i = 1) {
          (fe.prototype.isVector4 = !0),
            (this.x = e),
            (this.y = t),
            (this.z = n),
            (this.w = i);
        }
        get width() {
          return this.z;
        }
        set width(e) {
          this.z = e;
        }
        get height() {
          return this.w;
        }
        set height(e) {
          this.w = e;
        }
        set(e, t, n, i) {
          return (this.x = e), (this.y = t), (this.z = n), (this.w = i), this;
        }
        setScalar(e) {
          return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
        }
        setX(e) {
          return (this.x = e), this;
        }
        setY(e) {
          return (this.y = e), this;
        }
        setZ(e) {
          return (this.z = e), this;
        }
        setW(e) {
          return (this.w = e), this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            case 2:
              this.z = t;
              break;
            case 3:
              this.w = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(e) {
          return (
            (this.x = e.x),
            (this.y = e.y),
            (this.z = e.z),
            (this.w = void 0 !== e.w ? e.w : 1),
            this
          );
        }
        add(e, t) {
          return void 0 !== t
            ? (console.warn(
                "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(e, t))
            : ((this.x += e.x),
              (this.y += e.y),
              (this.z += e.z),
              (this.w += e.w),
              this);
        }
        addScalar(e) {
          return (
            (this.x += e), (this.y += e), (this.z += e), (this.w += e), this
          );
        }
        addVectors(e, t) {
          return (
            (this.x = e.x + t.x),
            (this.y = e.y + t.y),
            (this.z = e.z + t.z),
            (this.w = e.w + t.w),
            this
          );
        }
        addScaledVector(e, t) {
          return (
            (this.x += e.x * t),
            (this.y += e.y * t),
            (this.z += e.z * t),
            (this.w += e.w * t),
            this
          );
        }
        sub(e, t) {
          return void 0 !== t
            ? (console.warn(
                "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(e, t))
            : ((this.x -= e.x),
              (this.y -= e.y),
              (this.z -= e.z),
              (this.w -= e.w),
              this);
        }
        subScalar(e) {
          return (
            (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this
          );
        }
        subVectors(e, t) {
          return (
            (this.x = e.x - t.x),
            (this.y = e.y - t.y),
            (this.z = e.z - t.z),
            (this.w = e.w - t.w),
            this
          );
        }
        multiply(e) {
          return (
            (this.x *= e.x),
            (this.y *= e.y),
            (this.z *= e.z),
            (this.w *= e.w),
            this
          );
        }
        multiplyScalar(e) {
          return (
            (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this
          );
        }
        applyMatrix4(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = this.w,
            s = e.elements;
          return (
            (this.x = s[0] * t + s[4] * n + s[8] * i + s[12] * r),
            (this.y = s[1] * t + s[5] * n + s[9] * i + s[13] * r),
            (this.z = s[2] * t + s[6] * n + s[10] * i + s[14] * r),
            (this.w = s[3] * t + s[7] * n + s[11] * i + s[15] * r),
            this
          );
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        setAxisAngleFromQuaternion(e) {
          this.w = 2 * Math.acos(e.w);
          const t = Math.sqrt(1 - e.w * e.w);
          return (
            t < 1e-4
              ? ((this.x = 1), (this.y = 0), (this.z = 0))
              : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
            this
          );
        }
        setAxisAngleFromRotationMatrix(e) {
          let t, n, i, r;
          const s = 0.01,
            a = 0.1,
            o = e.elements,
            l = o[0],
            c = o[4],
            u = o[8],
            h = o[1],
            d = o[5],
            p = o[9],
            f = o[2],
            m = o[6],
            g = o[10];
          if (
            Math.abs(c - h) < s &&
            Math.abs(u - f) < s &&
            Math.abs(p - m) < s
          ) {
            if (
              Math.abs(c + h) < a &&
              Math.abs(u + f) < a &&
              Math.abs(p + m) < a &&
              Math.abs(l + d + g - 3) < a
            )
              return this.set(1, 0, 0, 0), this;
            t = Math.PI;
            const e = (l + 1) / 2,
              o = (d + 1) / 2,
              v = (g + 1) / 2,
              _ = (c + h) / 4,
              x = (u + f) / 4,
              y = (p + m) / 4;
            return (
              e > o && e > v
                ? e < s
                  ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
                  : ((n = Math.sqrt(e)), (i = _ / n), (r = x / n))
                : o > v
                ? o < s
                  ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
                  : ((i = Math.sqrt(o)), (n = _ / i), (r = y / i))
                : v < s
                ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
                : ((r = Math.sqrt(v)), (n = x / r), (i = y / r)),
              this.set(n, i, r, t),
              this
            );
          }
          let v = Math.sqrt(
            (m - p) * (m - p) + (u - f) * (u - f) + (h - c) * (h - c)
          );
          return (
            Math.abs(v) < 0.001 && (v = 1),
            (this.x = (m - p) / v),
            (this.y = (u - f) / v),
            (this.z = (h - c) / v),
            (this.w = Math.acos((l + d + g - 1) / 2)),
            this
          );
        }
        min(e) {
          return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            (this.z = Math.min(this.z, e.z)),
            (this.w = Math.min(this.w, e.w)),
            this
          );
        }
        max(e) {
          return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            (this.z = Math.max(this.z, e.z)),
            (this.w = Math.max(this.w, e.w)),
            this
          );
        }
        clamp(e, t) {
          return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            (this.z = Math.max(e.z, Math.min(t.z, this.z))),
            (this.w = Math.max(e.w, Math.min(t.w, this.w))),
            this
          );
        }
        clampScalar(e, t) {
          return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            (this.z = Math.max(e, Math.min(t, this.z))),
            (this.w = Math.max(e, Math.min(t, this.w))),
            this
          );
        }
        clampLength(e, t) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(e, Math.min(t, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            (this.w = Math.floor(this.w)),
            this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            (this.w = Math.ceil(this.w)),
            this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            (this.w = Math.round(this.w)),
            this
          );
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
            (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
            this
          );
        }
        negate() {
          return (
            (this.x = -this.x),
            (this.y = -this.y),
            (this.z = -this.z),
            (this.w = -this.w),
            this
          );
        }
        dot(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
        }
        lengthSq() {
          return (
            this.x * this.x +
            this.y * this.y +
            this.z * this.z +
            this.w * this.w
          );
        }
        length() {
          return Math.sqrt(
            this.x * this.x +
              this.y * this.y +
              this.z * this.z +
              this.w * this.w
          );
        }
        manhattanLength() {
          return (
            Math.abs(this.x) +
            Math.abs(this.y) +
            Math.abs(this.z) +
            Math.abs(this.w)
          );
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return (
            (this.x += (e.x - this.x) * t),
            (this.y += (e.y - this.y) * t),
            (this.z += (e.z - this.z) * t),
            (this.w += (e.w - this.w) * t),
            this
          );
        }
        lerpVectors(e, t, n) {
          return (
            (this.x = e.x + (t.x - e.x) * n),
            (this.y = e.y + (t.y - e.y) * n),
            (this.z = e.z + (t.z - e.z) * n),
            (this.w = e.w + (t.w - e.w) * n),
            this
          );
        }
        equals(e) {
          return (
            e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
          );
        }
        fromArray(e, t = 0) {
          return (
            (this.x = e[t]),
            (this.y = e[t + 1]),
            (this.z = e[t + 2]),
            (this.w = e[t + 3]),
            this
          );
        }
        toArray(e = [], t = 0) {
          return (
            (e[t] = this.x),
            (e[t + 1] = this.y),
            (e[t + 2] = this.z),
            (e[t + 3] = this.w),
            e
          );
        }
        fromBufferAttribute(e, t, n) {
          return (
            void 0 !== n &&
              console.warn(
                "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = e.getX(t)),
            (this.y = e.getY(t)),
            (this.z = e.getZ(t)),
            (this.w = e.getW(t)),
            this
          );
        }
        random() {
          return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            (this.w = Math.random()),
            this
          );
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z, yield this.w;
        }
      }
      class me extends z {
        constructor(e, t, n = {}) {
          super(),
            (this.isWebGLRenderTarget = !0),
            (this.width = e),
            (this.height = t),
            (this.depth = 1),
            (this.scissor = new fe(0, 0, e, t)),
            (this.scissorTest = !1),
            (this.viewport = new fe(0, 0, e, t));
          const i = { width: e, height: t, depth: 1 };
          (this.texture = new pe(
            i,
            n.mapping,
            n.wrapS,
            n.wrapT,
            n.magFilter,
            n.minFilter,
            n.format,
            n.type,
            n.anisotropy,
            n.encoding
          )),
            (this.texture.isRenderTargetTexture = !0),
            (this.texture.flipY = !1),
            (this.texture.generateMipmaps =
              void 0 !== n.generateMipmaps && n.generateMipmaps),
            (this.texture.internalFormat =
              void 0 !== n.internalFormat ? n.internalFormat : null),
            (this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : f),
            (this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer),
            (this.stencilBuffer =
              void 0 !== n.stencilBuffer && n.stencilBuffer),
            (this.depthTexture =
              void 0 !== n.depthTexture ? n.depthTexture : null),
            (this.samples = void 0 !== n.samples ? n.samples : 0);
        }
        setSize(e, t, n = 1) {
          (this.width === e && this.height === t && this.depth === n) ||
            ((this.width = e),
            (this.height = t),
            (this.depth = n),
            (this.texture.image.width = e),
            (this.texture.image.height = t),
            (this.texture.image.depth = n),
            this.dispose()),
            this.viewport.set(0, 0, e, t),
            this.scissor.set(0, 0, e, t);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          (this.width = e.width),
            (this.height = e.height),
            (this.depth = e.depth),
            this.viewport.copy(e.viewport),
            (this.texture = e.texture.clone()),
            (this.texture.isRenderTargetTexture = !0);
          const t = Object.assign({}, e.texture.image);
          return (
            (this.texture.source = new ue(t)),
            (this.depthBuffer = e.depthBuffer),
            (this.stencilBuffer = e.stencilBuffer),
            null !== e.depthTexture &&
              (this.depthTexture = e.depthTexture.clone()),
            (this.samples = e.samples),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      class ge extends pe {
        constructor(e = null, t = 1, n = 1, i = 1) {
          super(null),
            (this.isDataArrayTexture = !0),
            (this.image = { data: e, width: t, height: n, depth: i }),
            (this.magFilter = p),
            (this.minFilter = p),
            (this.wrapR = h),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
        }
      }
      class ve extends pe {
        constructor(e = null, t = 1, n = 1, i = 1) {
          super(null),
            (this.isData3DTexture = !0),
            (this.image = { data: e, width: t, height: n, depth: i }),
            (this.magFilter = p),
            (this.minFilter = p),
            (this.wrapR = h),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
        }
      }
      class _e {
        constructor(e = 0, t = 0, n = 0, i = 1) {
          (this.isQuaternion = !0),
            (this._x = e),
            (this._y = t),
            (this._z = n),
            (this._w = i);
        }
        static slerp(e, t, n, i) {
          return (
            console.warn(
              "THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."
            ),
            n.slerpQuaternions(e, t, i)
          );
        }
        static slerpFlat(e, t, n, i, r, s, a) {
          let o = n[i + 0],
            l = n[i + 1],
            c = n[i + 2],
            u = n[i + 3];
          const h = r[s + 0],
            d = r[s + 1],
            p = r[s + 2],
            f = r[s + 3];
          if (0 === a)
            return (
              (e[t + 0] = o),
              (e[t + 1] = l),
              (e[t + 2] = c),
              void (e[t + 3] = u)
            );
          if (1 === a)
            return (
              (e[t + 0] = h),
              (e[t + 1] = d),
              (e[t + 2] = p),
              void (e[t + 3] = f)
            );
          if (u !== f || o !== h || l !== d || c !== p) {
            let e = 1 - a;
            const t = o * h + l * d + c * p + u * f,
              n = t >= 0 ? 1 : -1,
              i = 1 - t * t;
            if (i > Number.EPSILON) {
              const r = Math.sqrt(i),
                s = Math.atan2(r, t * n);
              (e = Math.sin(e * s) / r), (a = Math.sin(a * s) / r);
            }
            const r = a * n;
            if (
              ((o = o * e + h * r),
              (l = l * e + d * r),
              (c = c * e + p * r),
              (u = u * e + f * r),
              e === 1 - a)
            ) {
              const e = 1 / Math.sqrt(o * o + l * l + c * c + u * u);
              (o *= e), (l *= e), (c *= e), (u *= e);
            }
          }
          (e[t] = o), (e[t + 1] = l), (e[t + 2] = c), (e[t + 3] = u);
        }
        static multiplyQuaternionsFlat(e, t, n, i, r, s) {
          const a = n[i],
            o = n[i + 1],
            l = n[i + 2],
            c = n[i + 3],
            u = r[s],
            h = r[s + 1],
            d = r[s + 2],
            p = r[s + 3];
          return (
            (e[t] = a * p + c * u + o * d - l * h),
            (e[t + 1] = o * p + c * h + l * u - a * d),
            (e[t + 2] = l * p + c * d + a * h - o * u),
            (e[t + 3] = c * p - a * u - o * h - l * d),
            e
          );
        }
        get x() {
          return this._x;
        }
        set x(e) {
          (this._x = e), this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(e) {
          (this._y = e), this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(e) {
          (this._z = e), this._onChangeCallback();
        }
        get w() {
          return this._w;
        }
        set w(e) {
          (this._w = e), this._onChangeCallback();
        }
        set(e, t, n, i) {
          return (
            (this._x = e),
            (this._y = t),
            (this._z = n),
            (this._w = i),
            this._onChangeCallback(),
            this
          );
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(e) {
          return (
            (this._x = e.x),
            (this._y = e.y),
            (this._z = e.z),
            (this._w = e.w),
            this._onChangeCallback(),
            this
          );
        }
        setFromEuler(e, t) {
          if (!e || !e.isEuler)
            throw new Error(
              "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
            );
          const n = e._x,
            i = e._y,
            r = e._z,
            s = e._order,
            a = Math.cos,
            o = Math.sin,
            l = a(n / 2),
            c = a(i / 2),
            u = a(r / 2),
            h = o(n / 2),
            d = o(i / 2),
            p = o(r / 2);
          switch (s) {
            case "XYZ":
              (this._x = h * c * u + l * d * p),
                (this._y = l * d * u - h * c * p),
                (this._z = l * c * p + h * d * u),
                (this._w = l * c * u - h * d * p);
              break;
            case "YXZ":
              (this._x = h * c * u + l * d * p),
                (this._y = l * d * u - h * c * p),
                (this._z = l * c * p - h * d * u),
                (this._w = l * c * u + h * d * p);
              break;
            case "ZXY":
              (this._x = h * c * u - l * d * p),
                (this._y = l * d * u + h * c * p),
                (this._z = l * c * p + h * d * u),
                (this._w = l * c * u - h * d * p);
              break;
            case "ZYX":
              (this._x = h * c * u - l * d * p),
                (this._y = l * d * u + h * c * p),
                (this._z = l * c * p - h * d * u),
                (this._w = l * c * u + h * d * p);
              break;
            case "YZX":
              (this._x = h * c * u + l * d * p),
                (this._y = l * d * u + h * c * p),
                (this._z = l * c * p - h * d * u),
                (this._w = l * c * u - h * d * p);
              break;
            case "XZY":
              (this._x = h * c * u - l * d * p),
                (this._y = l * d * u - h * c * p),
                (this._z = l * c * p + h * d * u),
                (this._w = l * c * u + h * d * p);
              break;
            default:
              console.warn(
                "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
                  s
              );
          }
          return !1 !== t && this._onChangeCallback(), this;
        }
        setFromAxisAngle(e, t) {
          const n = t / 2,
            i = Math.sin(n);
          return (
            (this._x = e.x * i),
            (this._y = e.y * i),
            (this._z = e.z * i),
            (this._w = Math.cos(n)),
            this._onChangeCallback(),
            this
          );
        }
        setFromRotationMatrix(e) {
          const t = e.elements,
            n = t[0],
            i = t[4],
            r = t[8],
            s = t[1],
            a = t[5],
            o = t[9],
            l = t[2],
            c = t[6],
            u = t[10],
            h = n + a + u;
          if (h > 0) {
            const e = 0.5 / Math.sqrt(h + 1);
            (this._w = 0.25 / e),
              (this._x = (c - o) * e),
              (this._y = (r - l) * e),
              (this._z = (s - i) * e);
          } else if (n > a && n > u) {
            const e = 2 * Math.sqrt(1 + n - a - u);
            (this._w = (c - o) / e),
              (this._x = 0.25 * e),
              (this._y = (i + s) / e),
              (this._z = (r + l) / e);
          } else if (a > u) {
            const e = 2 * Math.sqrt(1 + a - n - u);
            (this._w = (r - l) / e),
              (this._x = (i + s) / e),
              (this._y = 0.25 * e),
              (this._z = (o + c) / e);
          } else {
            const e = 2 * Math.sqrt(1 + u - n - a);
            (this._w = (s - i) / e),
              (this._x = (r + l) / e),
              (this._y = (o + c) / e),
              (this._z = 0.25 * e);
          }
          return this._onChangeCallback(), this;
        }
        setFromUnitVectors(e, t) {
          let n = e.dot(t) + 1;
          return (
            n < Number.EPSILON
              ? ((n = 0),
                Math.abs(e.x) > Math.abs(e.z)
                  ? ((this._x = -e.y),
                    (this._y = e.x),
                    (this._z = 0),
                    (this._w = n))
                  : ((this._x = 0),
                    (this._y = -e.z),
                    (this._z = e.y),
                    (this._w = n)))
              : ((this._x = e.y * t.z - e.z * t.y),
                (this._y = e.z * t.x - e.x * t.z),
                (this._z = e.x * t.y - e.y * t.x),
                (this._w = n)),
            this.normalize()
          );
        }
        angleTo(e) {
          return 2 * Math.acos(Math.abs(H(this.dot(e), -1, 1)));
        }
        rotateTowards(e, t) {
          const n = this.angleTo(e);
          if (0 === n) return this;
          const i = Math.min(1, t / n);
          return this.slerp(e, i), this;
        }
        identity() {
          return this.set(0, 0, 0, 1);
        }
        invert() {
          return this.conjugate();
        }
        conjugate() {
          return (
            (this._x *= -1),
            (this._y *= -1),
            (this._z *= -1),
            this._onChangeCallback(),
            this
          );
        }
        dot(e) {
          return (
            this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
          );
        }
        lengthSq() {
          return (
            this._x * this._x +
            this._y * this._y +
            this._z * this._z +
            this._w * this._w
          );
        }
        length() {
          return Math.sqrt(
            this._x * this._x +
              this._y * this._y +
              this._z * this._z +
              this._w * this._w
          );
        }
        normalize() {
          let e = this.length();
          return (
            0 === e
              ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
              : ((e = 1 / e),
                (this._x = this._x * e),
                (this._y = this._y * e),
                (this._z = this._z * e),
                (this._w = this._w * e)),
            this._onChangeCallback(),
            this
          );
        }
        multiply(e, t) {
          return void 0 !== t
            ? (console.warn(
                "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
              ),
              this.multiplyQuaternions(e, t))
            : this.multiplyQuaternions(this, e);
        }
        premultiply(e) {
          return this.multiplyQuaternions(e, this);
        }
        multiplyQuaternions(e, t) {
          const n = e._x,
            i = e._y,
            r = e._z,
            s = e._w,
            a = t._x,
            o = t._y,
            l = t._z,
            c = t._w;
          return (
            (this._x = n * c + s * a + i * l - r * o),
            (this._y = i * c + s * o + r * a - n * l),
            (this._z = r * c + s * l + n * o - i * a),
            (this._w = s * c - n * a - i * o - r * l),
            this._onChangeCallback(),
            this
          );
        }
        slerp(e, t) {
          if (0 === t) return this;
          if (1 === t) return this.copy(e);
          const n = this._x,
            i = this._y,
            r = this._z,
            s = this._w;
          let a = s * e._w + n * e._x + i * e._y + r * e._z;
          if (
            (a < 0
              ? ((this._w = -e._w),
                (this._x = -e._x),
                (this._y = -e._y),
                (this._z = -e._z),
                (a = -a))
              : this.copy(e),
            a >= 1)
          )
            return (
              (this._w = s), (this._x = n), (this._y = i), (this._z = r), this
            );
          const o = 1 - a * a;
          if (o <= Number.EPSILON) {
            const e = 1 - t;
            return (
              (this._w = e * s + t * this._w),
              (this._x = e * n + t * this._x),
              (this._y = e * i + t * this._y),
              (this._z = e * r + t * this._z),
              this.normalize(),
              this._onChangeCallback(),
              this
            );
          }
          const l = Math.sqrt(o),
            c = Math.atan2(l, a),
            u = Math.sin((1 - t) * c) / l,
            h = Math.sin(t * c) / l;
          return (
            (this._w = s * u + this._w * h),
            (this._x = n * u + this._x * h),
            (this._y = i * u + this._y * h),
            (this._z = r * u + this._z * h),
            this._onChangeCallback(),
            this
          );
        }
        slerpQuaternions(e, t, n) {
          return this.copy(e).slerp(t, n);
        }
        random() {
          const e = Math.random(),
            t = Math.sqrt(1 - e),
            n = Math.sqrt(e),
            i = 2 * Math.PI * Math.random(),
            r = 2 * Math.PI * Math.random();
          return this.set(
            t * Math.cos(i),
            n * Math.sin(r),
            n * Math.cos(r),
            t * Math.sin(i)
          );
        }
        equals(e) {
          return (
            e._x === this._x &&
            e._y === this._y &&
            e._z === this._z &&
            e._w === this._w
          );
        }
        fromArray(e, t = 0) {
          return (
            (this._x = e[t]),
            (this._y = e[t + 1]),
            (this._z = e[t + 2]),
            (this._w = e[t + 3]),
            this._onChangeCallback(),
            this
          );
        }
        toArray(e = [], t = 0) {
          return (
            (e[t] = this._x),
            (e[t + 1] = this._y),
            (e[t + 2] = this._z),
            (e[t + 3] = this._w),
            e
          );
        }
        fromBufferAttribute(e, t) {
          return (
            (this._x = e.getX(t)),
            (this._y = e.getY(t)),
            (this._z = e.getZ(t)),
            (this._w = e.getW(t)),
            this
          );
        }
        _onChange(e) {
          return (this._onChangeCallback = e), this;
        }
        _onChangeCallback() {}
        *[Symbol.iterator]() {
          yield this._x, yield this._y, yield this._z, yield this._w;
        }
      }
      class xe {
        constructor(e = 0, t = 0, n = 0) {
          (xe.prototype.isVector3 = !0),
            (this.x = e),
            (this.y = t),
            (this.z = n);
        }
        set(e, t, n) {
          return (
            void 0 === n && (n = this.z),
            (this.x = e),
            (this.y = t),
            (this.z = n),
            this
          );
        }
        setScalar(e) {
          return (this.x = e), (this.y = e), (this.z = e), this;
        }
        setX(e) {
          return (this.x = e), this;
        }
        setY(e) {
          return (this.y = e), this;
        }
        setZ(e) {
          return (this.z = e), this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            case 2:
              this.z = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z);
        }
        copy(e) {
          return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
        }
        add(e, t) {
          return void 0 !== t
            ? (console.warn(
                "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(e, t))
            : ((this.x += e.x), (this.y += e.y), (this.z += e.z), this);
        }
        addScalar(e) {
          return (this.x += e), (this.y += e), (this.z += e), this;
        }
        addVectors(e, t) {
          return (
            (this.x = e.x + t.x),
            (this.y = e.y + t.y),
            (this.z = e.z + t.z),
            this
          );
        }
        addScaledVector(e, t) {
          return (
            (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this
          );
        }
        sub(e, t) {
          return void 0 !== t
            ? (console.warn(
                "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(e, t))
            : ((this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this);
        }
        subScalar(e) {
          return (this.x -= e), (this.y -= e), (this.z -= e), this;
        }
        subVectors(e, t) {
          return (
            (this.x = e.x - t.x),
            (this.y = e.y - t.y),
            (this.z = e.z - t.z),
            this
          );
        }
        multiply(e, t) {
          return void 0 !== t
            ? (console.warn(
                "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
              ),
              this.multiplyVectors(e, t))
            : ((this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this);
        }
        multiplyScalar(e) {
          return (this.x *= e), (this.y *= e), (this.z *= e), this;
        }
        multiplyVectors(e, t) {
          return (
            (this.x = e.x * t.x),
            (this.y = e.y * t.y),
            (this.z = e.z * t.z),
            this
          );
        }
        applyEuler(e) {
          return (
            (e && e.isEuler) ||
              console.error(
                "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
              ),
            this.applyQuaternion(be.setFromEuler(e))
          );
        }
        applyAxisAngle(e, t) {
          return this.applyQuaternion(be.setFromAxisAngle(e, t));
        }
        applyMatrix3(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = e.elements;
          return (
            (this.x = r[0] * t + r[3] * n + r[6] * i),
            (this.y = r[1] * t + r[4] * n + r[7] * i),
            (this.z = r[2] * t + r[5] * n + r[8] * i),
            this
          );
        }
        applyNormalMatrix(e) {
          return this.applyMatrix3(e).normalize();
        }
        applyMatrix4(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = e.elements,
            s = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
          return (
            (this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * s),
            (this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * s),
            (this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * s),
            this
          );
        }
        applyQuaternion(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = e.x,
            s = e.y,
            a = e.z,
            o = e.w,
            l = o * t + s * i - a * n,
            c = o * n + a * t - r * i,
            u = o * i + r * n - s * t,
            h = -r * t - s * n - a * i;
          return (
            (this.x = l * o + h * -r + c * -a - u * -s),
            (this.y = c * o + h * -s + u * -r - l * -a),
            (this.z = u * o + h * -a + l * -s - c * -r),
            this
          );
        }
        project(e) {
          return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
            e.projectionMatrix
          );
        }
        unproject(e) {
          return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
            e.matrixWorld
          );
        }
        transformDirection(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = e.elements;
          return (
            (this.x = r[0] * t + r[4] * n + r[8] * i),
            (this.y = r[1] * t + r[5] * n + r[9] * i),
            (this.z = r[2] * t + r[6] * n + r[10] * i),
            this.normalize()
          );
        }
        divide(e) {
          return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        min(e) {
          return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            (this.z = Math.min(this.z, e.z)),
            this
          );
        }
        max(e) {
          return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            (this.z = Math.max(this.z, e.z)),
            this
          );
        }
        clamp(e, t) {
          return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            (this.z = Math.max(e.z, Math.min(t.z, this.z))),
            this
          );
        }
        clampScalar(e, t) {
          return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            (this.z = Math.max(e, Math.min(t, this.z))),
            this
          );
        }
        clampLength(e, t) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(e, Math.min(t, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            this
          );
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
            this
          );
        }
        negate() {
          return (
            (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
          );
        }
        dot(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return (
            (this.x += (e.x - this.x) * t),
            (this.y += (e.y - this.y) * t),
            (this.z += (e.z - this.z) * t),
            this
          );
        }
        lerpVectors(e, t, n) {
          return (
            (this.x = e.x + (t.x - e.x) * n),
            (this.y = e.y + (t.y - e.y) * n),
            (this.z = e.z + (t.z - e.z) * n),
            this
          );
        }
        cross(e, t) {
          return void 0 !== t
            ? (console.warn(
                "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
              ),
              this.crossVectors(e, t))
            : this.crossVectors(this, e);
        }
        crossVectors(e, t) {
          const n = e.x,
            i = e.y,
            r = e.z,
            s = t.x,
            a = t.y,
            o = t.z;
          return (
            (this.x = i * o - r * a),
            (this.y = r * s - n * o),
            (this.z = n * a - i * s),
            this
          );
        }
        projectOnVector(e) {
          const t = e.lengthSq();
          if (0 === t) return this.set(0, 0, 0);
          const n = e.dot(this) / t;
          return this.copy(e).multiplyScalar(n);
        }
        projectOnPlane(e) {
          return ye.copy(this).projectOnVector(e), this.sub(ye);
        }
        reflect(e) {
          return this.sub(ye.copy(e).multiplyScalar(2 * this.dot(e)));
        }
        angleTo(e) {
          const t = Math.sqrt(this.lengthSq() * e.lengthSq());
          if (0 === t) return Math.PI / 2;
          const n = this.dot(e) / t;
          return Math.acos(H(n, -1, 1));
        }
        distanceTo(e) {
          return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
          const t = this.x - e.x,
            n = this.y - e.y,
            i = this.z - e.z;
          return t * t + n * n + i * i;
        }
        manhattanDistanceTo(e) {
          return (
            Math.abs(this.x - e.x) +
            Math.abs(this.y - e.y) +
            Math.abs(this.z - e.z)
          );
        }
        setFromSpherical(e) {
          return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
        }
        setFromSphericalCoords(e, t, n) {
          const i = Math.sin(t) * e;
          return (
            (this.x = i * Math.sin(n)),
            (this.y = Math.cos(t) * e),
            (this.z = i * Math.cos(n)),
            this
          );
        }
        setFromCylindrical(e) {
          return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
        }
        setFromCylindricalCoords(e, t, n) {
          return (
            (this.x = e * Math.sin(t)),
            (this.y = n),
            (this.z = e * Math.cos(t)),
            this
          );
        }
        setFromMatrixPosition(e) {
          const t = e.elements;
          return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
        }
        setFromMatrixScale(e) {
          const t = this.setFromMatrixColumn(e, 0).length(),
            n = this.setFromMatrixColumn(e, 1).length(),
            i = this.setFromMatrixColumn(e, 2).length();
          return (this.x = t), (this.y = n), (this.z = i), this;
        }
        setFromMatrixColumn(e, t) {
          return this.fromArray(e.elements, 4 * t);
        }
        setFromMatrix3Column(e, t) {
          return this.fromArray(e.elements, 3 * t);
        }
        setFromEuler(e) {
          return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
        }
        equals(e) {
          return e.x === this.x && e.y === this.y && e.z === this.z;
        }
        fromArray(e, t = 0) {
          return (
            (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this
          );
        }
        toArray(e = [], t = 0) {
          return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
        }
        fromBufferAttribute(e, t, n) {
          return (
            void 0 !== n &&
              console.warn(
                "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = e.getX(t)),
            (this.y = e.getY(t)),
            (this.z = e.getZ(t)),
            this
          );
        }
        random() {
          return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            this
          );
        }
        randomDirection() {
          const e = 2 * (Math.random() - 0.5),
            t = Math.random() * Math.PI * 2,
            n = Math.sqrt(1 - e ** 2);
          return (
            (this.x = n * Math.cos(t)),
            (this.y = n * Math.sin(t)),
            (this.z = e),
            this
          );
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z;
        }
      }
      const ye = new xe(),
        be = new _e();
      class we {
        constructor(
          e = new xe(1 / 0, 1 / 0, 1 / 0),
          t = new xe(-1 / 0, -1 / 0, -1 / 0)
        ) {
          (this.isBox3 = !0), (this.min = e), (this.max = t);
        }
        set(e, t) {
          return this.min.copy(e), this.max.copy(t), this;
        }
        setFromArray(e) {
          let t = 1 / 0,
            n = 1 / 0,
            i = 1 / 0,
            r = -1 / 0,
            s = -1 / 0,
            a = -1 / 0;
          for (let o = 0, l = e.length; o < l; o += 3) {
            const l = e[o],
              c = e[o + 1],
              u = e[o + 2];
            l < t && (t = l),
              c < n && (n = c),
              u < i && (i = u),
              l > r && (r = l),
              c > s && (s = c),
              u > a && (a = u);
          }
          return this.min.set(t, n, i), this.max.set(r, s, a), this;
        }
        setFromBufferAttribute(e) {
          let t = 1 / 0,
            n = 1 / 0,
            i = 1 / 0,
            r = -1 / 0,
            s = -1 / 0,
            a = -1 / 0;
          for (let o = 0, l = e.count; o < l; o++) {
            const l = e.getX(o),
              c = e.getY(o),
              u = e.getZ(o);
            l < t && (t = l),
              c < n && (n = c),
              u < i && (i = u),
              l > r && (r = l),
              c > s && (s = c),
              u > a && (a = u);
          }
          return this.min.set(t, n, i), this.max.set(r, s, a), this;
        }
        setFromPoints(e) {
          this.makeEmpty();
          for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
          return this;
        }
        setFromCenterAndSize(e, t) {
          const n = Me.copy(t).multiplyScalar(0.5);
          return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
        }
        setFromObject(e, t = !1) {
          return this.makeEmpty(), this.expandByObject(e, t);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.min.copy(e.min), this.max.copy(e.max), this;
        }
        makeEmpty() {
          return (
            (this.min.x = this.min.y = this.min.z = 1 / 0),
            (this.max.x = this.max.y = this.max.z = -1 / 0),
            this
          );
        }
        isEmpty() {
          return (
            this.max.x < this.min.x ||
            this.max.y < this.min.y ||
            this.max.z < this.min.z
          );
        }
        getCenter(e) {
          return this.isEmpty()
            ? e.set(0, 0, 0)
            : e.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(e) {
          return this.isEmpty()
            ? e.set(0, 0, 0)
            : e.subVectors(this.max, this.min);
        }
        expandByPoint(e) {
          return this.min.min(e), this.max.max(e), this;
        }
        expandByVector(e) {
          return this.min.sub(e), this.max.add(e), this;
        }
        expandByScalar(e) {
          return this.min.addScalar(-e), this.max.addScalar(e), this;
        }
        expandByObject(e, t = !1) {
          e.updateWorldMatrix(!1, !1);
          const n = e.geometry;
          if (void 0 !== n)
            if (t && null != n.attributes && void 0 !== n.attributes.position) {
              const t = n.attributes.position;
              for (let n = 0, i = t.count; n < i; n++)
                Me.fromBufferAttribute(t, n).applyMatrix4(e.matrixWorld),
                  this.expandByPoint(Me);
            } else
              null === n.boundingBox && n.computeBoundingBox(),
                Ee.copy(n.boundingBox),
                Ee.applyMatrix4(e.matrixWorld),
                this.union(Ee);
          const i = e.children;
          for (let e = 0, n = i.length; e < n; e++)
            this.expandByObject(i[e], t);
          return this;
        }
        containsPoint(e) {
          return !(
            e.x < this.min.x ||
            e.x > this.max.x ||
            e.y < this.min.y ||
            e.y > this.max.y ||
            e.z < this.min.z ||
            e.z > this.max.z
          );
        }
        containsBox(e) {
          return (
            this.min.x <= e.min.x &&
            e.max.x <= this.max.x &&
            this.min.y <= e.min.y &&
            e.max.y <= this.max.y &&
            this.min.z <= e.min.z &&
            e.max.z <= this.max.z
          );
        }
        getParameter(e, t) {
          return t.set(
            (e.x - this.min.x) / (this.max.x - this.min.x),
            (e.y - this.min.y) / (this.max.y - this.min.y),
            (e.z - this.min.z) / (this.max.z - this.min.z)
          );
        }
        intersectsBox(e) {
          return !(
            e.max.x < this.min.x ||
            e.min.x > this.max.x ||
            e.max.y < this.min.y ||
            e.min.y > this.max.y ||
            e.max.z < this.min.z ||
            e.min.z > this.max.z
          );
        }
        intersectsSphere(e) {
          return (
            this.clampPoint(e.center, Me),
            Me.distanceToSquared(e.center) <= e.radius * e.radius
          );
        }
        intersectsPlane(e) {
          let t, n;
          return (
            e.normal.x > 0
              ? ((t = e.normal.x * this.min.x), (n = e.normal.x * this.max.x))
              : ((t = e.normal.x * this.max.x), (n = e.normal.x * this.min.x)),
            e.normal.y > 0
              ? ((t += e.normal.y * this.min.y), (n += e.normal.y * this.max.y))
              : ((t += e.normal.y * this.max.y),
                (n += e.normal.y * this.min.y)),
            e.normal.z > 0
              ? ((t += e.normal.z * this.min.z), (n += e.normal.z * this.max.z))
              : ((t += e.normal.z * this.max.z),
                (n += e.normal.z * this.min.z)),
            t <= -e.constant && n >= -e.constant
          );
        }
        intersectsTriangle(e) {
          if (this.isEmpty()) return !1;
          this.getCenter(ke),
            Re.subVectors(this.max, ke),
            Te.subVectors(e.a, ke),
            Ae.subVectors(e.b, ke),
            Ce.subVectors(e.c, ke),
            Le.subVectors(Ae, Te),
            Pe.subVectors(Ce, Ae),
            De.subVectors(Te, Ce);
          let t = [
            0,
            -Le.z,
            Le.y,
            0,
            -Pe.z,
            Pe.y,
            0,
            -De.z,
            De.y,
            Le.z,
            0,
            -Le.x,
            Pe.z,
            0,
            -Pe.x,
            De.z,
            0,
            -De.x,
            -Le.y,
            Le.x,
            0,
            -Pe.y,
            Pe.x,
            0,
            -De.y,
            De.x,
            0,
          ];
          return (
            !!Oe(t, Te, Ae, Ce, Re) &&
            ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
            !!Oe(t, Te, Ae, Ce, Re) &&
              (Ie.crossVectors(Le, Pe),
              (t = [Ie.x, Ie.y, Ie.z]),
              Oe(t, Te, Ae, Ce, Re)))
          );
        }
        clampPoint(e, t) {
          return t.copy(e).clamp(this.min, this.max);
        }
        distanceToPoint(e) {
          return Me.copy(e).clamp(this.min, this.max).sub(e).length();
        }
        getBoundingSphere(e) {
          return (
            this.getCenter(e.center),
            (e.radius = 0.5 * this.getSize(Me).length()),
            e
          );
        }
        intersect(e) {
          return (
            this.min.max(e.min),
            this.max.min(e.max),
            this.isEmpty() && this.makeEmpty(),
            this
          );
        }
        union(e) {
          return this.min.min(e.min), this.max.max(e.max), this;
        }
        applyMatrix4(e) {
          return (
            this.isEmpty() ||
              (Se[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
              Se[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
              Se[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
              Se[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
              Se[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
              Se[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
              Se[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
              Se[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
              this.setFromPoints(Se)),
            this
          );
        }
        translate(e) {
          return this.min.add(e), this.max.add(e), this;
        }
        equals(e) {
          return e.min.equals(this.min) && e.max.equals(this.max);
        }
      }
      const Se = [
          new xe(),
          new xe(),
          new xe(),
          new xe(),
          new xe(),
          new xe(),
          new xe(),
          new xe(),
        ],
        Me = new xe(),
        Ee = new we(),
        Te = new xe(),
        Ae = new xe(),
        Ce = new xe(),
        Le = new xe(),
        Pe = new xe(),
        De = new xe(),
        ke = new xe(),
        Re = new xe(),
        Ie = new xe(),
        Fe = new xe();
      function Oe(e, t, n, i, r) {
        for (let s = 0, a = e.length - 3; s <= a; s += 3) {
          Fe.fromArray(e, s);
          const a =
              r.x * Math.abs(Fe.x) +
              r.y * Math.abs(Fe.y) +
              r.z * Math.abs(Fe.z),
            o = t.dot(Fe),
            l = n.dot(Fe),
            c = i.dot(Fe);
          if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > a) return !1;
        }
        return !0;
      }
      const Ne = new we(),
        ze = new xe(),
        Be = new xe(),
        Ue = new xe();
      class Ve {
        constructor(e = new xe(), t = -1) {
          (this.center = e), (this.radius = t);
        }
        set(e, t) {
          return this.center.copy(e), (this.radius = t), this;
        }
        setFromPoints(e, t) {
          const n = this.center;
          void 0 !== t ? n.copy(t) : Ne.setFromPoints(e).getCenter(n);
          let i = 0;
          for (let t = 0, r = e.length; t < r; t++)
            i = Math.max(i, n.distanceToSquared(e[t]));
          return (this.radius = Math.sqrt(i)), this;
        }
        copy(e) {
          return this.center.copy(e.center), (this.radius = e.radius), this;
        }
        isEmpty() {
          return this.radius < 0;
        }
        makeEmpty() {
          return this.center.set(0, 0, 0), (this.radius = -1), this;
        }
        containsPoint(e) {
          return e.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(e) {
          return e.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(e) {
          const t = this.radius + e.radius;
          return e.center.distanceToSquared(this.center) <= t * t;
        }
        intersectsBox(e) {
          return e.intersectsSphere(this);
        }
        intersectsPlane(e) {
          return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(e, t) {
          const n = this.center.distanceToSquared(e);
          return (
            t.copy(e),
            n > this.radius * this.radius &&
              (t.sub(this.center).normalize(),
              t.multiplyScalar(this.radius).add(this.center)),
            t
          );
        }
        getBoundingBox(e) {
          return this.isEmpty()
            ? (e.makeEmpty(), e)
            : (e.set(this.center, this.center),
              e.expandByScalar(this.radius),
              e);
        }
        applyMatrix4(e) {
          return (
            this.center.applyMatrix4(e),
            (this.radius = this.radius * e.getMaxScaleOnAxis()),
            this
          );
        }
        translate(e) {
          return this.center.add(e), this;
        }
        expandByPoint(e) {
          Ue.subVectors(e, this.center);
          const t = Ue.lengthSq();
          if (t > this.radius * this.radius) {
            const e = Math.sqrt(t),
              n = 0.5 * (e - this.radius);
            this.center.add(Ue.multiplyScalar(n / e)), (this.radius += n);
          }
          return this;
        }
        union(e) {
          return (
            !0 === this.center.equals(e.center)
              ? Be.set(0, 0, 1).multiplyScalar(e.radius)
              : Be.subVectors(e.center, this.center)
                  .normalize()
                  .multiplyScalar(e.radius),
            this.expandByPoint(ze.copy(e.center).add(Be)),
            this.expandByPoint(ze.copy(e.center).sub(Be)),
            this
          );
        }
        equals(e) {
          return e.center.equals(this.center) && e.radius === this.radius;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const Ge = new xe(),
        He = new xe(),
        We = new xe(),
        je = new xe(),
        qe = new xe(),
        Xe = new xe(),
        Ye = new xe();
      class Ze {
        constructor(e = new xe(), t = new xe(0, 0, -1)) {
          (this.origin = e), (this.direction = t);
        }
        set(e, t) {
          return this.origin.copy(e), this.direction.copy(t), this;
        }
        copy(e) {
          return (
            this.origin.copy(e.origin), this.direction.copy(e.direction), this
          );
        }
        at(e, t) {
          return t.copy(this.direction).multiplyScalar(e).add(this.origin);
        }
        lookAt(e) {
          return this.direction.copy(e).sub(this.origin).normalize(), this;
        }
        recast(e) {
          return this.origin.copy(this.at(e, Ge)), this;
        }
        closestPointToPoint(e, t) {
          t.subVectors(e, this.origin);
          const n = t.dot(this.direction);
          return n < 0
            ? t.copy(this.origin)
            : t.copy(this.direction).multiplyScalar(n).add(this.origin);
        }
        distanceToPoint(e) {
          return Math.sqrt(this.distanceSqToPoint(e));
        }
        distanceSqToPoint(e) {
          const t = Ge.subVectors(e, this.origin).dot(this.direction);
          return t < 0
            ? this.origin.distanceToSquared(e)
            : (Ge.copy(this.direction).multiplyScalar(t).add(this.origin),
              Ge.distanceToSquared(e));
        }
        distanceSqToSegment(e, t, n, i) {
          He.copy(e).add(t).multiplyScalar(0.5),
            We.copy(t).sub(e).normalize(),
            je.copy(this.origin).sub(He);
          const r = 0.5 * e.distanceTo(t),
            s = -this.direction.dot(We),
            a = je.dot(this.direction),
            o = -je.dot(We),
            l = je.lengthSq(),
            c = Math.abs(1 - s * s);
          let u, h, d, p;
          if (c > 0)
            if (((u = s * o - a), (h = s * a - o), (p = r * c), u >= 0))
              if (h >= -p)
                if (h <= p) {
                  const e = 1 / c;
                  (u *= e),
                    (h *= e),
                    (d = u * (u + s * h + 2 * a) + h * (s * u + h + 2 * o) + l);
                } else
                  (h = r),
                    (u = Math.max(0, -(s * h + a))),
                    (d = -u * u + h * (h + 2 * o) + l);
              else
                (h = -r),
                  (u = Math.max(0, -(s * h + a))),
                  (d = -u * u + h * (h + 2 * o) + l);
            else
              h <= -p
                ? ((u = Math.max(0, -(-s * r + a))),
                  (h = u > 0 ? -r : Math.min(Math.max(-r, -o), r)),
                  (d = -u * u + h * (h + 2 * o) + l))
                : h <= p
                ? ((u = 0),
                  (h = Math.min(Math.max(-r, -o), r)),
                  (d = h * (h + 2 * o) + l))
                : ((u = Math.max(0, -(s * r + a))),
                  (h = u > 0 ? r : Math.min(Math.max(-r, -o), r)),
                  (d = -u * u + h * (h + 2 * o) + l));
          else
            (h = s > 0 ? -r : r),
              (u = Math.max(0, -(s * h + a))),
              (d = -u * u + h * (h + 2 * o) + l);
          return (
            n && n.copy(this.direction).multiplyScalar(u).add(this.origin),
            i && i.copy(We).multiplyScalar(h).add(He),
            d
          );
        }
        intersectSphere(e, t) {
          Ge.subVectors(e.center, this.origin);
          const n = Ge.dot(this.direction),
            i = Ge.dot(Ge) - n * n,
            r = e.radius * e.radius;
          if (i > r) return null;
          const s = Math.sqrt(r - i),
            a = n - s,
            o = n + s;
          return a < 0 && o < 0 ? null : a < 0 ? this.at(o, t) : this.at(a, t);
        }
        intersectsSphere(e) {
          return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
        }
        distanceToPlane(e) {
          const t = e.normal.dot(this.direction);
          if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
          const n = -(this.origin.dot(e.normal) + e.constant) / t;
          return n >= 0 ? n : null;
        }
        intersectPlane(e, t) {
          const n = this.distanceToPlane(e);
          return null === n ? null : this.at(n, t);
        }
        intersectsPlane(e) {
          const t = e.distanceToPoint(this.origin);
          return 0 === t || e.normal.dot(this.direction) * t < 0;
        }
        intersectBox(e, t) {
          let n, i, r, s, a, o;
          const l = 1 / this.direction.x,
            c = 1 / this.direction.y,
            u = 1 / this.direction.z,
            h = this.origin;
          return (
            l >= 0
              ? ((n = (e.min.x - h.x) * l), (i = (e.max.x - h.x) * l))
              : ((n = (e.max.x - h.x) * l), (i = (e.min.x - h.x) * l)),
            c >= 0
              ? ((r = (e.min.y - h.y) * c), (s = (e.max.y - h.y) * c))
              : ((r = (e.max.y - h.y) * c), (s = (e.min.y - h.y) * c)),
            n > s || r > i
              ? null
              : ((r > n || n != n) && (n = r),
                (s < i || i != i) && (i = s),
                u >= 0
                  ? ((a = (e.min.z - h.z) * u), (o = (e.max.z - h.z) * u))
                  : ((a = (e.max.z - h.z) * u), (o = (e.min.z - h.z) * u)),
                n > o || a > i
                  ? null
                  : ((a > n || n != n) && (n = a),
                    (o < i || i != i) && (i = o),
                    i < 0 ? null : this.at(n >= 0 ? n : i, t)))
          );
        }
        intersectsBox(e) {
          return null !== this.intersectBox(e, Ge);
        }
        intersectTriangle(e, t, n, i, r) {
          qe.subVectors(t, e), Xe.subVectors(n, e), Ye.crossVectors(qe, Xe);
          let s,
            a = this.direction.dot(Ye);
          if (a > 0) {
            if (i) return null;
            s = 1;
          } else {
            if (!(a < 0)) return null;
            (s = -1), (a = -a);
          }
          je.subVectors(this.origin, e);
          const o = s * this.direction.dot(Xe.crossVectors(je, Xe));
          if (o < 0) return null;
          const l = s * this.direction.dot(qe.cross(je));
          if (l < 0) return null;
          if (o + l > a) return null;
          const c = -s * je.dot(Ye);
          return c < 0 ? null : this.at(c / a, r);
        }
        applyMatrix4(e) {
          return (
            this.origin.applyMatrix4(e),
            this.direction.transformDirection(e),
            this
          );
        }
        equals(e) {
          return (
            e.origin.equals(this.origin) && e.direction.equals(this.direction)
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class $e {
        constructor() {
          ($e.prototype.isMatrix4 = !0),
            (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
            arguments.length > 0 &&
              console.error(
                "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
              );
        }
        set(e, t, n, i, r, s, a, o, l, c, u, h, d, p, f, m) {
          const g = this.elements;
          return (
            (g[0] = e),
            (g[4] = t),
            (g[8] = n),
            (g[12] = i),
            (g[1] = r),
            (g[5] = s),
            (g[9] = a),
            (g[13] = o),
            (g[2] = l),
            (g[6] = c),
            (g[10] = u),
            (g[14] = h),
            (g[3] = d),
            (g[7] = p),
            (g[11] = f),
            (g[15] = m),
            this
          );
        }
        identity() {
          return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        clone() {
          return new $e().fromArray(this.elements);
        }
        copy(e) {
          const t = this.elements,
            n = e.elements;
          return (
            (t[0] = n[0]),
            (t[1] = n[1]),
            (t[2] = n[2]),
            (t[3] = n[3]),
            (t[4] = n[4]),
            (t[5] = n[5]),
            (t[6] = n[6]),
            (t[7] = n[7]),
            (t[8] = n[8]),
            (t[9] = n[9]),
            (t[10] = n[10]),
            (t[11] = n[11]),
            (t[12] = n[12]),
            (t[13] = n[13]),
            (t[14] = n[14]),
            (t[15] = n[15]),
            this
          );
        }
        copyPosition(e) {
          const t = this.elements,
            n = e.elements;
          return (t[12] = n[12]), (t[13] = n[13]), (t[14] = n[14]), this;
        }
        setFromMatrix3(e) {
          const t = e.elements;
          return (
            this.set(
              t[0],
              t[3],
              t[6],
              0,
              t[1],
              t[4],
              t[7],
              0,
              t[2],
              t[5],
              t[8],
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        extractBasis(e, t, n) {
          return (
            e.setFromMatrixColumn(this, 0),
            t.setFromMatrixColumn(this, 1),
            n.setFromMatrixColumn(this, 2),
            this
          );
        }
        makeBasis(e, t, n) {
          return (
            this.set(
              e.x,
              t.x,
              n.x,
              0,
              e.y,
              t.y,
              n.y,
              0,
              e.z,
              t.z,
              n.z,
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        extractRotation(e) {
          const t = this.elements,
            n = e.elements,
            i = 1 / Ke.setFromMatrixColumn(e, 0).length(),
            r = 1 / Ke.setFromMatrixColumn(e, 1).length(),
            s = 1 / Ke.setFromMatrixColumn(e, 2).length();
          return (
            (t[0] = n[0] * i),
            (t[1] = n[1] * i),
            (t[2] = n[2] * i),
            (t[3] = 0),
            (t[4] = n[4] * r),
            (t[5] = n[5] * r),
            (t[6] = n[6] * r),
            (t[7] = 0),
            (t[8] = n[8] * s),
            (t[9] = n[9] * s),
            (t[10] = n[10] * s),
            (t[11] = 0),
            (t[12] = 0),
            (t[13] = 0),
            (t[14] = 0),
            (t[15] = 1),
            this
          );
        }
        makeRotationFromEuler(e) {
          (e && e.isEuler) ||
            console.error(
              "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
            );
          const t = this.elements,
            n = e.x,
            i = e.y,
            r = e.z,
            s = Math.cos(n),
            a = Math.sin(n),
            o = Math.cos(i),
            l = Math.sin(i),
            c = Math.cos(r),
            u = Math.sin(r);
          if ("XYZ" === e.order) {
            const e = s * c,
              n = s * u,
              i = a * c,
              r = a * u;
            (t[0] = o * c),
              (t[4] = -o * u),
              (t[8] = l),
              (t[1] = n + i * l),
              (t[5] = e - r * l),
              (t[9] = -a * o),
              (t[2] = r - e * l),
              (t[6] = i + n * l),
              (t[10] = s * o);
          } else if ("YXZ" === e.order) {
            const e = o * c,
              n = o * u,
              i = l * c,
              r = l * u;
            (t[0] = e + r * a),
              (t[4] = i * a - n),
              (t[8] = s * l),
              (t[1] = s * u),
              (t[5] = s * c),
              (t[9] = -a),
              (t[2] = n * a - i),
              (t[6] = r + e * a),
              (t[10] = s * o);
          } else if ("ZXY" === e.order) {
            const e = o * c,
              n = o * u,
              i = l * c,
              r = l * u;
            (t[0] = e - r * a),
              (t[4] = -s * u),
              (t[8] = i + n * a),
              (t[1] = n + i * a),
              (t[5] = s * c),
              (t[9] = r - e * a),
              (t[2] = -s * l),
              (t[6] = a),
              (t[10] = s * o);
          } else if ("ZYX" === e.order) {
            const e = s * c,
              n = s * u,
              i = a * c,
              r = a * u;
            (t[0] = o * c),
              (t[4] = i * l - n),
              (t[8] = e * l + r),
              (t[1] = o * u),
              (t[5] = r * l + e),
              (t[9] = n * l - i),
              (t[2] = -l),
              (t[6] = a * o),
              (t[10] = s * o);
          } else if ("YZX" === e.order) {
            const e = s * o,
              n = s * l,
              i = a * o,
              r = a * l;
            (t[0] = o * c),
              (t[4] = r - e * u),
              (t[8] = i * u + n),
              (t[1] = u),
              (t[5] = s * c),
              (t[9] = -a * c),
              (t[2] = -l * c),
              (t[6] = n * u + i),
              (t[10] = e - r * u);
          } else if ("XZY" === e.order) {
            const e = s * o,
              n = s * l,
              i = a * o,
              r = a * l;
            (t[0] = o * c),
              (t[4] = -u),
              (t[8] = l * c),
              (t[1] = e * u + r),
              (t[5] = s * c),
              (t[9] = n * u - i),
              (t[2] = i * u - n),
              (t[6] = a * c),
              (t[10] = r * u + e);
          }
          return (
            (t[3] = 0),
            (t[7] = 0),
            (t[11] = 0),
            (t[12] = 0),
            (t[13] = 0),
            (t[14] = 0),
            (t[15] = 1),
            this
          );
        }
        makeRotationFromQuaternion(e) {
          return this.compose(Qe, e, et);
        }
        lookAt(e, t, n) {
          const i = this.elements;
          return (
            it.subVectors(e, t),
            0 === it.lengthSq() && (it.z = 1),
            it.normalize(),
            tt.crossVectors(n, it),
            0 === tt.lengthSq() &&
              (1 === Math.abs(n.z) ? (it.x += 1e-4) : (it.z += 1e-4),
              it.normalize(),
              tt.crossVectors(n, it)),
            tt.normalize(),
            nt.crossVectors(it, tt),
            (i[0] = tt.x),
            (i[4] = nt.x),
            (i[8] = it.x),
            (i[1] = tt.y),
            (i[5] = nt.y),
            (i[9] = it.y),
            (i[2] = tt.z),
            (i[6] = nt.z),
            (i[10] = it.z),
            this
          );
        }
        multiply(e, t) {
          return void 0 !== t
            ? (console.warn(
                "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
              ),
              this.multiplyMatrices(e, t))
            : this.multiplyMatrices(this, e);
        }
        premultiply(e) {
          return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
          const n = e.elements,
            i = t.elements,
            r = this.elements,
            s = n[0],
            a = n[4],
            o = n[8],
            l = n[12],
            c = n[1],
            u = n[5],
            h = n[9],
            d = n[13],
            p = n[2],
            f = n[6],
            m = n[10],
            g = n[14],
            v = n[3],
            _ = n[7],
            x = n[11],
            y = n[15],
            b = i[0],
            w = i[4],
            S = i[8],
            M = i[12],
            E = i[1],
            T = i[5],
            A = i[9],
            C = i[13],
            L = i[2],
            P = i[6],
            D = i[10],
            k = i[14],
            R = i[3],
            I = i[7],
            F = i[11],
            O = i[15];
          return (
            (r[0] = s * b + a * E + o * L + l * R),
            (r[4] = s * w + a * T + o * P + l * I),
            (r[8] = s * S + a * A + o * D + l * F),
            (r[12] = s * M + a * C + o * k + l * O),
            (r[1] = c * b + u * E + h * L + d * R),
            (r[5] = c * w + u * T + h * P + d * I),
            (r[9] = c * S + u * A + h * D + d * F),
            (r[13] = c * M + u * C + h * k + d * O),
            (r[2] = p * b + f * E + m * L + g * R),
            (r[6] = p * w + f * T + m * P + g * I),
            (r[10] = p * S + f * A + m * D + g * F),
            (r[14] = p * M + f * C + m * k + g * O),
            (r[3] = v * b + _ * E + x * L + y * R),
            (r[7] = v * w + _ * T + x * P + y * I),
            (r[11] = v * S + _ * A + x * D + y * F),
            (r[15] = v * M + _ * C + x * k + y * O),
            this
          );
        }
        multiplyScalar(e) {
          const t = this.elements;
          return (
            (t[0] *= e),
            (t[4] *= e),
            (t[8] *= e),
            (t[12] *= e),
            (t[1] *= e),
            (t[5] *= e),
            (t[9] *= e),
            (t[13] *= e),
            (t[2] *= e),
            (t[6] *= e),
            (t[10] *= e),
            (t[14] *= e),
            (t[3] *= e),
            (t[7] *= e),
            (t[11] *= e),
            (t[15] *= e),
            this
          );
        }
        determinant() {
          const e = this.elements,
            t = e[0],
            n = e[4],
            i = e[8],
            r = e[12],
            s = e[1],
            a = e[5],
            o = e[9],
            l = e[13],
            c = e[2],
            u = e[6],
            h = e[10],
            d = e[14];
          return (
            e[3] *
              (+r * o * u -
                i * l * u -
                r * a * h +
                n * l * h +
                i * a * d -
                n * o * d) +
            e[7] *
              (+t * o * d -
                t * l * h +
                r * s * h -
                i * s * d +
                i * l * c -
                r * o * c) +
            e[11] *
              (+t * l * u -
                t * a * d -
                r * s * u +
                n * s * d +
                r * a * c -
                n * l * c) +
            e[15] *
              (-i * a * c -
                t * o * u +
                t * a * h +
                i * s * u -
                n * s * h +
                n * o * c)
          );
        }
        transpose() {
          const e = this.elements;
          let t;
          return (
            (t = e[1]),
            (e[1] = e[4]),
            (e[4] = t),
            (t = e[2]),
            (e[2] = e[8]),
            (e[8] = t),
            (t = e[6]),
            (e[6] = e[9]),
            (e[9] = t),
            (t = e[3]),
            (e[3] = e[12]),
            (e[12] = t),
            (t = e[7]),
            (e[7] = e[13]),
            (e[13] = t),
            (t = e[11]),
            (e[11] = e[14]),
            (e[14] = t),
            this
          );
        }
        setPosition(e, t, n) {
          const i = this.elements;
          return (
            e.isVector3
              ? ((i[12] = e.x), (i[13] = e.y), (i[14] = e.z))
              : ((i[12] = e), (i[13] = t), (i[14] = n)),
            this
          );
        }
        invert() {
          const e = this.elements,
            t = e[0],
            n = e[1],
            i = e[2],
            r = e[3],
            s = e[4],
            a = e[5],
            o = e[6],
            l = e[7],
            c = e[8],
            u = e[9],
            h = e[10],
            d = e[11],
            p = e[12],
            f = e[13],
            m = e[14],
            g = e[15],
            v =
              u * m * l -
              f * h * l +
              f * o * d -
              a * m * d -
              u * o * g +
              a * h * g,
            _ =
              p * h * l -
              c * m * l -
              p * o * d +
              s * m * d +
              c * o * g -
              s * h * g,
            x =
              c * f * l -
              p * u * l +
              p * a * d -
              s * f * d -
              c * a * g +
              s * u * g,
            y =
              p * u * o -
              c * f * o -
              p * a * h +
              s * f * h +
              c * a * m -
              s * u * m,
            b = t * v + n * _ + i * x + r * y;
          if (0 === b)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          const w = 1 / b;
          return (
            (e[0] = v * w),
            (e[1] =
              (f * h * r -
                u * m * r -
                f * i * d +
                n * m * d +
                u * i * g -
                n * h * g) *
              w),
            (e[2] =
              (a * m * r -
                f * o * r +
                f * i * l -
                n * m * l -
                a * i * g +
                n * o * g) *
              w),
            (e[3] =
              (u * o * r -
                a * h * r -
                u * i * l +
                n * h * l +
                a * i * d -
                n * o * d) *
              w),
            (e[4] = _ * w),
            (e[5] =
              (c * m * r -
                p * h * r +
                p * i * d -
                t * m * d -
                c * i * g +
                t * h * g) *
              w),
            (e[6] =
              (p * o * r -
                s * m * r -
                p * i * l +
                t * m * l +
                s * i * g -
                t * o * g) *
              w),
            (e[7] =
              (s * h * r -
                c * o * r +
                c * i * l -
                t * h * l -
                s * i * d +
                t * o * d) *
              w),
            (e[8] = x * w),
            (e[9] =
              (p * u * r -
                c * f * r -
                p * n * d +
                t * f * d +
                c * n * g -
                t * u * g) *
              w),
            (e[10] =
              (s * f * r -
                p * a * r +
                p * n * l -
                t * f * l -
                s * n * g +
                t * a * g) *
              w),
            (e[11] =
              (c * a * r -
                s * u * r -
                c * n * l +
                t * u * l +
                s * n * d -
                t * a * d) *
              w),
            (e[12] = y * w),
            (e[13] =
              (c * f * i -
                p * u * i +
                p * n * h -
                t * f * h -
                c * n * m +
                t * u * m) *
              w),
            (e[14] =
              (p * a * i -
                s * f * i -
                p * n * o +
                t * f * o +
                s * n * m -
                t * a * m) *
              w),
            (e[15] =
              (s * u * i -
                c * a * i +
                c * n * o -
                t * u * o -
                s * n * h +
                t * a * h) *
              w),
            this
          );
        }
        scale(e) {
          const t = this.elements,
            n = e.x,
            i = e.y,
            r = e.z;
          return (
            (t[0] *= n),
            (t[4] *= i),
            (t[8] *= r),
            (t[1] *= n),
            (t[5] *= i),
            (t[9] *= r),
            (t[2] *= n),
            (t[6] *= i),
            (t[10] *= r),
            (t[3] *= n),
            (t[7] *= i),
            (t[11] *= r),
            this
          );
        }
        getMaxScaleOnAxis() {
          const e = this.elements,
            t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
            n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
            i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
          return Math.sqrt(Math.max(t, n, i));
        }
        makeTranslation(e, t, n) {
          return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this;
        }
        makeRotationX(e) {
          const t = Math.cos(e),
            n = Math.sin(e);
          return (
            this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationY(e) {
          const t = Math.cos(e),
            n = Math.sin(e);
          return (
            this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationZ(e) {
          const t = Math.cos(e),
            n = Math.sin(e);
          return (
            this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationAxis(e, t) {
          const n = Math.cos(t),
            i = Math.sin(t),
            r = 1 - n,
            s = e.x,
            a = e.y,
            o = e.z,
            l = r * s,
            c = r * a;
          return (
            this.set(
              l * s + n,
              l * a - i * o,
              l * o + i * a,
              0,
              l * a + i * o,
              c * a + n,
              c * o - i * s,
              0,
              l * o - i * a,
              c * o + i * s,
              r * o * o + n,
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        makeScale(e, t, n) {
          return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
        }
        makeShear(e, t, n, i, r, s) {
          return this.set(1, n, r, 0, e, 1, s, 0, t, i, 1, 0, 0, 0, 0, 1), this;
        }
        compose(e, t, n) {
          const i = this.elements,
            r = t._x,
            s = t._y,
            a = t._z,
            o = t._w,
            l = r + r,
            c = s + s,
            u = a + a,
            h = r * l,
            d = r * c,
            p = r * u,
            f = s * c,
            m = s * u,
            g = a * u,
            v = o * l,
            _ = o * c,
            x = o * u,
            y = n.x,
            b = n.y,
            w = n.z;
          return (
            (i[0] = (1 - (f + g)) * y),
            (i[1] = (d + x) * y),
            (i[2] = (p - _) * y),
            (i[3] = 0),
            (i[4] = (d - x) * b),
            (i[5] = (1 - (h + g)) * b),
            (i[6] = (m + v) * b),
            (i[7] = 0),
            (i[8] = (p + _) * w),
            (i[9] = (m - v) * w),
            (i[10] = (1 - (h + f)) * w),
            (i[11] = 0),
            (i[12] = e.x),
            (i[13] = e.y),
            (i[14] = e.z),
            (i[15] = 1),
            this
          );
        }
        decompose(e, t, n) {
          const i = this.elements;
          let r = Ke.set(i[0], i[1], i[2]).length();
          const s = Ke.set(i[4], i[5], i[6]).length(),
            a = Ke.set(i[8], i[9], i[10]).length();
          this.determinant() < 0 && (r = -r),
            (e.x = i[12]),
            (e.y = i[13]),
            (e.z = i[14]),
            Je.copy(this);
          const o = 1 / r,
            l = 1 / s,
            c = 1 / a;
          return (
            (Je.elements[0] *= o),
            (Je.elements[1] *= o),
            (Je.elements[2] *= o),
            (Je.elements[4] *= l),
            (Je.elements[5] *= l),
            (Je.elements[6] *= l),
            (Je.elements[8] *= c),
            (Je.elements[9] *= c),
            (Je.elements[10] *= c),
            t.setFromRotationMatrix(Je),
            (n.x = r),
            (n.y = s),
            (n.z = a),
            this
          );
        }
        makePerspective(e, t, n, i, r, s) {
          void 0 === s &&
            console.warn(
              "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
            );
          const a = this.elements,
            o = (2 * r) / (t - e),
            l = (2 * r) / (n - i),
            c = (t + e) / (t - e),
            u = (n + i) / (n - i),
            h = -(s + r) / (s - r),
            d = (-2 * s * r) / (s - r);
          return (
            (a[0] = o),
            (a[4] = 0),
            (a[8] = c),
            (a[12] = 0),
            (a[1] = 0),
            (a[5] = l),
            (a[9] = u),
            (a[13] = 0),
            (a[2] = 0),
            (a[6] = 0),
            (a[10] = h),
            (a[14] = d),
            (a[3] = 0),
            (a[7] = 0),
            (a[11] = -1),
            (a[15] = 0),
            this
          );
        }
        makeOrthographic(e, t, n, i, r, s) {
          const a = this.elements,
            o = 1 / (t - e),
            l = 1 / (n - i),
            c = 1 / (s - r),
            u = (t + e) * o,
            h = (n + i) * l,
            d = (s + r) * c;
          return (
            (a[0] = 2 * o),
            (a[4] = 0),
            (a[8] = 0),
            (a[12] = -u),
            (a[1] = 0),
            (a[5] = 2 * l),
            (a[9] = 0),
            (a[13] = -h),
            (a[2] = 0),
            (a[6] = 0),
            (a[10] = -2 * c),
            (a[14] = -d),
            (a[3] = 0),
            (a[7] = 0),
            (a[11] = 0),
            (a[15] = 1),
            this
          );
        }
        equals(e) {
          const t = this.elements,
            n = e.elements;
          for (let e = 0; e < 16; e++) if (t[e] !== n[e]) return !1;
          return !0;
        }
        fromArray(e, t = 0) {
          for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
          return this;
        }
        toArray(e = [], t = 0) {
          const n = this.elements;
          return (
            (e[t] = n[0]),
            (e[t + 1] = n[1]),
            (e[t + 2] = n[2]),
            (e[t + 3] = n[3]),
            (e[t + 4] = n[4]),
            (e[t + 5] = n[5]),
            (e[t + 6] = n[6]),
            (e[t + 7] = n[7]),
            (e[t + 8] = n[8]),
            (e[t + 9] = n[9]),
            (e[t + 10] = n[10]),
            (e[t + 11] = n[11]),
            (e[t + 12] = n[12]),
            (e[t + 13] = n[13]),
            (e[t + 14] = n[14]),
            (e[t + 15] = n[15]),
            e
          );
        }
      }
      const Ke = new xe(),
        Je = new $e(),
        Qe = new xe(0, 0, 0),
        et = new xe(1, 1, 1),
        tt = new xe(),
        nt = new xe(),
        it = new xe(),
        rt = new $e(),
        st = new _e();
      class at {
        constructor(e = 0, t = 0, n = 0, i = at.DefaultOrder) {
          (this.isEuler = !0),
            (this._x = e),
            (this._y = t),
            (this._z = n),
            (this._order = i);
        }
        get x() {
          return this._x;
        }
        set x(e) {
          (this._x = e), this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(e) {
          (this._y = e), this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(e) {
          (this._z = e), this._onChangeCallback();
        }
        get order() {
          return this._order;
        }
        set order(e) {
          (this._order = e), this._onChangeCallback();
        }
        set(e, t, n, i = this._order) {
          return (
            (this._x = e),
            (this._y = t),
            (this._z = n),
            (this._order = i),
            this._onChangeCallback(),
            this
          );
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(e) {
          return (
            (this._x = e._x),
            (this._y = e._y),
            (this._z = e._z),
            (this._order = e._order),
            this._onChangeCallback(),
            this
          );
        }
        setFromRotationMatrix(e, t = this._order, n = !0) {
          const i = e.elements,
            r = i[0],
            s = i[4],
            a = i[8],
            o = i[1],
            l = i[5],
            c = i[9],
            u = i[2],
            h = i[6],
            d = i[10];
          switch (t) {
            case "XYZ":
              (this._y = Math.asin(H(a, -1, 1))),
                Math.abs(a) < 0.9999999
                  ? ((this._x = Math.atan2(-c, d)),
                    (this._z = Math.atan2(-s, r)))
                  : ((this._x = Math.atan2(h, l)), (this._z = 0));
              break;
            case "YXZ":
              (this._x = Math.asin(-H(c, -1, 1))),
                Math.abs(c) < 0.9999999
                  ? ((this._y = Math.atan2(a, d)), (this._z = Math.atan2(o, l)))
                  : ((this._y = Math.atan2(-u, r)), (this._z = 0));
              break;
            case "ZXY":
              (this._x = Math.asin(H(h, -1, 1))),
                Math.abs(h) < 0.9999999
                  ? ((this._y = Math.atan2(-u, d)),
                    (this._z = Math.atan2(-s, l)))
                  : ((this._y = 0), (this._z = Math.atan2(o, r)));
              break;
            case "ZYX":
              (this._y = Math.asin(-H(u, -1, 1))),
                Math.abs(u) < 0.9999999
                  ? ((this._x = Math.atan2(h, d)), (this._z = Math.atan2(o, r)))
                  : ((this._x = 0), (this._z = Math.atan2(-s, l)));
              break;
            case "YZX":
              (this._z = Math.asin(H(o, -1, 1))),
                Math.abs(o) < 0.9999999
                  ? ((this._x = Math.atan2(-c, l)),
                    (this._y = Math.atan2(-u, r)))
                  : ((this._x = 0), (this._y = Math.atan2(a, d)));
              break;
            case "XZY":
              (this._z = Math.asin(-H(s, -1, 1))),
                Math.abs(s) < 0.9999999
                  ? ((this._x = Math.atan2(h, l)), (this._y = Math.atan2(a, r)))
                  : ((this._x = Math.atan2(-c, d)), (this._y = 0));
              break;
            default:
              console.warn(
                "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
                  t
              );
          }
          return (this._order = t), !0 === n && this._onChangeCallback(), this;
        }
        setFromQuaternion(e, t, n) {
          return (
            rt.makeRotationFromQuaternion(e),
            this.setFromRotationMatrix(rt, t, n)
          );
        }
        setFromVector3(e, t = this._order) {
          return this.set(e.x, e.y, e.z, t);
        }
        reorder(e) {
          return st.setFromEuler(this), this.setFromQuaternion(st, e);
        }
        equals(e) {
          return (
            e._x === this._x &&
            e._y === this._y &&
            e._z === this._z &&
            e._order === this._order
          );
        }
        fromArray(e) {
          return (
            (this._x = e[0]),
            (this._y = e[1]),
            (this._z = e[2]),
            void 0 !== e[3] && (this._order = e[3]),
            this._onChangeCallback(),
            this
          );
        }
        toArray(e = [], t = 0) {
          return (
            (e[t] = this._x),
            (e[t + 1] = this._y),
            (e[t + 2] = this._z),
            (e[t + 3] = this._order),
            e
          );
        }
        _onChange(e) {
          return (this._onChangeCallback = e), this;
        }
        _onChangeCallback() {}
        *[Symbol.iterator]() {
          yield this._x, yield this._y, yield this._z, yield this._order;
        }
        toVector3() {
          console.error(
            "THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead"
          );
        }
      }
      (at.DefaultOrder = "XYZ"),
        (at.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]);
      class ot {
        constructor() {
          this.mask = 1;
        }
        set(e) {
          this.mask = ((1 << e) | 0) >>> 0;
        }
        enable(e) {
          this.mask |= (1 << e) | 0;
        }
        enableAll() {
          this.mask = -1;
        }
        toggle(e) {
          this.mask ^= (1 << e) | 0;
        }
        disable(e) {
          this.mask &= ~((1 << e) | 0);
        }
        disableAll() {
          this.mask = 0;
        }
        test(e) {
          return 0 != (this.mask & e.mask);
        }
        isEnabled(e) {
          return 0 != (this.mask & ((1 << e) | 0));
        }
      }
      let lt = 0;
      const ct = new xe(),
        ut = new _e(),
        ht = new $e(),
        dt = new xe(),
        pt = new xe(),
        ft = new xe(),
        mt = new _e(),
        gt = new xe(1, 0, 0),
        vt = new xe(0, 1, 0),
        _t = new xe(0, 0, 1),
        xt = { type: "added" },
        yt = { type: "removed" };
      class bt extends z {
        constructor() {
          super(),
            (this.isObject3D = !0),
            Object.defineProperty(this, "id", { value: lt++ }),
            (this.uuid = G()),
            (this.name = ""),
            (this.type = "Object3D"),
            (this.parent = null),
            (this.children = []),
            (this.up = bt.DefaultUp.clone());
          const e = new xe(),
            t = new at(),
            n = new _e(),
            i = new xe(1, 1, 1);
          t._onChange(function () {
            n.setFromEuler(t, !1);
          }),
            n._onChange(function () {
              t.setFromQuaternion(n, void 0, !1);
            }),
            Object.defineProperties(this, {
              position: { configurable: !0, enumerable: !0, value: e },
              rotation: { configurable: !0, enumerable: !0, value: t },
              quaternion: { configurable: !0, enumerable: !0, value: n },
              scale: { configurable: !0, enumerable: !0, value: i },
              modelViewMatrix: { value: new $e() },
              normalMatrix: { value: new Y() },
            }),
            (this.matrix = new $e()),
            (this.matrixWorld = new $e()),
            (this.matrixAutoUpdate = bt.DefaultMatrixAutoUpdate),
            (this.matrixWorldNeedsUpdate = !1),
            (this.layers = new ot()),
            (this.visible = !0),
            (this.castShadow = !1),
            (this.receiveShadow = !1),
            (this.frustumCulled = !0),
            (this.renderOrder = 0),
            (this.animations = []),
            (this.userData = {});
        }
        onBeforeRender() {}
        onAfterRender() {}
        applyMatrix4(e) {
          this.matrixAutoUpdate && this.updateMatrix(),
            this.matrix.premultiply(e),
            this.matrix.decompose(this.position, this.quaternion, this.scale);
        }
        applyQuaternion(e) {
          return this.quaternion.premultiply(e), this;
        }
        setRotationFromAxisAngle(e, t) {
          this.quaternion.setFromAxisAngle(e, t);
        }
        setRotationFromEuler(e) {
          this.quaternion.setFromEuler(e, !0);
        }
        setRotationFromMatrix(e) {
          this.quaternion.setFromRotationMatrix(e);
        }
        setRotationFromQuaternion(e) {
          this.quaternion.copy(e);
        }
        rotateOnAxis(e, t) {
          return ut.setFromAxisAngle(e, t), this.quaternion.multiply(ut), this;
        }
        rotateOnWorldAxis(e, t) {
          return (
            ut.setFromAxisAngle(e, t), this.quaternion.premultiply(ut), this
          );
        }
        rotateX(e) {
          return this.rotateOnAxis(gt, e);
        }
        rotateY(e) {
          return this.rotateOnAxis(vt, e);
        }
        rotateZ(e) {
          return this.rotateOnAxis(_t, e);
        }
        translateOnAxis(e, t) {
          return (
            ct.copy(e).applyQuaternion(this.quaternion),
            this.position.add(ct.multiplyScalar(t)),
            this
          );
        }
        translateX(e) {
          return this.translateOnAxis(gt, e);
        }
        translateY(e) {
          return this.translateOnAxis(vt, e);
        }
        translateZ(e) {
          return this.translateOnAxis(_t, e);
        }
        localToWorld(e) {
          return e.applyMatrix4(this.matrixWorld);
        }
        worldToLocal(e) {
          return e.applyMatrix4(ht.copy(this.matrixWorld).invert());
        }
        lookAt(e, t, n) {
          e.isVector3 ? dt.copy(e) : dt.set(e, t, n);
          const i = this.parent;
          this.updateWorldMatrix(!0, !1),
            pt.setFromMatrixPosition(this.matrixWorld),
            this.isCamera || this.isLight
              ? ht.lookAt(pt, dt, this.up)
              : ht.lookAt(dt, pt, this.up),
            this.quaternion.setFromRotationMatrix(ht),
            i &&
              (ht.extractRotation(i.matrixWorld),
              ut.setFromRotationMatrix(ht),
              this.quaternion.premultiply(ut.invert()));
        }
        add(e) {
          if (arguments.length > 1) {
            for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
            return this;
          }
          return e === this
            ? (console.error(
                "THREE.Object3D.add: object can't be added as a child of itself.",
                e
              ),
              this)
            : (e && e.isObject3D
                ? (null !== e.parent && e.parent.remove(e),
                  (e.parent = this),
                  this.children.push(e),
                  e.dispatchEvent(xt))
                : console.error(
                    "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                    e
                  ),
              this);
        }
        remove(e) {
          if (arguments.length > 1) {
            for (let e = 0; e < arguments.length; e++)
              this.remove(arguments[e]);
            return this;
          }
          const t = this.children.indexOf(e);
          return (
            -1 !== t &&
              ((e.parent = null),
              this.children.splice(t, 1),
              e.dispatchEvent(yt)),
            this
          );
        }
        removeFromParent() {
          const e = this.parent;
          return null !== e && e.remove(this), this;
        }
        clear() {
          for (let e = 0; e < this.children.length; e++) {
            const t = this.children[e];
            (t.parent = null), t.dispatchEvent(yt);
          }
          return (this.children.length = 0), this;
        }
        attach(e) {
          return (
            this.updateWorldMatrix(!0, !1),
            ht.copy(this.matrixWorld).invert(),
            null !== e.parent &&
              (e.parent.updateWorldMatrix(!0, !1),
              ht.multiply(e.parent.matrixWorld)),
            e.applyMatrix4(ht),
            this.add(e),
            e.updateWorldMatrix(!1, !0),
            this
          );
        }
        getObjectById(e) {
          return this.getObjectByProperty("id", e);
        }
        getObjectByName(e) {
          return this.getObjectByProperty("name", e);
        }
        getObjectByProperty(e, t) {
          if (this[e] === t) return this;
          for (let n = 0, i = this.children.length; n < i; n++) {
            const i = this.children[n].getObjectByProperty(e, t);
            if (void 0 !== i) return i;
          }
        }
        getWorldPosition(e) {
          return (
            this.updateWorldMatrix(!0, !1),
            e.setFromMatrixPosition(this.matrixWorld)
          );
        }
        getWorldQuaternion(e) {
          return (
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(pt, e, ft),
            e
          );
        }
        getWorldScale(e) {
          return (
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(pt, mt, e),
            e
          );
        }
        getWorldDirection(e) {
          this.updateWorldMatrix(!0, !1);
          const t = this.matrixWorld.elements;
          return e.set(t[8], t[9], t[10]).normalize();
        }
        raycast() {}
        traverse(e) {
          e(this);
          const t = this.children;
          for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e);
        }
        traverseVisible(e) {
          if (!1 === this.visible) return;
          e(this);
          const t = this.children;
          for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e);
        }
        traverseAncestors(e) {
          const t = this.parent;
          null !== t && (e(t), t.traverseAncestors(e));
        }
        updateMatrix() {
          this.matrix.compose(this.position, this.quaternion, this.scale),
            (this.matrixWorldNeedsUpdate = !0);
        }
        updateMatrixWorld(e) {
          this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || e) &&
              (null === this.parent
                ? this.matrixWorld.copy(this.matrix)
                : this.matrixWorld.multiplyMatrices(
                    this.parent.matrixWorld,
                    this.matrix
                  ),
              (this.matrixWorldNeedsUpdate = !1),
              (e = !0));
          const t = this.children;
          for (let n = 0, i = t.length; n < i; n++) t[n].updateMatrixWorld(e);
        }
        updateWorldMatrix(e, t) {
          const n = this.parent;
          if (
            (!0 === e && null !== n && n.updateWorldMatrix(!0, !1),
            this.matrixAutoUpdate && this.updateMatrix(),
            null === this.parent
              ? this.matrixWorld.copy(this.matrix)
              : this.matrixWorld.multiplyMatrices(
                  this.parent.matrixWorld,
                  this.matrix
                ),
            !0 === t)
          ) {
            const e = this.children;
            for (let t = 0, n = e.length; t < n; t++)
              e[t].updateWorldMatrix(!1, !0);
          }
        }
        toJSON(e) {
          const t = void 0 === e || "string" == typeof e,
            n = {};
          t &&
            ((e = {
              geometries: {},
              materials: {},
              textures: {},
              images: {},
              shapes: {},
              skeletons: {},
              animations: {},
              nodes: {},
            }),
            (n.metadata = {
              version: 4.5,
              type: "Object",
              generator: "Object3D.toJSON",
            }));
          const i = {};
          function r(t, n) {
            return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid;
          }
          if (
            ((i.uuid = this.uuid),
            (i.type = this.type),
            "" !== this.name && (i.name = this.name),
            !0 === this.castShadow && (i.castShadow = !0),
            !0 === this.receiveShadow && (i.receiveShadow = !0),
            !1 === this.visible && (i.visible = !1),
            !1 === this.frustumCulled && (i.frustumCulled = !1),
            0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
            "{}" !== JSON.stringify(this.userData) &&
              (i.userData = this.userData),
            (i.layers = this.layers.mask),
            (i.matrix = this.matrix.toArray()),
            !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
            this.isInstancedMesh &&
              ((i.type = "InstancedMesh"),
              (i.count = this.count),
              (i.instanceMatrix = this.instanceMatrix.toJSON()),
              null !== this.instanceColor &&
                (i.instanceColor = this.instanceColor.toJSON())),
            this.isScene)
          )
            this.background &&
              (this.background.isColor
                ? (i.background = this.background.toJSON())
                : this.background.isTexture &&
                  (i.background = this.background.toJSON(e).uuid)),
              this.environment &&
                this.environment.isTexture &&
                (i.environment = this.environment.toJSON(e).uuid);
          else if (this.isMesh || this.isLine || this.isPoints) {
            i.geometry = r(e.geometries, this.geometry);
            const t = this.geometry.parameters;
            if (void 0 !== t && void 0 !== t.shapes) {
              const n = t.shapes;
              if (Array.isArray(n))
                for (let t = 0, i = n.length; t < i; t++) {
                  const i = n[t];
                  r(e.shapes, i);
                }
              else r(e.shapes, n);
            }
          }
          if (
            (this.isSkinnedMesh &&
              ((i.bindMode = this.bindMode),
              (i.bindMatrix = this.bindMatrix.toArray()),
              void 0 !== this.skeleton &&
                (r(e.skeletons, this.skeleton),
                (i.skeleton = this.skeleton.uuid))),
            void 0 !== this.material)
          )
            if (Array.isArray(this.material)) {
              const t = [];
              for (let n = 0, i = this.material.length; n < i; n++)
                t.push(r(e.materials, this.material[n]));
              i.material = t;
            } else i.material = r(e.materials, this.material);
          if (this.children.length > 0) {
            i.children = [];
            for (let t = 0; t < this.children.length; t++)
              i.children.push(this.children[t].toJSON(e).object);
          }
          if (this.animations.length > 0) {
            i.animations = [];
            for (let t = 0; t < this.animations.length; t++) {
              const n = this.animations[t];
              i.animations.push(r(e.animations, n));
            }
          }
          if (t) {
            const t = s(e.geometries),
              i = s(e.materials),
              r = s(e.textures),
              a = s(e.images),
              o = s(e.shapes),
              l = s(e.skeletons),
              c = s(e.animations),
              u = s(e.nodes);
            t.length > 0 && (n.geometries = t),
              i.length > 0 && (n.materials = i),
              r.length > 0 && (n.textures = r),
              a.length > 0 && (n.images = a),
              o.length > 0 && (n.shapes = o),
              l.length > 0 && (n.skeletons = l),
              c.length > 0 && (n.animations = c),
              u.length > 0 && (n.nodes = u);
          }
          return (n.object = i), n;
          function s(e) {
            const t = [];
            for (const n in e) {
              const i = e[n];
              delete i.metadata, t.push(i);
            }
            return t;
          }
        }
        clone(e) {
          return new this.constructor().copy(this, e);
        }
        copy(e, t = !0) {
          if (
            ((this.name = e.name),
            this.up.copy(e.up),
            this.position.copy(e.position),
            (this.rotation.order = e.rotation.order),
            this.quaternion.copy(e.quaternion),
            this.scale.copy(e.scale),
            this.matrix.copy(e.matrix),
            this.matrixWorld.copy(e.matrixWorld),
            (this.matrixAutoUpdate = e.matrixAutoUpdate),
            (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
            (this.layers.mask = e.layers.mask),
            (this.visible = e.visible),
            (this.castShadow = e.castShadow),
            (this.receiveShadow = e.receiveShadow),
            (this.frustumCulled = e.frustumCulled),
            (this.renderOrder = e.renderOrder),
            (this.userData = JSON.parse(JSON.stringify(e.userData))),
            !0 === t)
          )
            for (let t = 0; t < e.children.length; t++) {
              const n = e.children[t];
              this.add(n.clone());
            }
          return this;
        }
      }
      (bt.DefaultUp = new xe(0, 1, 0)), (bt.DefaultMatrixAutoUpdate = !0);
      const wt = new xe(),
        St = new xe(),
        Mt = new xe(),
        Et = new xe(),
        Tt = new xe(),
        At = new xe(),
        Ct = new xe(),
        Lt = new xe(),
        Pt = new xe(),
        Dt = new xe();
      class kt {
        constructor(e = new xe(), t = new xe(), n = new xe()) {
          (this.a = e), (this.b = t), (this.c = n);
        }
        static getNormal(e, t, n, i) {
          i.subVectors(n, t), wt.subVectors(e, t), i.cross(wt);
          const r = i.lengthSq();
          return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
        }
        static getBarycoord(e, t, n, i, r) {
          wt.subVectors(i, t), St.subVectors(n, t), Mt.subVectors(e, t);
          const s = wt.dot(wt),
            a = wt.dot(St),
            o = wt.dot(Mt),
            l = St.dot(St),
            c = St.dot(Mt),
            u = s * l - a * a;
          if (0 === u) return r.set(-2, -1, -1);
          const h = 1 / u,
            d = (l * o - a * c) * h,
            p = (s * c - a * o) * h;
          return r.set(1 - d - p, p, d);
        }
        static containsPoint(e, t, n, i) {
          return (
            this.getBarycoord(e, t, n, i, Et),
            Et.x >= 0 && Et.y >= 0 && Et.x + Et.y <= 1
          );
        }
        static getUV(e, t, n, i, r, s, a, o) {
          return (
            this.getBarycoord(e, t, n, i, Et),
            o.set(0, 0),
            o.addScaledVector(r, Et.x),
            o.addScaledVector(s, Et.y),
            o.addScaledVector(a, Et.z),
            o
          );
        }
        static isFrontFacing(e, t, n, i) {
          return (
            wt.subVectors(n, t), St.subVectors(e, t), wt.cross(St).dot(i) < 0
          );
        }
        set(e, t, n) {
          return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
        }
        setFromPointsAndIndices(e, t, n, i) {
          return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this;
        }
        setFromAttributeAndIndices(e, t, n, i) {
          return (
            this.a.fromBufferAttribute(e, t),
            this.b.fromBufferAttribute(e, n),
            this.c.fromBufferAttribute(e, i),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
        }
        getArea() {
          return (
            wt.subVectors(this.c, this.b),
            St.subVectors(this.a, this.b),
            0.5 * wt.cross(St).length()
          );
        }
        getMidpoint(e) {
          return e
            .addVectors(this.a, this.b)
            .add(this.c)
            .multiplyScalar(1 / 3);
        }
        getNormal(e) {
          return kt.getNormal(this.a, this.b, this.c, e);
        }
        getPlane(e) {
          return e.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(e, t) {
          return kt.getBarycoord(e, this.a, this.b, this.c, t);
        }
        getUV(e, t, n, i, r) {
          return kt.getUV(e, this.a, this.b, this.c, t, n, i, r);
        }
        containsPoint(e) {
          return kt.containsPoint(e, this.a, this.b, this.c);
        }
        isFrontFacing(e) {
          return kt.isFrontFacing(this.a, this.b, this.c, e);
        }
        intersectsBox(e) {
          return e.intersectsTriangle(this);
        }
        closestPointToPoint(e, t) {
          const n = this.a,
            i = this.b,
            r = this.c;
          let s, a;
          Tt.subVectors(i, n), At.subVectors(r, n), Lt.subVectors(e, n);
          const o = Tt.dot(Lt),
            l = At.dot(Lt);
          if (o <= 0 && l <= 0) return t.copy(n);
          Pt.subVectors(e, i);
          const c = Tt.dot(Pt),
            u = At.dot(Pt);
          if (c >= 0 && u <= c) return t.copy(i);
          const h = o * u - c * l;
          if (h <= 0 && o >= 0 && c <= 0)
            return (s = o / (o - c)), t.copy(n).addScaledVector(Tt, s);
          Dt.subVectors(e, r);
          const d = Tt.dot(Dt),
            p = At.dot(Dt);
          if (p >= 0 && d <= p) return t.copy(r);
          const f = d * l - o * p;
          if (f <= 0 && l >= 0 && p <= 0)
            return (a = l / (l - p)), t.copy(n).addScaledVector(At, a);
          const m = c * p - d * u;
          if (m <= 0 && u - c >= 0 && d - p >= 0)
            return (
              Ct.subVectors(r, i),
              (a = (u - c) / (u - c + (d - p))),
              t.copy(i).addScaledVector(Ct, a)
            );
          const g = 1 / (m + f + h);
          return (
            (s = f * g),
            (a = h * g),
            t.copy(n).addScaledVector(Tt, s).addScaledVector(At, a)
          );
        }
        equals(e) {
          return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
        }
      }
      let Rt = 0;
      class It extends z {
        constructor() {
          super(),
            (this.isMaterial = !0),
            Object.defineProperty(this, "id", { value: Rt++ }),
            (this.uuid = G()),
            (this.name = ""),
            (this.type = "Material"),
            (this.blending = 1),
            (this.side = 0),
            (this.vertexColors = !1),
            (this.opacity = 1),
            (this.transparent = !1),
            (this.blendSrc = 204),
            (this.blendDst = 205),
            (this.blendEquation = a),
            (this.blendSrcAlpha = null),
            (this.blendDstAlpha = null),
            (this.blendEquationAlpha = null),
            (this.depthFunc = 3),
            (this.depthTest = !0),
            (this.depthWrite = !0),
            (this.stencilWriteMask = 255),
            (this.stencilFunc = 519),
            (this.stencilRef = 0),
            (this.stencilFuncMask = 255),
            (this.stencilFail = F),
            (this.stencilZFail = F),
            (this.stencilZPass = F),
            (this.stencilWrite = !1),
            (this.clippingPlanes = null),
            (this.clipIntersection = !1),
            (this.clipShadows = !1),
            (this.shadowSide = null),
            (this.colorWrite = !0),
            (this.precision = null),
            (this.polygonOffset = !1),
            (this.polygonOffsetFactor = 0),
            (this.polygonOffsetUnits = 0),
            (this.dithering = !1),
            (this.alphaToCoverage = !1),
            (this.premultipliedAlpha = !1),
            (this.visible = !0),
            (this.toneMapped = !0),
            (this.userData = {}),
            (this.version = 0),
            (this._alphaTest = 0);
        }
        get alphaTest() {
          return this._alphaTest;
        }
        set alphaTest(e) {
          this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
        }
        onBuild() {}
        onBeforeRender() {}
        onBeforeCompile() {}
        customProgramCacheKey() {
          return this.onBeforeCompile.toString();
        }
        setValues(e) {
          if (void 0 !== e)
            for (const t in e) {
              const n = e[t];
              if (void 0 === n) {
                console.warn(
                  "THREE.Material: '" + t + "' parameter is undefined."
                );
                continue;
              }
              if ("shading" === t) {
                console.warn(
                  "THREE." +
                    this.type +
                    ": .shading has been removed. Use the boolean .flatShading instead."
                ),
                  (this.flatShading = 1 === n);
                continue;
              }
              const i = this[t];
              void 0 !== i
                ? i && i.isColor
                  ? i.set(n)
                  : i && i.isVector3 && n && n.isVector3
                  ? i.copy(n)
                  : (this[t] = n)
                : console.warn(
                    "THREE." +
                      this.type +
                      ": '" +
                      t +
                      "' is not a property of this material."
                  );
            }
        }
        toJSON(e) {
          const t = void 0 === e || "string" == typeof e;
          t && (e = { textures: {}, images: {} });
          const n = {
            metadata: {
              version: 4.5,
              type: "Material",
              generator: "Material.toJSON",
            },
          };
          function i(e) {
            const t = [];
            for (const n in e) {
              const i = e[n];
              delete i.metadata, t.push(i);
            }
            return t;
          }
          if (
            ((n.uuid = this.uuid),
            (n.type = this.type),
            "" !== this.name && (n.name = this.name),
            this.color && this.color.isColor && (n.color = this.color.getHex()),
            void 0 !== this.roughness && (n.roughness = this.roughness),
            void 0 !== this.metalness && (n.metalness = this.metalness),
            void 0 !== this.sheen && (n.sheen = this.sheen),
            this.sheenColor &&
              this.sheenColor.isColor &&
              (n.sheenColor = this.sheenColor.getHex()),
            void 0 !== this.sheenRoughness &&
              (n.sheenRoughness = this.sheenRoughness),
            this.emissive &&
              this.emissive.isColor &&
              (n.emissive = this.emissive.getHex()),
            this.emissiveIntensity &&
              1 !== this.emissiveIntensity &&
              (n.emissiveIntensity = this.emissiveIntensity),
            this.specular &&
              this.specular.isColor &&
              (n.specular = this.specular.getHex()),
            void 0 !== this.specularIntensity &&
              (n.specularIntensity = this.specularIntensity),
            this.specularColor &&
              this.specularColor.isColor &&
              (n.specularColor = this.specularColor.getHex()),
            void 0 !== this.shininess && (n.shininess = this.shininess),
            void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
            void 0 !== this.clearcoatRoughness &&
              (n.clearcoatRoughness = this.clearcoatRoughness),
            this.clearcoatMap &&
              this.clearcoatMap.isTexture &&
              (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
            this.clearcoatRoughnessMap &&
              this.clearcoatRoughnessMap.isTexture &&
              (n.clearcoatRoughnessMap =
                this.clearcoatRoughnessMap.toJSON(e).uuid),
            this.clearcoatNormalMap &&
              this.clearcoatNormalMap.isTexture &&
              ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
              (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
            void 0 !== this.iridescence && (n.iridescence = this.iridescence),
            void 0 !== this.iridescenceIOR &&
              (n.iridescenceIOR = this.iridescenceIOR),
            void 0 !== this.iridescenceThicknessRange &&
              (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
            this.iridescenceMap &&
              this.iridescenceMap.isTexture &&
              (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
            this.iridescenceThicknessMap &&
              this.iridescenceThicknessMap.isTexture &&
              (n.iridescenceThicknessMap =
                this.iridescenceThicknessMap.toJSON(e).uuid),
            this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
            this.matcap &&
              this.matcap.isTexture &&
              (n.matcap = this.matcap.toJSON(e).uuid),
            this.alphaMap &&
              this.alphaMap.isTexture &&
              (n.alphaMap = this.alphaMap.toJSON(e).uuid),
            this.lightMap &&
              this.lightMap.isTexture &&
              ((n.lightMap = this.lightMap.toJSON(e).uuid),
              (n.lightMapIntensity = this.lightMapIntensity)),
            this.aoMap &&
              this.aoMap.isTexture &&
              ((n.aoMap = this.aoMap.toJSON(e).uuid),
              (n.aoMapIntensity = this.aoMapIntensity)),
            this.bumpMap &&
              this.bumpMap.isTexture &&
              ((n.bumpMap = this.bumpMap.toJSON(e).uuid),
              (n.bumpScale = this.bumpScale)),
            this.normalMap &&
              this.normalMap.isTexture &&
              ((n.normalMap = this.normalMap.toJSON(e).uuid),
              (n.normalMapType = this.normalMapType),
              (n.normalScale = this.normalScale.toArray())),
            this.displacementMap &&
              this.displacementMap.isTexture &&
              ((n.displacementMap = this.displacementMap.toJSON(e).uuid),
              (n.displacementScale = this.displacementScale),
              (n.displacementBias = this.displacementBias)),
            this.roughnessMap &&
              this.roughnessMap.isTexture &&
              (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
            this.metalnessMap &&
              this.metalnessMap.isTexture &&
              (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
            this.emissiveMap &&
              this.emissiveMap.isTexture &&
              (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
            this.specularMap &&
              this.specularMap.isTexture &&
              (n.specularMap = this.specularMap.toJSON(e).uuid),
            this.specularIntensityMap &&
              this.specularIntensityMap.isTexture &&
              (n.specularIntensityMap =
                this.specularIntensityMap.toJSON(e).uuid),
            this.specularColorMap &&
              this.specularColorMap.isTexture &&
              (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
            this.envMap &&
              this.envMap.isTexture &&
              ((n.envMap = this.envMap.toJSON(e).uuid),
              void 0 !== this.combine && (n.combine = this.combine)),
            void 0 !== this.envMapIntensity &&
              (n.envMapIntensity = this.envMapIntensity),
            void 0 !== this.reflectivity &&
              (n.reflectivity = this.reflectivity),
            void 0 !== this.refractionRatio &&
              (n.refractionRatio = this.refractionRatio),
            this.gradientMap &&
              this.gradientMap.isTexture &&
              (n.gradientMap = this.gradientMap.toJSON(e).uuid),
            void 0 !== this.transmission &&
              (n.transmission = this.transmission),
            this.transmissionMap &&
              this.transmissionMap.isTexture &&
              (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
            void 0 !== this.thickness && (n.thickness = this.thickness),
            this.thicknessMap &&
              this.thicknessMap.isTexture &&
              (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
            void 0 !== this.attenuationDistance &&
              (n.attenuationDistance = this.attenuationDistance),
            void 0 !== this.attenuationColor &&
              (n.attenuationColor = this.attenuationColor.getHex()),
            void 0 !== this.size && (n.size = this.size),
            null !== this.shadowSide && (n.shadowSide = this.shadowSide),
            void 0 !== this.sizeAttenuation &&
              (n.sizeAttenuation = this.sizeAttenuation),
            1 !== this.blending && (n.blending = this.blending),
            0 !== this.side && (n.side = this.side),
            this.vertexColors && (n.vertexColors = !0),
            this.opacity < 1 && (n.opacity = this.opacity),
            !0 === this.transparent && (n.transparent = this.transparent),
            (n.depthFunc = this.depthFunc),
            (n.depthTest = this.depthTest),
            (n.depthWrite = this.depthWrite),
            (n.colorWrite = this.colorWrite),
            (n.stencilWrite = this.stencilWrite),
            (n.stencilWriteMask = this.stencilWriteMask),
            (n.stencilFunc = this.stencilFunc),
            (n.stencilRef = this.stencilRef),
            (n.stencilFuncMask = this.stencilFuncMask),
            (n.stencilFail = this.stencilFail),
            (n.stencilZFail = this.stencilZFail),
            (n.stencilZPass = this.stencilZPass),
            void 0 !== this.rotation &&
              0 !== this.rotation &&
              (n.rotation = this.rotation),
            !0 === this.polygonOffset && (n.polygonOffset = !0),
            0 !== this.polygonOffsetFactor &&
              (n.polygonOffsetFactor = this.polygonOffsetFactor),
            0 !== this.polygonOffsetUnits &&
              (n.polygonOffsetUnits = this.polygonOffsetUnits),
            void 0 !== this.linewidth &&
              1 !== this.linewidth &&
              (n.linewidth = this.linewidth),
            void 0 !== this.dashSize && (n.dashSize = this.dashSize),
            void 0 !== this.gapSize && (n.gapSize = this.gapSize),
            void 0 !== this.scale && (n.scale = this.scale),
            !0 === this.dithering && (n.dithering = !0),
            this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
            !0 === this.alphaToCoverage &&
              (n.alphaToCoverage = this.alphaToCoverage),
            !0 === this.premultipliedAlpha &&
              (n.premultipliedAlpha = this.premultipliedAlpha),
            !0 === this.wireframe && (n.wireframe = this.wireframe),
            this.wireframeLinewidth > 1 &&
              (n.wireframeLinewidth = this.wireframeLinewidth),
            "round" !== this.wireframeLinecap &&
              (n.wireframeLinecap = this.wireframeLinecap),
            "round" !== this.wireframeLinejoin &&
              (n.wireframeLinejoin = this.wireframeLinejoin),
            !0 === this.flatShading && (n.flatShading = this.flatShading),
            !1 === this.visible && (n.visible = !1),
            !1 === this.toneMapped && (n.toneMapped = !1),
            !1 === this.fog && (n.fog = !1),
            "{}" !== JSON.stringify(this.userData) &&
              (n.userData = this.userData),
            t)
          ) {
            const t = i(e.textures),
              r = i(e.images);
            t.length > 0 && (n.textures = t), r.length > 0 && (n.images = r);
          }
          return n;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          (this.name = e.name),
            (this.blending = e.blending),
            (this.side = e.side),
            (this.vertexColors = e.vertexColors),
            (this.opacity = e.opacity),
            (this.transparent = e.transparent),
            (this.blendSrc = e.blendSrc),
            (this.blendDst = e.blendDst),
            (this.blendEquation = e.blendEquation),
            (this.blendSrcAlpha = e.blendSrcAlpha),
            (this.blendDstAlpha = e.blendDstAlpha),
            (this.blendEquationAlpha = e.blendEquationAlpha),
            (this.depthFunc = e.depthFunc),
            (this.depthTest = e.depthTest),
            (this.depthWrite = e.depthWrite),
            (this.stencilWriteMask = e.stencilWriteMask),
            (this.stencilFunc = e.stencilFunc),
            (this.stencilRef = e.stencilRef),
            (this.stencilFuncMask = e.stencilFuncMask),
            (this.stencilFail = e.stencilFail),
            (this.stencilZFail = e.stencilZFail),
            (this.stencilZPass = e.stencilZPass),
            (this.stencilWrite = e.stencilWrite);
          const t = e.clippingPlanes;
          let n = null;
          if (null !== t) {
            const e = t.length;
            n = new Array(e);
            for (let i = 0; i !== e; ++i) n[i] = t[i].clone();
          }
          return (
            (this.clippingPlanes = n),
            (this.clipIntersection = e.clipIntersection),
            (this.clipShadows = e.clipShadows),
            (this.shadowSide = e.shadowSide),
            (this.colorWrite = e.colorWrite),
            (this.precision = e.precision),
            (this.polygonOffset = e.polygonOffset),
            (this.polygonOffsetFactor = e.polygonOffsetFactor),
            (this.polygonOffsetUnits = e.polygonOffsetUnits),
            (this.dithering = e.dithering),
            (this.alphaTest = e.alphaTest),
            (this.alphaToCoverage = e.alphaToCoverage),
            (this.premultipliedAlpha = e.premultipliedAlpha),
            (this.visible = e.visible),
            (this.toneMapped = e.toneMapped),
            (this.userData = JSON.parse(JSON.stringify(e.userData))),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        set needsUpdate(e) {
          !0 === e && this.version++;
        }
      }
      class Ft extends It {
        constructor(e) {
          super(),
            (this.isMeshBasicMaterial = !0),
            (this.type = "MeshBasicMaterial"),
            (this.color = new oe(16777215)),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.combine = 0),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.fog = e.fog),
            this
          );
        }
      }
      const Ot = new xe(),
        Nt = new X();
      class zt {
        constructor(e, t, n) {
          if (Array.isArray(e))
            throw new TypeError(
              "THREE.BufferAttribute: array should be a Typed Array."
            );
          (this.isBufferAttribute = !0),
            (this.name = ""),
            (this.array = e),
            (this.itemSize = t),
            (this.count = void 0 !== e ? e.length / t : 0),
            (this.normalized = !0 === n),
            (this.usage = 35044),
            (this.updateRange = { offset: 0, count: -1 }),
            (this.version = 0);
        }
        onUploadCallback() {}
        set needsUpdate(e) {
          !0 === e && this.version++;
        }
        setUsage(e) {
          return (this.usage = e), this;
        }
        copy(e) {
          return (
            (this.name = e.name),
            (this.array = new e.array.constructor(e.array)),
            (this.itemSize = e.itemSize),
            (this.count = e.count),
            (this.normalized = e.normalized),
            (this.usage = e.usage),
            this
          );
        }
        copyAt(e, t, n) {
          (e *= this.itemSize), (n *= t.itemSize);
          for (let i = 0, r = this.itemSize; i < r; i++)
            this.array[e + i] = t.array[n + i];
          return this;
        }
        copyArray(e) {
          return this.array.set(e), this;
        }
        copyColorsArray(e) {
          const t = this.array;
          let n = 0;
          for (let i = 0, r = e.length; i < r; i++) {
            let r = e[i];
            void 0 === r &&
              (console.warn(
                "THREE.BufferAttribute.copyColorsArray(): color is undefined",
                i
              ),
              (r = new oe())),
              (t[n++] = r.r),
              (t[n++] = r.g),
              (t[n++] = r.b);
          }
          return this;
        }
        copyVector2sArray(e) {
          const t = this.array;
          let n = 0;
          for (let i = 0, r = e.length; i < r; i++) {
            let r = e[i];
            void 0 === r &&
              (console.warn(
                "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
                i
              ),
              (r = new X())),
              (t[n++] = r.x),
              (t[n++] = r.y);
          }
          return this;
        }
        copyVector3sArray(e) {
          const t = this.array;
          let n = 0;
          for (let i = 0, r = e.length; i < r; i++) {
            let r = e[i];
            void 0 === r &&
              (console.warn(
                "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
                i
              ),
              (r = new xe())),
              (t[n++] = r.x),
              (t[n++] = r.y),
              (t[n++] = r.z);
          }
          return this;
        }
        copyVector4sArray(e) {
          const t = this.array;
          let n = 0;
          for (let i = 0, r = e.length; i < r; i++) {
            let r = e[i];
            void 0 === r &&
              (console.warn(
                "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
                i
              ),
              (r = new fe())),
              (t[n++] = r.x),
              (t[n++] = r.y),
              (t[n++] = r.z),
              (t[n++] = r.w);
          }
          return this;
        }
        applyMatrix3(e) {
          if (2 === this.itemSize)
            for (let t = 0, n = this.count; t < n; t++)
              Nt.fromBufferAttribute(this, t),
                Nt.applyMatrix3(e),
                this.setXY(t, Nt.x, Nt.y);
          else if (3 === this.itemSize)
            for (let t = 0, n = this.count; t < n; t++)
              Ot.fromBufferAttribute(this, t),
                Ot.applyMatrix3(e),
                this.setXYZ(t, Ot.x, Ot.y, Ot.z);
          return this;
        }
        applyMatrix4(e) {
          for (let t = 0, n = this.count; t < n; t++)
            Ot.fromBufferAttribute(this, t),
              Ot.applyMatrix4(e),
              this.setXYZ(t, Ot.x, Ot.y, Ot.z);
          return this;
        }
        applyNormalMatrix(e) {
          for (let t = 0, n = this.count; t < n; t++)
            Ot.fromBufferAttribute(this, t),
              Ot.applyNormalMatrix(e),
              this.setXYZ(t, Ot.x, Ot.y, Ot.z);
          return this;
        }
        transformDirection(e) {
          for (let t = 0, n = this.count; t < n; t++)
            Ot.fromBufferAttribute(this, t),
              Ot.transformDirection(e),
              this.setXYZ(t, Ot.x, Ot.y, Ot.z);
          return this;
        }
        set(e, t = 0) {
          return this.array.set(e, t), this;
        }
        getX(e) {
          return this.array[e * this.itemSize];
        }
        setX(e, t) {
          return (this.array[e * this.itemSize] = t), this;
        }
        getY(e) {
          return this.array[e * this.itemSize + 1];
        }
        setY(e, t) {
          return (this.array[e * this.itemSize + 1] = t), this;
        }
        getZ(e) {
          return this.array[e * this.itemSize + 2];
        }
        setZ(e, t) {
          return (this.array[e * this.itemSize + 2] = t), this;
        }
        getW(e) {
          return this.array[e * this.itemSize + 3];
        }
        setW(e, t) {
          return (this.array[e * this.itemSize + 3] = t), this;
        }
        setXY(e, t, n) {
          return (
            (e *= this.itemSize),
            (this.array[e + 0] = t),
            (this.array[e + 1] = n),
            this
          );
        }
        setXYZ(e, t, n, i) {
          return (
            (e *= this.itemSize),
            (this.array[e + 0] = t),
            (this.array[e + 1] = n),
            (this.array[e + 2] = i),
            this
          );
        }
        setXYZW(e, t, n, i, r) {
          return (
            (e *= this.itemSize),
            (this.array[e + 0] = t),
            (this.array[e + 1] = n),
            (this.array[e + 2] = i),
            (this.array[e + 3] = r),
            this
          );
        }
        onUpload(e) {
          return (this.onUploadCallback = e), this;
        }
        clone() {
          return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
          const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized,
          };
          return (
            "" !== this.name && (e.name = this.name),
            35044 !== this.usage && (e.usage = this.usage),
            (0 === this.updateRange.offset && -1 === this.updateRange.count) ||
              (e.updateRange = this.updateRange),
            e
          );
        }
      }
      class Bt extends zt {
        constructor(e, t, n) {
          super(new Uint16Array(e), t, n);
        }
      }
      class Ut extends zt {
        constructor(e, t, n) {
          super(new Uint32Array(e), t, n);
        }
      }
      class Vt extends zt {
        constructor(e, t, n) {
          super(new Float32Array(e), t, n);
        }
      }
      let Gt = 0;
      const Ht = new $e(),
        Wt = new bt(),
        jt = new xe(),
        qt = new we(),
        Xt = new we(),
        Yt = new xe();
      class Zt extends z {
        constructor() {
          super(),
            (this.isBufferGeometry = !0),
            Object.defineProperty(this, "id", { value: Gt++ }),
            (this.uuid = G()),
            (this.name = ""),
            (this.type = "BufferGeometry"),
            (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.morphTargetsRelative = !1),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null),
            (this.drawRange = { start: 0, count: 1 / 0 }),
            (this.userData = {});
        }
        getIndex() {
          return this.index;
        }
        setIndex(e) {
          return (
            Array.isArray(e)
              ? (this.index = new (Z(e) ? Ut : Bt)(e, 1))
              : (this.index = e),
            this
          );
        }
        getAttribute(e) {
          return this.attributes[e];
        }
        setAttribute(e, t) {
          return (this.attributes[e] = t), this;
        }
        deleteAttribute(e) {
          return delete this.attributes[e], this;
        }
        hasAttribute(e) {
          return void 0 !== this.attributes[e];
        }
        addGroup(e, t, n = 0) {
          this.groups.push({ start: e, count: t, materialIndex: n });
        }
        clearGroups() {
          this.groups = [];
        }
        setDrawRange(e, t) {
          (this.drawRange.start = e), (this.drawRange.count = t);
        }
        applyMatrix4(e) {
          const t = this.attributes.position;
          void 0 !== t && (t.applyMatrix4(e), (t.needsUpdate = !0));
          const n = this.attributes.normal;
          if (void 0 !== n) {
            const t = new Y().getNormalMatrix(e);
            n.applyNormalMatrix(t), (n.needsUpdate = !0);
          }
          const i = this.attributes.tangent;
          return (
            void 0 !== i && (i.transformDirection(e), (i.needsUpdate = !0)),
            null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this
          );
        }
        applyQuaternion(e) {
          return Ht.makeRotationFromQuaternion(e), this.applyMatrix4(Ht), this;
        }
        rotateX(e) {
          return Ht.makeRotationX(e), this.applyMatrix4(Ht), this;
        }
        rotateY(e) {
          return Ht.makeRotationY(e), this.applyMatrix4(Ht), this;
        }
        rotateZ(e) {
          return Ht.makeRotationZ(e), this.applyMatrix4(Ht), this;
        }
        translate(e, t, n) {
          return Ht.makeTranslation(e, t, n), this.applyMatrix4(Ht), this;
        }
        scale(e, t, n) {
          return Ht.makeScale(e, t, n), this.applyMatrix4(Ht), this;
        }
        lookAt(e) {
          return (
            Wt.lookAt(e), Wt.updateMatrix(), this.applyMatrix4(Wt.matrix), this
          );
        }
        center() {
          return (
            this.computeBoundingBox(),
            this.boundingBox.getCenter(jt).negate(),
            this.translate(jt.x, jt.y, jt.z),
            this
          );
        }
        setFromPoints(e) {
          const t = [];
          for (let n = 0, i = e.length; n < i; n++) {
            const i = e[n];
            t.push(i.x, i.y, i.z || 0);
          }
          return this.setAttribute("position", new Vt(t, 3)), this;
        }
        computeBoundingBox() {
          null === this.boundingBox && (this.boundingBox = new we());
          const e = this.attributes.position,
            t = this.morphAttributes.position;
          if (e && e.isGLBufferAttribute)
            return (
              console.error(
                'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
                this
              ),
              void this.boundingBox.set(
                new xe(-1 / 0, -1 / 0, -1 / 0),
                new xe(1 / 0, 1 / 0, 1 / 0)
              )
            );
          if (void 0 !== e) {
            if ((this.boundingBox.setFromBufferAttribute(e), t))
              for (let e = 0, n = t.length; e < n; e++) {
                const n = t[e];
                qt.setFromBufferAttribute(n),
                  this.morphTargetsRelative
                    ? (Yt.addVectors(this.boundingBox.min, qt.min),
                      this.boundingBox.expandByPoint(Yt),
                      Yt.addVectors(this.boundingBox.max, qt.max),
                      this.boundingBox.expandByPoint(Yt))
                    : (this.boundingBox.expandByPoint(qt.min),
                      this.boundingBox.expandByPoint(qt.max));
              }
          } else this.boundingBox.makeEmpty();
          (isNaN(this.boundingBox.min.x) ||
            isNaN(this.boundingBox.min.y) ||
            isNaN(this.boundingBox.min.z)) &&
            console.error(
              'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
              this
            );
        }
        computeBoundingSphere() {
          null === this.boundingSphere && (this.boundingSphere = new Ve());
          const e = this.attributes.position,
            t = this.morphAttributes.position;
          if (e && e.isGLBufferAttribute)
            return (
              console.error(
                'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
                this
              ),
              void this.boundingSphere.set(new xe(), 1 / 0)
            );
          if (e) {
            const n = this.boundingSphere.center;
            if ((qt.setFromBufferAttribute(e), t))
              for (let e = 0, n = t.length; e < n; e++) {
                const n = t[e];
                Xt.setFromBufferAttribute(n),
                  this.morphTargetsRelative
                    ? (Yt.addVectors(qt.min, Xt.min),
                      qt.expandByPoint(Yt),
                      Yt.addVectors(qt.max, Xt.max),
                      qt.expandByPoint(Yt))
                    : (qt.expandByPoint(Xt.min), qt.expandByPoint(Xt.max));
              }
            qt.getCenter(n);
            let i = 0;
            for (let t = 0, r = e.count; t < r; t++)
              Yt.fromBufferAttribute(e, t),
                (i = Math.max(i, n.distanceToSquared(Yt)));
            if (t)
              for (let r = 0, s = t.length; r < s; r++) {
                const s = t[r],
                  a = this.morphTargetsRelative;
                for (let t = 0, r = s.count; t < r; t++)
                  Yt.fromBufferAttribute(s, t),
                    a && (jt.fromBufferAttribute(e, t), Yt.add(jt)),
                    (i = Math.max(i, n.distanceToSquared(Yt)));
              }
            (this.boundingSphere.radius = Math.sqrt(i)),
              isNaN(this.boundingSphere.radius) &&
                console.error(
                  'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                  this
                );
          }
        }
        computeTangents() {
          const e = this.index,
            t = this.attributes;
          if (
            null === e ||
            void 0 === t.position ||
            void 0 === t.normal ||
            void 0 === t.uv
          )
            return void console.error(
              "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
            );
          const n = e.array,
            i = t.position.array,
            r = t.normal.array,
            s = t.uv.array,
            a = i.length / 3;
          !1 === this.hasAttribute("tangent") &&
            this.setAttribute("tangent", new zt(new Float32Array(4 * a), 4));
          const o = this.getAttribute("tangent").array,
            l = [],
            c = [];
          for (let e = 0; e < a; e++) (l[e] = new xe()), (c[e] = new xe());
          const u = new xe(),
            h = new xe(),
            d = new xe(),
            p = new X(),
            f = new X(),
            m = new X(),
            g = new xe(),
            v = new xe();
          function _(e, t, n) {
            u.fromArray(i, 3 * e),
              h.fromArray(i, 3 * t),
              d.fromArray(i, 3 * n),
              p.fromArray(s, 2 * e),
              f.fromArray(s, 2 * t),
              m.fromArray(s, 2 * n),
              h.sub(u),
              d.sub(u),
              f.sub(p),
              m.sub(p);
            const r = 1 / (f.x * m.y - m.x * f.y);
            isFinite(r) &&
              (g
                .copy(h)
                .multiplyScalar(m.y)
                .addScaledVector(d, -f.y)
                .multiplyScalar(r),
              v
                .copy(d)
                .multiplyScalar(f.x)
                .addScaledVector(h, -m.x)
                .multiplyScalar(r),
              l[e].add(g),
              l[t].add(g),
              l[n].add(g),
              c[e].add(v),
              c[t].add(v),
              c[n].add(v));
          }
          let x = this.groups;
          0 === x.length && (x = [{ start: 0, count: n.length }]);
          for (let e = 0, t = x.length; e < t; ++e) {
            const t = x[e],
              i = t.start;
            for (let e = i, r = i + t.count; e < r; e += 3)
              _(n[e + 0], n[e + 1], n[e + 2]);
          }
          const y = new xe(),
            b = new xe(),
            w = new xe(),
            S = new xe();
          function M(e) {
            w.fromArray(r, 3 * e), S.copy(w);
            const t = l[e];
            y.copy(t),
              y.sub(w.multiplyScalar(w.dot(t))).normalize(),
              b.crossVectors(S, t);
            const n = b.dot(c[e]) < 0 ? -1 : 1;
            (o[4 * e] = y.x),
              (o[4 * e + 1] = y.y),
              (o[4 * e + 2] = y.z),
              (o[4 * e + 3] = n);
          }
          for (let e = 0, t = x.length; e < t; ++e) {
            const t = x[e],
              i = t.start;
            for (let e = i, r = i + t.count; e < r; e += 3)
              M(n[e + 0]), M(n[e + 1]), M(n[e + 2]);
          }
        }
        computeVertexNormals() {
          const e = this.index,
            t = this.getAttribute("position");
          if (void 0 !== t) {
            let n = this.getAttribute("normal");
            if (void 0 === n)
              (n = new zt(new Float32Array(3 * t.count), 3)),
                this.setAttribute("normal", n);
            else for (let e = 0, t = n.count; e < t; e++) n.setXYZ(e, 0, 0, 0);
            const i = new xe(),
              r = new xe(),
              s = new xe(),
              a = new xe(),
              o = new xe(),
              l = new xe(),
              c = new xe(),
              u = new xe();
            if (e)
              for (let h = 0, d = e.count; h < d; h += 3) {
                const d = e.getX(h + 0),
                  p = e.getX(h + 1),
                  f = e.getX(h + 2);
                i.fromBufferAttribute(t, d),
                  r.fromBufferAttribute(t, p),
                  s.fromBufferAttribute(t, f),
                  c.subVectors(s, r),
                  u.subVectors(i, r),
                  c.cross(u),
                  a.fromBufferAttribute(n, d),
                  o.fromBufferAttribute(n, p),
                  l.fromBufferAttribute(n, f),
                  a.add(c),
                  o.add(c),
                  l.add(c),
                  n.setXYZ(d, a.x, a.y, a.z),
                  n.setXYZ(p, o.x, o.y, o.z),
                  n.setXYZ(f, l.x, l.y, l.z);
              }
            else
              for (let e = 0, a = t.count; e < a; e += 3)
                i.fromBufferAttribute(t, e + 0),
                  r.fromBufferAttribute(t, e + 1),
                  s.fromBufferAttribute(t, e + 2),
                  c.subVectors(s, r),
                  u.subVectors(i, r),
                  c.cross(u),
                  n.setXYZ(e + 0, c.x, c.y, c.z),
                  n.setXYZ(e + 1, c.x, c.y, c.z),
                  n.setXYZ(e + 2, c.x, c.y, c.z);
            this.normalizeNormals(), (n.needsUpdate = !0);
          }
        }
        merge(e, t) {
          if (!e || !e.isBufferGeometry)
            return void console.error(
              "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
              e
            );
          void 0 === t &&
            ((t = 0),
            console.warn(
              "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
            ));
          const n = this.attributes;
          for (const i in n) {
            if (void 0 === e.attributes[i]) continue;
            const r = n[i].array,
              s = e.attributes[i],
              a = s.array,
              o = s.itemSize * t,
              l = Math.min(a.length, r.length - o);
            for (let e = 0, t = o; e < l; e++, t++) r[t] = a[e];
          }
          return this;
        }
        normalizeNormals() {
          const e = this.attributes.normal;
          for (let t = 0, n = e.count; t < n; t++)
            Yt.fromBufferAttribute(e, t),
              Yt.normalize(),
              e.setXYZ(t, Yt.x, Yt.y, Yt.z);
        }
        toNonIndexed() {
          function e(e, t) {
            const n = e.array,
              i = e.itemSize,
              r = e.normalized,
              s = new n.constructor(t.length * i);
            let a = 0,
              o = 0;
            for (let r = 0, l = t.length; r < l; r++) {
              a = e.isInterleavedBufferAttribute
                ? t[r] * e.data.stride + e.offset
                : t[r] * i;
              for (let e = 0; e < i; e++) s[o++] = n[a++];
            }
            return new zt(s, i, r);
          }
          if (null === this.index)
            return (
              console.warn(
                "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
              ),
              this
            );
          const t = new Zt(),
            n = this.index.array,
            i = this.attributes;
          for (const r in i) {
            const s = e(i[r], n);
            t.setAttribute(r, s);
          }
          const r = this.morphAttributes;
          for (const i in r) {
            const s = [],
              a = r[i];
            for (let t = 0, i = a.length; t < i; t++) {
              const i = e(a[t], n);
              s.push(i);
            }
            t.morphAttributes[i] = s;
          }
          t.morphTargetsRelative = this.morphTargetsRelative;
          const s = this.groups;
          for (let e = 0, n = s.length; e < n; e++) {
            const n = s[e];
            t.addGroup(n.start, n.count, n.materialIndex);
          }
          return t;
        }
        toJSON() {
          const e = {
            metadata: {
              version: 4.5,
              type: "BufferGeometry",
              generator: "BufferGeometry.toJSON",
            },
          };
          if (
            ((e.uuid = this.uuid),
            (e.type = this.type),
            "" !== this.name && (e.name = this.name),
            Object.keys(this.userData).length > 0 &&
              (e.userData = this.userData),
            void 0 !== this.parameters)
          ) {
            const t = this.parameters;
            for (const n in t) void 0 !== t[n] && (e[n] = t[n]);
            return e;
          }
          e.data = { attributes: {} };
          const t = this.index;
          null !== t &&
            (e.data.index = {
              type: t.array.constructor.name,
              array: Array.prototype.slice.call(t.array),
            });
          const n = this.attributes;
          for (const t in n) {
            const i = n[t];
            e.data.attributes[t] = i.toJSON(e.data);
          }
          const i = {};
          let r = !1;
          for (const t in this.morphAttributes) {
            const n = this.morphAttributes[t],
              s = [];
            for (let t = 0, i = n.length; t < i; t++) {
              const i = n[t];
              s.push(i.toJSON(e.data));
            }
            s.length > 0 && ((i[t] = s), (r = !0));
          }
          r &&
            ((e.data.morphAttributes = i),
            (e.data.morphTargetsRelative = this.morphTargetsRelative));
          const s = this.groups;
          s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s)));
          const a = this.boundingSphere;
          return (
            null !== a &&
              (e.data.boundingSphere = {
                center: a.center.toArray(),
                radius: a.radius,
              }),
            e
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null);
          const t = {};
          this.name = e.name;
          const n = e.index;
          null !== n && this.setIndex(n.clone(t));
          const i = e.attributes;
          for (const e in i) {
            const n = i[e];
            this.setAttribute(e, n.clone(t));
          }
          const r = e.morphAttributes;
          for (const e in r) {
            const n = [],
              i = r[e];
            for (let e = 0, r = i.length; e < r; e++) n.push(i[e].clone(t));
            this.morphAttributes[e] = n;
          }
          this.morphTargetsRelative = e.morphTargetsRelative;
          const s = e.groups;
          for (let e = 0, t = s.length; e < t; e++) {
            const t = s[e];
            this.addGroup(t.start, t.count, t.materialIndex);
          }
          const a = e.boundingBox;
          null !== a && (this.boundingBox = a.clone());
          const o = e.boundingSphere;
          return (
            null !== o && (this.boundingSphere = o.clone()),
            (this.drawRange.start = e.drawRange.start),
            (this.drawRange.count = e.drawRange.count),
            (this.userData = e.userData),
            void 0 !== e.parameters &&
              (this.parameters = Object.assign({}, e.parameters)),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      const $t = new $e(),
        Kt = new Ze(),
        Jt = new Ve(),
        Qt = new xe(),
        en = new xe(),
        tn = new xe(),
        nn = new xe(),
        rn = new xe(),
        sn = new xe(),
        an = new xe(),
        on = new xe(),
        ln = new xe(),
        cn = new X(),
        un = new X(),
        hn = new X(),
        dn = new xe(),
        pn = new xe();
      class fn extends bt {
        constructor(e = new Zt(), t = new Ft()) {
          super(),
            (this.isMesh = !0),
            (this.type = "Mesh"),
            (this.geometry = e),
            (this.material = t),
            this.updateMorphTargets();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            void 0 !== e.morphTargetInfluences &&
              (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
            void 0 !== e.morphTargetDictionary &&
              (this.morphTargetDictionary = Object.assign(
                {},
                e.morphTargetDictionary
              )),
            (this.material = e.material),
            (this.geometry = e.geometry),
            this
          );
        }
        updateMorphTargets() {
          const e = this.geometry.morphAttributes,
            t = Object.keys(e);
          if (t.length > 0) {
            const n = e[t[0]];
            if (void 0 !== n) {
              (this.morphTargetInfluences = []),
                (this.morphTargetDictionary = {});
              for (let e = 0, t = n.length; e < t; e++) {
                const t = n[e].name || String(e);
                this.morphTargetInfluences.push(0),
                  (this.morphTargetDictionary[t] = e);
              }
            }
          }
        }
        raycast(e, t) {
          const n = this.geometry,
            i = this.material,
            r = this.matrixWorld;
          if (void 0 === i) return;
          if (
            (null === n.boundingSphere && n.computeBoundingSphere(),
            Jt.copy(n.boundingSphere),
            Jt.applyMatrix4(r),
            !1 === e.ray.intersectsSphere(Jt))
          )
            return;
          if (
            ($t.copy(r).invert(),
            Kt.copy(e.ray).applyMatrix4($t),
            null !== n.boundingBox && !1 === Kt.intersectsBox(n.boundingBox))
          )
            return;
          let s;
          const a = n.index,
            o = n.attributes.position,
            l = n.morphAttributes.position,
            c = n.morphTargetsRelative,
            u = n.attributes.uv,
            h = n.attributes.uv2,
            d = n.groups,
            p = n.drawRange;
          if (null !== a)
            if (Array.isArray(i))
              for (let n = 0, r = d.length; n < r; n++) {
                const r = d[n],
                  f = i[r.materialIndex];
                for (
                  let n = Math.max(r.start, p.start),
                    i = Math.min(
                      a.count,
                      Math.min(r.start + r.count, p.start + p.count)
                    );
                  n < i;
                  n += 3
                ) {
                  const i = a.getX(n),
                    d = a.getX(n + 1),
                    p = a.getX(n + 2);
                  (s = mn(this, f, e, Kt, o, l, c, u, h, i, d, p)),
                    s &&
                      ((s.faceIndex = Math.floor(n / 3)),
                      (s.face.materialIndex = r.materialIndex),
                      t.push(s));
                }
              }
            else
              for (
                let n = Math.max(0, p.start),
                  r = Math.min(a.count, p.start + p.count);
                n < r;
                n += 3
              ) {
                const r = a.getX(n),
                  d = a.getX(n + 1),
                  p = a.getX(n + 2);
                (s = mn(this, i, e, Kt, o, l, c, u, h, r, d, p)),
                  s && ((s.faceIndex = Math.floor(n / 3)), t.push(s));
              }
          else if (void 0 !== o)
            if (Array.isArray(i))
              for (let n = 0, r = d.length; n < r; n++) {
                const r = d[n],
                  a = i[r.materialIndex];
                for (
                  let n = Math.max(r.start, p.start),
                    i = Math.min(
                      o.count,
                      Math.min(r.start + r.count, p.start + p.count)
                    );
                  n < i;
                  n += 3
                )
                  (s = mn(this, a, e, Kt, o, l, c, u, h, n, n + 1, n + 2)),
                    s &&
                      ((s.faceIndex = Math.floor(n / 3)),
                      (s.face.materialIndex = r.materialIndex),
                      t.push(s));
              }
            else
              for (
                let n = Math.max(0, p.start),
                  r = Math.min(o.count, p.start + p.count);
                n < r;
                n += 3
              )
                (s = mn(this, i, e, Kt, o, l, c, u, h, n, n + 1, n + 2)),
                  s && ((s.faceIndex = Math.floor(n / 3)), t.push(s));
        }
      }
      function mn(e, t, n, i, r, s, a, o, l, c, u, h) {
        Qt.fromBufferAttribute(r, c),
          en.fromBufferAttribute(r, u),
          tn.fromBufferAttribute(r, h);
        const d = e.morphTargetInfluences;
        if (s && d) {
          an.set(0, 0, 0), on.set(0, 0, 0), ln.set(0, 0, 0);
          for (let e = 0, t = s.length; e < t; e++) {
            const t = d[e],
              n = s[e];
            0 !== t &&
              (nn.fromBufferAttribute(n, c),
              rn.fromBufferAttribute(n, u),
              sn.fromBufferAttribute(n, h),
              a
                ? (an.addScaledVector(nn, t),
                  on.addScaledVector(rn, t),
                  ln.addScaledVector(sn, t))
                : (an.addScaledVector(nn.sub(Qt), t),
                  on.addScaledVector(rn.sub(en), t),
                  ln.addScaledVector(sn.sub(tn), t)));
          }
          Qt.add(an), en.add(on), tn.add(ln);
        }
        e.isSkinnedMesh &&
          (e.boneTransform(c, Qt),
          e.boneTransform(u, en),
          e.boneTransform(h, tn));
        const p = (function (e, t, n, i, r, s, a, o) {
          let l;
          if (
            ((l =
              1 === t.side
                ? i.intersectTriangle(a, s, r, !0, o)
                : i.intersectTriangle(r, s, a, 2 !== t.side, o)),
            null === l)
          )
            return null;
          pn.copy(o), pn.applyMatrix4(e.matrixWorld);
          const c = n.ray.origin.distanceTo(pn);
          return c < n.near || c > n.far
            ? null
            : { distance: c, point: pn.clone(), object: e };
        })(e, t, n, i, Qt, en, tn, dn);
        if (p) {
          o &&
            (cn.fromBufferAttribute(o, c),
            un.fromBufferAttribute(o, u),
            hn.fromBufferAttribute(o, h),
            (p.uv = kt.getUV(dn, Qt, en, tn, cn, un, hn, new X()))),
            l &&
              (cn.fromBufferAttribute(l, c),
              un.fromBufferAttribute(l, u),
              hn.fromBufferAttribute(l, h),
              (p.uv2 = kt.getUV(dn, Qt, en, tn, cn, un, hn, new X())));
          const e = { a: c, b: u, c: h, normal: new xe(), materialIndex: 0 };
          kt.getNormal(Qt, en, tn, e.normal), (p.face = e);
        }
        return p;
      }
      class gn extends Zt {
        constructor(e = 1, t = 1, n = 1, i = 1, r = 1, s = 1) {
          super(),
            (this.type = "BoxGeometry"),
            (this.parameters = {
              width: e,
              height: t,
              depth: n,
              widthSegments: i,
              heightSegments: r,
              depthSegments: s,
            });
          const a = this;
          (i = Math.floor(i)), (r = Math.floor(r)), (s = Math.floor(s));
          const o = [],
            l = [],
            c = [],
            u = [];
          let h = 0,
            d = 0;
          function p(e, t, n, i, r, s, p, f, m, g, v) {
            const _ = s / m,
              x = p / g,
              y = s / 2,
              b = p / 2,
              w = f / 2,
              S = m + 1,
              M = g + 1;
            let E = 0,
              T = 0;
            const A = new xe();
            for (let s = 0; s < M; s++) {
              const a = s * x - b;
              for (let o = 0; o < S; o++) {
                const h = o * _ - y;
                (A[e] = h * i),
                  (A[t] = a * r),
                  (A[n] = w),
                  l.push(A.x, A.y, A.z),
                  (A[e] = 0),
                  (A[t] = 0),
                  (A[n] = f > 0 ? 1 : -1),
                  c.push(A.x, A.y, A.z),
                  u.push(o / m),
                  u.push(1 - s / g),
                  (E += 1);
              }
            }
            for (let e = 0; e < g; e++)
              for (let t = 0; t < m; t++) {
                const n = h + t + S * e,
                  i = h + t + S * (e + 1),
                  r = h + (t + 1) + S * (e + 1),
                  s = h + (t + 1) + S * e;
                o.push(n, i, s), o.push(i, r, s), (T += 6);
              }
            a.addGroup(d, T, v), (d += T), (h += E);
          }
          p("z", "y", "x", -1, -1, n, t, e, s, r, 0),
            p("z", "y", "x", 1, -1, n, t, -e, s, r, 1),
            p("x", "z", "y", 1, 1, e, n, t, i, s, 2),
            p("x", "z", "y", 1, -1, e, n, -t, i, s, 3),
            p("x", "y", "z", 1, -1, e, t, n, i, r, 4),
            p("x", "y", "z", -1, -1, e, t, -n, i, r, 5),
            this.setIndex(o),
            this.setAttribute("position", new Vt(l, 3)),
            this.setAttribute("normal", new Vt(c, 3)),
            this.setAttribute("uv", new Vt(u, 2));
        }
        static fromJSON(e) {
          return new gn(
            e.width,
            e.height,
            e.depth,
            e.widthSegments,
            e.heightSegments,
            e.depthSegments
          );
        }
      }
      function vn(e) {
        const t = {};
        for (const n in e) {
          t[n] = {};
          for (const i in e[n]) {
            const r = e[n][i];
            r &&
            (r.isColor ||
              r.isMatrix3 ||
              r.isMatrix4 ||
              r.isVector2 ||
              r.isVector3 ||
              r.isVector4 ||
              r.isTexture ||
              r.isQuaternion)
              ? (t[n][i] = r.clone())
              : Array.isArray(r)
              ? (t[n][i] = r.slice())
              : (t[n][i] = r);
          }
        }
        return t;
      }
      function _n(e) {
        const t = {};
        for (let n = 0; n < e.length; n++) {
          const i = vn(e[n]);
          for (const e in i) t[e] = i[e];
        }
        return t;
      }
      const xn = { clone: vn, merge: _n };
      class yn extends It {
        constructor(e) {
          super(),
            (this.isShaderMaterial = !0),
            (this.type = "ShaderMaterial"),
            (this.defines = {}),
            (this.uniforms = {}),
            (this.vertexShader =
              "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"),
            (this.fragmentShader =
              "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"),
            (this.linewidth = 1),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            (this.lights = !1),
            (this.clipping = !1),
            (this.extensions = {
              derivatives: !1,
              fragDepth: !1,
              drawBuffers: !1,
              shaderTextureLOD: !1,
            }),
            (this.defaultAttributeValues = {
              color: [1, 1, 1],
              uv: [0, 0],
              uv2: [0, 0],
            }),
            (this.index0AttributeName = void 0),
            (this.uniformsNeedUpdate = !1),
            (this.glslVersion = null),
            void 0 !== e &&
              (void 0 !== e.attributes &&
                console.error(
                  "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
                ),
              this.setValues(e));
        }
        copy(e) {
          return (
            super.copy(e),
            (this.fragmentShader = e.fragmentShader),
            (this.vertexShader = e.vertexShader),
            (this.uniforms = vn(e.uniforms)),
            (this.defines = Object.assign({}, e.defines)),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.fog = e.fog),
            (this.lights = e.lights),
            (this.clipping = e.clipping),
            (this.extensions = Object.assign({}, e.extensions)),
            (this.glslVersion = e.glslVersion),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          (t.glslVersion = this.glslVersion), (t.uniforms = {});
          for (const n in this.uniforms) {
            const i = this.uniforms[n].value;
            i && i.isTexture
              ? (t.uniforms[n] = { type: "t", value: i.toJSON(e).uuid })
              : i && i.isColor
              ? (t.uniforms[n] = { type: "c", value: i.getHex() })
              : i && i.isVector2
              ? (t.uniforms[n] = { type: "v2", value: i.toArray() })
              : i && i.isVector3
              ? (t.uniforms[n] = { type: "v3", value: i.toArray() })
              : i && i.isVector4
              ? (t.uniforms[n] = { type: "v4", value: i.toArray() })
              : i && i.isMatrix3
              ? (t.uniforms[n] = { type: "m3", value: i.toArray() })
              : i && i.isMatrix4
              ? (t.uniforms[n] = { type: "m4", value: i.toArray() })
              : (t.uniforms[n] = { value: i });
          }
          Object.keys(this.defines).length > 0 && (t.defines = this.defines),
            (t.vertexShader = this.vertexShader),
            (t.fragmentShader = this.fragmentShader);
          const n = {};
          for (const e in this.extensions)
            !0 === this.extensions[e] && (n[e] = !0);
          return Object.keys(n).length > 0 && (t.extensions = n), t;
        }
      }
      class bn extends bt {
        constructor() {
          super(),
            (this.isCamera = !0),
            (this.type = "Camera"),
            (this.matrixWorldInverse = new $e()),
            (this.projectionMatrix = new $e()),
            (this.projectionMatrixInverse = new $e());
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            this.matrixWorldInverse.copy(e.matrixWorldInverse),
            this.projectionMatrix.copy(e.projectionMatrix),
            this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
            this
          );
        }
        getWorldDirection(e) {
          this.updateWorldMatrix(!0, !1);
          const t = this.matrixWorld.elements;
          return e.set(-t[8], -t[9], -t[10]).normalize();
        }
        updateMatrixWorld(e) {
          super.updateMatrixWorld(e),
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(e, t) {
          super.updateWorldMatrix(e, t),
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class wn extends bn {
        constructor(e = 50, t = 1, n = 0.1, i = 2e3) {
          super(),
            (this.isPerspectiveCamera = !0),
            (this.type = "PerspectiveCamera"),
            (this.fov = e),
            (this.zoom = 1),
            (this.near = n),
            (this.far = i),
            (this.focus = 10),
            (this.aspect = t),
            (this.view = null),
            (this.filmGauge = 35),
            (this.filmOffset = 0),
            this.updateProjectionMatrix();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.fov = e.fov),
            (this.zoom = e.zoom),
            (this.near = e.near),
            (this.far = e.far),
            (this.focus = e.focus),
            (this.aspect = e.aspect),
            (this.view = null === e.view ? null : Object.assign({}, e.view)),
            (this.filmGauge = e.filmGauge),
            (this.filmOffset = e.filmOffset),
            this
          );
        }
        setFocalLength(e) {
          const t = (0.5 * this.getFilmHeight()) / e;
          (this.fov = 2 * V * Math.atan(t)), this.updateProjectionMatrix();
        }
        getFocalLength() {
          const e = Math.tan(0.5 * U * this.fov);
          return (0.5 * this.getFilmHeight()) / e;
        }
        getEffectiveFOV() {
          return 2 * V * Math.atan(Math.tan(0.5 * U * this.fov) / this.zoom);
        }
        getFilmWidth() {
          return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
          return this.filmGauge / Math.max(this.aspect, 1);
        }
        setViewOffset(e, t, n, i, r, s) {
          (this.aspect = e / t),
            null === this.view &&
              (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1,
              }),
            (this.view.enabled = !0),
            (this.view.fullWidth = e),
            (this.view.fullHeight = t),
            (this.view.offsetX = n),
            (this.view.offsetY = i),
            (this.view.width = r),
            (this.view.height = s),
            this.updateProjectionMatrix();
        }
        clearViewOffset() {
          null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const e = this.near;
          let t = (e * Math.tan(0.5 * U * this.fov)) / this.zoom,
            n = 2 * t,
            i = this.aspect * n,
            r = -0.5 * i;
          const s = this.view;
          if (null !== this.view && this.view.enabled) {
            const e = s.fullWidth,
              a = s.fullHeight;
            (r += (s.offsetX * i) / e),
              (t -= (s.offsetY * n) / a),
              (i *= s.width / e),
              (n *= s.height / a);
          }
          const a = this.filmOffset;
          0 !== a && (r += (e * a) / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(
              r,
              r + i,
              t,
              t - n,
              e,
              this.far
            ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.fov = this.fov),
            (t.object.zoom = this.zoom),
            (t.object.near = this.near),
            (t.object.far = this.far),
            (t.object.focus = this.focus),
            (t.object.aspect = this.aspect),
            null !== this.view &&
              (t.object.view = Object.assign({}, this.view)),
            (t.object.filmGauge = this.filmGauge),
            (t.object.filmOffset = this.filmOffset),
            t
          );
        }
      }
      const Sn = 90;
      class Mn extends bt {
        constructor(e, t, n) {
          if (
            (super(),
            (this.type = "CubeCamera"),
            !0 !== n.isWebGLCubeRenderTarget)
          )
            return void console.error(
              "THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."
            );
          this.renderTarget = n;
          const i = new wn(Sn, 1, e, t);
          (i.layers = this.layers),
            i.up.set(0, -1, 0),
            i.lookAt(new xe(1, 0, 0)),
            this.add(i);
          const r = new wn(Sn, 1, e, t);
          (r.layers = this.layers),
            r.up.set(0, -1, 0),
            r.lookAt(new xe(-1, 0, 0)),
            this.add(r);
          const s = new wn(Sn, 1, e, t);
          (s.layers = this.layers),
            s.up.set(0, 0, 1),
            s.lookAt(new xe(0, 1, 0)),
            this.add(s);
          const a = new wn(Sn, 1, e, t);
          (a.layers = this.layers),
            a.up.set(0, 0, -1),
            a.lookAt(new xe(0, -1, 0)),
            this.add(a);
          const o = new wn(Sn, 1, e, t);
          (o.layers = this.layers),
            o.up.set(0, -1, 0),
            o.lookAt(new xe(0, 0, 1)),
            this.add(o);
          const l = new wn(Sn, 1, e, t);
          (l.layers = this.layers),
            l.up.set(0, -1, 0),
            l.lookAt(new xe(0, 0, -1)),
            this.add(l);
        }
        update(e, t) {
          null === this.parent && this.updateMatrixWorld();
          const n = this.renderTarget,
            [i, r, s, a, o, l] = this.children,
            c = e.getRenderTarget(),
            u = e.toneMapping,
            h = e.xr.enabled;
          (e.toneMapping = 0), (e.xr.enabled = !1);
          const d = n.texture.generateMipmaps;
          (n.texture.generateMipmaps = !1),
            e.setRenderTarget(n, 0),
            e.render(t, i),
            e.setRenderTarget(n, 1),
            e.render(t, r),
            e.setRenderTarget(n, 2),
            e.render(t, s),
            e.setRenderTarget(n, 3),
            e.render(t, a),
            e.setRenderTarget(n, 4),
            e.render(t, o),
            (n.texture.generateMipmaps = d),
            e.setRenderTarget(n, 5),
            e.render(t, l),
            e.setRenderTarget(c),
            (e.toneMapping = u),
            (e.xr.enabled = h),
            (n.texture.needsPMREMUpdate = !0);
        }
      }
      class En extends pe {
        constructor(e, t, n, i, r, s, a, l, c, u) {
          super(
            (e = void 0 !== e ? e : []),
            (t = void 0 !== t ? t : o),
            n,
            i,
            r,
            s,
            a,
            l,
            c,
            u
          ),
            (this.isCubeTexture = !0),
            (this.flipY = !1);
        }
        get images() {
          return this.image;
        }
        set images(e) {
          this.image = e;
        }
      }
      class Tn extends me {
        constructor(e, t = {}) {
          super(e, e, t), (this.isWebGLCubeRenderTarget = !0);
          const n = { width: e, height: e, depth: 1 },
            i = [n, n, n, n, n, n];
          (this.texture = new En(
            i,
            t.mapping,
            t.wrapS,
            t.wrapT,
            t.magFilter,
            t.minFilter,
            t.format,
            t.type,
            t.anisotropy,
            t.encoding
          )),
            (this.texture.isRenderTargetTexture = !0),
            (this.texture.generateMipmaps =
              void 0 !== t.generateMipmaps && t.generateMipmaps),
            (this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : f);
        }
        fromEquirectangularTexture(e, t) {
          (this.texture.type = t.type),
            (this.texture.encoding = t.encoding),
            (this.texture.generateMipmaps = t.generateMipmaps),
            (this.texture.minFilter = t.minFilter),
            (this.texture.magFilter = t.magFilter);
          const n = { tEquirect: { value: null } },
            i =
              "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
            r =
              "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
            s = new gn(5, 5, 5),
            a = new yn({
              name: "CubemapFromEquirect",
              uniforms: vn(n),
              vertexShader: i,
              fragmentShader: r,
              side: 1,
              blending: 0,
            });
          a.uniforms.tEquirect.value = t;
          const o = new fn(s, a),
            l = t.minFilter;
          return (
            t.minFilter === m && (t.minFilter = f),
            new Mn(1, 10, this).update(e, o),
            (t.minFilter = l),
            o.geometry.dispose(),
            o.material.dispose(),
            this
          );
        }
        clear(e, t, n, i) {
          const r = e.getRenderTarget();
          for (let r = 0; r < 6; r++)
            e.setRenderTarget(this, r), e.clear(t, n, i);
          e.setRenderTarget(r);
        }
      }
      const An = new xe(),
        Cn = new xe(),
        Ln = new Y();
      class Pn {
        constructor(e = new xe(1, 0, 0), t = 0) {
          (this.isPlane = !0), (this.normal = e), (this.constant = t);
        }
        set(e, t) {
          return this.normal.copy(e), (this.constant = t), this;
        }
        setComponents(e, t, n, i) {
          return this.normal.set(e, t, n), (this.constant = i), this;
        }
        setFromNormalAndCoplanarPoint(e, t) {
          return (
            this.normal.copy(e), (this.constant = -t.dot(this.normal)), this
          );
        }
        setFromCoplanarPoints(e, t, n) {
          const i = An.subVectors(n, t).cross(Cn.subVectors(e, t)).normalize();
          return this.setFromNormalAndCoplanarPoint(i, e), this;
        }
        copy(e) {
          return this.normal.copy(e.normal), (this.constant = e.constant), this;
        }
        normalize() {
          const e = 1 / this.normal.length();
          return this.normal.multiplyScalar(e), (this.constant *= e), this;
        }
        negate() {
          return (this.constant *= -1), this.normal.negate(), this;
        }
        distanceToPoint(e) {
          return this.normal.dot(e) + this.constant;
        }
        distanceToSphere(e) {
          return this.distanceToPoint(e.center) - e.radius;
        }
        projectPoint(e, t) {
          return t
            .copy(this.normal)
            .multiplyScalar(-this.distanceToPoint(e))
            .add(e);
        }
        intersectLine(e, t) {
          const n = e.delta(An),
            i = this.normal.dot(n);
          if (0 === i)
            return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
          const r = -(e.start.dot(this.normal) + this.constant) / i;
          return r < 0 || r > 1
            ? null
            : t.copy(n).multiplyScalar(r).add(e.start);
        }
        intersectsLine(e) {
          const t = this.distanceToPoint(e.start),
            n = this.distanceToPoint(e.end);
          return (t < 0 && n > 0) || (n < 0 && t > 0);
        }
        intersectsBox(e) {
          return e.intersectsPlane(this);
        }
        intersectsSphere(e) {
          return e.intersectsPlane(this);
        }
        coplanarPoint(e) {
          return e.copy(this.normal).multiplyScalar(-this.constant);
        }
        applyMatrix4(e, t) {
          const n = t || Ln.getNormalMatrix(e),
            i = this.coplanarPoint(An).applyMatrix4(e),
            r = this.normal.applyMatrix3(n).normalize();
          return (this.constant = -i.dot(r)), this;
        }
        translate(e) {
          return (this.constant -= e.dot(this.normal)), this;
        }
        equals(e) {
          return e.normal.equals(this.normal) && e.constant === this.constant;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const Dn = new Ve(),
        kn = new xe();
      class Rn {
        constructor(
          e = new Pn(),
          t = new Pn(),
          n = new Pn(),
          i = new Pn(),
          r = new Pn(),
          s = new Pn()
        ) {
          this.planes = [e, t, n, i, r, s];
        }
        set(e, t, n, i, r, s) {
          const a = this.planes;
          return (
            a[0].copy(e),
            a[1].copy(t),
            a[2].copy(n),
            a[3].copy(i),
            a[4].copy(r),
            a[5].copy(s),
            this
          );
        }
        copy(e) {
          const t = this.planes;
          for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
          return this;
        }
        setFromProjectionMatrix(e) {
          const t = this.planes,
            n = e.elements,
            i = n[0],
            r = n[1],
            s = n[2],
            a = n[3],
            o = n[4],
            l = n[5],
            c = n[6],
            u = n[7],
            h = n[8],
            d = n[9],
            p = n[10],
            f = n[11],
            m = n[12],
            g = n[13],
            v = n[14],
            _ = n[15];
          return (
            t[0].setComponents(a - i, u - o, f - h, _ - m).normalize(),
            t[1].setComponents(a + i, u + o, f + h, _ + m).normalize(),
            t[2].setComponents(a + r, u + l, f + d, _ + g).normalize(),
            t[3].setComponents(a - r, u - l, f - d, _ - g).normalize(),
            t[4].setComponents(a - s, u - c, f - p, _ - v).normalize(),
            t[5].setComponents(a + s, u + c, f + p, _ + v).normalize(),
            this
          );
        }
        intersectsObject(e) {
          const t = e.geometry;
          return (
            null === t.boundingSphere && t.computeBoundingSphere(),
            Dn.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
            this.intersectsSphere(Dn)
          );
        }
        intersectsSprite(e) {
          return (
            Dn.center.set(0, 0, 0),
            (Dn.radius = 0.7071067811865476),
            Dn.applyMatrix4(e.matrixWorld),
            this.intersectsSphere(Dn)
          );
        }
        intersectsSphere(e) {
          const t = this.planes,
            n = e.center,
            i = -e.radius;
          for (let e = 0; e < 6; e++)
            if (t[e].distanceToPoint(n) < i) return !1;
          return !0;
        }
        intersectsBox(e) {
          const t = this.planes;
          for (let n = 0; n < 6; n++) {
            const i = t[n];
            if (
              ((kn.x = i.normal.x > 0 ? e.max.x : e.min.x),
              (kn.y = i.normal.y > 0 ? e.max.y : e.min.y),
              (kn.z = i.normal.z > 0 ? e.max.z : e.min.z),
              i.distanceToPoint(kn) < 0)
            )
              return !1;
          }
          return !0;
        }
        containsPoint(e) {
          const t = this.planes;
          for (let n = 0; n < 6; n++)
            if (t[n].distanceToPoint(e) < 0) return !1;
          return !0;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      function In() {
        let e = null,
          t = !1,
          n = null,
          i = null;
        function r(t, s) {
          n(t, s), (i = e.requestAnimationFrame(r));
        }
        return {
          start: function () {
            !0 !== t &&
              null !== n &&
              ((i = e.requestAnimationFrame(r)), (t = !0));
          },
          stop: function () {
            e.cancelAnimationFrame(i), (t = !1);
          },
          setAnimationLoop: function (e) {
            n = e;
          },
          setContext: function (t) {
            e = t;
          },
        };
      }
      function Fn(e, t) {
        const n = t.isWebGL2,
          i = new WeakMap();
        return {
          get: function (e) {
            return e.isInterleavedBufferAttribute && (e = e.data), i.get(e);
          },
          remove: function (t) {
            t.isInterleavedBufferAttribute && (t = t.data);
            const n = i.get(t);
            n && (e.deleteBuffer(n.buffer), i.delete(t));
          },
          update: function (t, r) {
            if (t.isGLBufferAttribute) {
              const e = i.get(t);
              return void (
                (!e || e.version < t.version) &&
                i.set(t, {
                  buffer: t.buffer,
                  type: t.type,
                  bytesPerElement: t.elementSize,
                  version: t.version,
                })
              );
            }
            t.isInterleavedBufferAttribute && (t = t.data);
            const s = i.get(t);
            void 0 === s
              ? i.set(
                  t,
                  (function (t, i) {
                    const r = t.array,
                      s = t.usage,
                      a = e.createBuffer();
                    let o;
                    if (
                      (e.bindBuffer(i, a),
                      e.bufferData(i, r, s),
                      t.onUploadCallback(),
                      r instanceof Float32Array)
                    )
                      o = 5126;
                    else if (r instanceof Uint16Array)
                      if (t.isFloat16BufferAttribute) {
                        if (!n)
                          throw new Error(
                            "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
                          );
                        o = 5131;
                      } else o = 5123;
                    else if (r instanceof Int16Array) o = 5122;
                    else if (r instanceof Uint32Array) o = 5125;
                    else if (r instanceof Int32Array) o = 5124;
                    else if (r instanceof Int8Array) o = 5120;
                    else if (r instanceof Uint8Array) o = 5121;
                    else {
                      if (!(r instanceof Uint8ClampedArray))
                        throw new Error(
                          "THREE.WebGLAttributes: Unsupported buffer data format: " +
                            r
                        );
                      o = 5121;
                    }
                    return {
                      buffer: a,
                      type: o,
                      bytesPerElement: r.BYTES_PER_ELEMENT,
                      version: t.version,
                    };
                  })(t, r)
                )
              : s.version < t.version &&
                ((function (t, i, r) {
                  const s = i.array,
                    a = i.updateRange;
                  e.bindBuffer(r, t),
                    -1 === a.count
                      ? e.bufferSubData(r, 0, s)
                      : (n
                          ? e.bufferSubData(
                              r,
                              a.offset * s.BYTES_PER_ELEMENT,
                              s,
                              a.offset,
                              a.count
                            )
                          : e.bufferSubData(
                              r,
                              a.offset * s.BYTES_PER_ELEMENT,
                              s.subarray(a.offset, a.offset + a.count)
                            ),
                        (a.count = -1));
                })(s.buffer, t, r),
                (s.version = t.version));
          },
        };
      }
      class On extends Zt {
        constructor(e = 1, t = 1, n = 1, i = 1) {
          super(),
            (this.type = "PlaneGeometry"),
            (this.parameters = {
              width: e,
              height: t,
              widthSegments: n,
              heightSegments: i,
            });
          const r = e / 2,
            s = t / 2,
            a = Math.floor(n),
            o = Math.floor(i),
            l = a + 1,
            c = o + 1,
            u = e / a,
            h = t / o,
            d = [],
            p = [],
            f = [],
            m = [];
          for (let e = 0; e < c; e++) {
            const t = e * h - s;
            for (let n = 0; n < l; n++) {
              const i = n * u - r;
              p.push(i, -t, 0),
                f.push(0, 0, 1),
                m.push(n / a),
                m.push(1 - e / o);
            }
          }
          for (let e = 0; e < o; e++)
            for (let t = 0; t < a; t++) {
              const n = t + l * e,
                i = t + l * (e + 1),
                r = t + 1 + l * (e + 1),
                s = t + 1 + l * e;
              d.push(n, i, s), d.push(i, r, s);
            }
          this.setIndex(d),
            this.setAttribute("position", new Vt(p, 3)),
            this.setAttribute("normal", new Vt(f, 3)),
            this.setAttribute("uv", new Vt(m, 2));
        }
        static fromJSON(e) {
          return new On(e.width, e.height, e.widthSegments, e.heightSegments);
        }
      }
      const Nn = {
          alphamap_fragment:
            "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
          alphamap_pars_fragment:
            "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
          alphatest_fragment:
            "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
          alphatest_pars_fragment:
            "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
          aomap_fragment:
            "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
          aomap_pars_fragment:
            "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
          begin_vertex: "vec3 transformed = vec3( position );",
          beginnormal_vertex:
            "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
          bsdfs:
            "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\nvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = mix(F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence);\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",
          iridescence_fragment:
            "#ifdef USE_IRIDESCENCE\nconst mat3 XYZ_TO_REC709 = mat3(\n    3.2404542, -0.9692660,  0.0556434,\n   -1.5371385,  1.8760108, -0.2040259,\n   -0.4985314,  0.0415560,  1.0572252\n);\nvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n   vec3 sqrtF0 = sqrt( fresnel0 );\n   return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n}\nvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n   return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n}\nfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n   return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n}\nvec3 evalSensitivity( float OPD, vec3 shift ) {\n   float phase = 2.0 * PI * OPD * 1.0e-9;\n   vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n   vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n   vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n   vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( -pow2( phase ) * var );\n   xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[0] ) * exp( -4.5282e+09 * pow2( phase ) );\n   xyz /= 1.0685e-7;\n   vec3 srgb = XYZ_TO_REC709 * xyz;\n   return srgb;\n}\nvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n   vec3 I;\n   float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n   float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n   float cosTheta2Sq = 1.0 - sinTheta2Sq;\n   if ( cosTheta2Sq < 0.0 ) {\n       return vec3( 1.0 );\n   }\n   float cosTheta2 = sqrt( cosTheta2Sq );\n   float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n   float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n   float R21 = R12;\n   float T121 = 1.0 - R12;\n   float phi12 = 0.0;\n   if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n   float phi21 = PI - phi12;\n   vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );   vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n   vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n   vec3 phi23 = vec3( 0.0 );\n   if ( baseIOR[0] < iridescenceIOR ) phi23[0] = PI;\n   if ( baseIOR[1] < iridescenceIOR ) phi23[1] = PI;\n   if ( baseIOR[2] < iridescenceIOR ) phi23[2] = PI;\n   float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n   vec3 phi = vec3( phi21 ) + phi23;\n   vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n   vec3 r123 = sqrt( R123 );\n   vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n   vec3 C0 = R12 + Rs;\n   I = C0;\n   vec3 Cm = Rs - T121;\n   for ( int m = 1; m <= 2; ++m ) {\n       Cm *= r123;\n       vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n       I += Cm * Sm;\n   }\n   return max( I, vec3( 0.0 ) );\n}\n#endif",
          bumpmap_pars_fragment:
            "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
          clipping_planes_fragment:
            "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
          clipping_planes_pars_fragment:
            "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
          clipping_planes_pars_vertex:
            "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
          clipping_planes_vertex:
            "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
          color_fragment:
            "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
          color_pars_fragment:
            "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
          color_pars_vertex:
            "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
          color_vertex:
            "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
          common:
            "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
          cube_uv_reflection_fragment:
            "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
          defaultnormal_vertex:
            "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
          displacementmap_pars_vertex:
            "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
          displacementmap_vertex:
            "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
          emissivemap_fragment:
            "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
          emissivemap_pars_fragment:
            "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
          encodings_fragment:
            "gl_FragColor = linearToOutputTexel( gl_FragColor );",
          encodings_pars_fragment:
            "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
          envmap_fragment:
            "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
          envmap_common_pars_fragment:
            "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
          envmap_pars_fragment:
            "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
          envmap_pars_vertex:
            "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
          envmap_physical_pars_fragment:
            "#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",
          envmap_vertex:
            "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
          fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
          fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
          fog_fragment:
            "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
          fog_pars_fragment:
            "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
          gradientmap_pars_fragment:
            "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
          lightmap_fragment:
            "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
          lightmap_pars_fragment:
            "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
          lights_lambert_vertex:
            "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
          lights_pars_begin:
            "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
          lights_toon_fragment:
            "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
          lights_toon_pars_fragment:
            "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
          lights_phong_fragment:
            "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
          lights_phong_pars_fragment:
            "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
          lights_physical_fragment:
            "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",
          lights_physical_pars_fragment:
            "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
          lights_fragment_begin:
            "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\nfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\nif ( material.iridescenceThickness == 0.0 ) {\n\tmaterial.iridescence = 0.0;\n} else {\n\tmaterial.iridescence = saturate( material.iridescence );\n}\nif ( material.iridescence > 0.0 ) {\n\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
          lights_fragment_maps:
            "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
          lights_fragment_end:
            "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
          logdepthbuf_fragment:
            "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
          logdepthbuf_pars_fragment:
            "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
          logdepthbuf_pars_vertex:
            "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
          logdepthbuf_vertex:
            "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
          map_fragment:
            "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
          map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
          map_particle_fragment:
            "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
          map_particle_pars_fragment:
            "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
          metalnessmap_fragment:
            "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
          metalnessmap_pars_fragment:
            "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
          morphcolor_vertex:
            "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
          morphnormal_vertex:
            "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
          morphtarget_pars_vertex:
            "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
          morphtarget_vertex:
            "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
          normal_fragment_begin:
            "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
          normal_fragment_maps:
            "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
          normal_pars_fragment:
            "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
          normal_pars_vertex:
            "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
          normal_vertex:
            "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
          normalmap_pars_fragment:
            "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
          clearcoat_normal_fragment_begin:
            "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
          clearcoat_normal_fragment_maps:
            "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
          clearcoat_pars_fragment:
            "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
          iridescence_pars_fragment:
            "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
          output_fragment:
            "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
          packing:
            "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
          premultiplied_alpha_fragment:
            "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
          project_vertex:
            "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
          dithering_fragment:
            "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
          dithering_pars_fragment:
            "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
          roughnessmap_fragment:
            "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
          roughnessmap_pars_fragment:
            "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
          shadowmap_pars_fragment:
            "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
          shadowmap_pars_vertex:
            "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
          shadowmap_vertex:
            "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
          shadowmask_pars_fragment:
            "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
          skinbase_vertex:
            "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
          skinning_pars_vertex:
            "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif",
          skinning_vertex:
            "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
          skinnormal_vertex:
            "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
          specularmap_fragment:
            "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
          specularmap_pars_fragment:
            "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
          tonemapping_fragment:
            "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
          tonemapping_pars_fragment:
            "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
          transmission_fragment:
            "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",
          transmission_pars_fragment:
            "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",
          uv_pars_fragment:
            "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
          uv_pars_vertex:
            "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
          uv_vertex:
            "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
          uv2_pars_fragment:
            "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
          uv2_pars_vertex:
            "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
          uv2_vertex:
            "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
          worldpos_vertex:
            "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
          background_vert:
            "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
          background_frag:
            "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
          cube_vert:
            "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
          cube_frag:
            "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
          depth_vert:
            "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
          depth_frag:
            "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
          distanceRGBA_vert:
            "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
          distanceRGBA_frag:
            "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
          equirect_vert:
            "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
          equirect_frag:
            "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
          linedashed_vert:
            "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
          linedashed_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
          meshbasic_vert:
            "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
          meshbasic_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshlambert_vert:
            "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          meshlambert_frag:
            "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshmatcap_vert:
            "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
          meshmatcap_frag:
            "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshnormal_vert:
            "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
          meshnormal_frag:
            "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
          meshphong_vert:
            "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          meshphong_frag:
            "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshphysical_vert:
            "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
          meshphysical_frag:
            "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshtoon_vert:
            "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          meshtoon_frag:
            "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          points_vert:
            "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
          points_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
          shadow_vert:
            "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          shadow_frag:
            "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
          sprite_vert:
            "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
          sprite_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        },
        zn = {
          common: {
            diffuse: { value: new oe(16777215) },
            opacity: { value: 1 },
            map: { value: null },
            uvTransform: { value: new Y() },
            uv2Transform: { value: new Y() },
            alphaMap: { value: null },
            alphaTest: { value: 0 },
          },
          specularmap: { specularMap: { value: null } },
          envmap: {
            envMap: { value: null },
            flipEnvMap: { value: -1 },
            reflectivity: { value: 1 },
            ior: { value: 1.5 },
            refractionRatio: { value: 0.98 },
          },
          aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
          lightmap: {
            lightMap: { value: null },
            lightMapIntensity: { value: 1 },
          },
          emissivemap: { emissiveMap: { value: null } },
          bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
          normalmap: {
            normalMap: { value: null },
            normalScale: { value: new X(1, 1) },
          },
          displacementmap: {
            displacementMap: { value: null },
            displacementScale: { value: 1 },
            displacementBias: { value: 0 },
          },
          roughnessmap: { roughnessMap: { value: null } },
          metalnessmap: { metalnessMap: { value: null } },
          gradientmap: { gradientMap: { value: null } },
          fog: {
            fogDensity: { value: 25e-5 },
            fogNear: { value: 1 },
            fogFar: { value: 2e3 },
            fogColor: { value: new oe(16777215) },
          },
          lights: {
            ambientLightColor: { value: [] },
            lightProbe: { value: [] },
            directionalLights: {
              value: [],
              properties: { direction: {}, color: {} },
            },
            directionalLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            directionalShadowMap: { value: [] },
            directionalShadowMatrix: { value: [] },
            spotLights: {
              value: [],
              properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {},
              },
            },
            spotLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            spotShadowMap: { value: [] },
            spotShadowMatrix: { value: [] },
            pointLights: {
              value: [],
              properties: { color: {}, position: {}, decay: {}, distance: {} },
            },
            pointLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {},
              },
            },
            pointShadowMap: { value: [] },
            pointShadowMatrix: { value: [] },
            hemisphereLights: {
              value: [],
              properties: { direction: {}, skyColor: {}, groundColor: {} },
            },
            rectAreaLights: {
              value: [],
              properties: { color: {}, position: {}, width: {}, height: {} },
            },
            ltc_1: { value: null },
            ltc_2: { value: null },
          },
          points: {
            diffuse: { value: new oe(16777215) },
            opacity: { value: 1 },
            size: { value: 1 },
            scale: { value: 1 },
            map: { value: null },
            alphaMap: { value: null },
            alphaTest: { value: 0 },
            uvTransform: { value: new Y() },
          },
          sprite: {
            diffuse: { value: new oe(16777215) },
            opacity: { value: 1 },
            center: { value: new X(0.5, 0.5) },
            rotation: { value: 0 },
            map: { value: null },
            alphaMap: { value: null },
            alphaTest: { value: 0 },
            uvTransform: { value: new Y() },
          },
        },
        Bn = {
          basic: {
            uniforms: _n([
              zn.common,
              zn.specularmap,
              zn.envmap,
              zn.aomap,
              zn.lightmap,
              zn.fog,
            ]),
            vertexShader: Nn.meshbasic_vert,
            fragmentShader: Nn.meshbasic_frag,
          },
          lambert: {
            uniforms: _n([
              zn.common,
              zn.specularmap,
              zn.envmap,
              zn.aomap,
              zn.lightmap,
              zn.emissivemap,
              zn.fog,
              zn.lights,
              { emissive: { value: new oe(0) } },
            ]),
            vertexShader: Nn.meshlambert_vert,
            fragmentShader: Nn.meshlambert_frag,
          },
          phong: {
            uniforms: _n([
              zn.common,
              zn.specularmap,
              zn.envmap,
              zn.aomap,
              zn.lightmap,
              zn.emissivemap,
              zn.bumpmap,
              zn.normalmap,
              zn.displacementmap,
              zn.fog,
              zn.lights,
              {
                emissive: { value: new oe(0) },
                specular: { value: new oe(1118481) },
                shininess: { value: 30 },
              },
            ]),
            vertexShader: Nn.meshphong_vert,
            fragmentShader: Nn.meshphong_frag,
          },
          standard: {
            uniforms: _n([
              zn.common,
              zn.envmap,
              zn.aomap,
              zn.lightmap,
              zn.emissivemap,
              zn.bumpmap,
              zn.normalmap,
              zn.displacementmap,
              zn.roughnessmap,
              zn.metalnessmap,
              zn.fog,
              zn.lights,
              {
                emissive: { value: new oe(0) },
                roughness: { value: 1 },
                metalness: { value: 0 },
                envMapIntensity: { value: 1 },
              },
            ]),
            vertexShader: Nn.meshphysical_vert,
            fragmentShader: Nn.meshphysical_frag,
          },
          toon: {
            uniforms: _n([
              zn.common,
              zn.aomap,
              zn.lightmap,
              zn.emissivemap,
              zn.bumpmap,
              zn.normalmap,
              zn.displacementmap,
              zn.gradientmap,
              zn.fog,
              zn.lights,
              { emissive: { value: new oe(0) } },
            ]),
            vertexShader: Nn.meshtoon_vert,
            fragmentShader: Nn.meshtoon_frag,
          },
          matcap: {
            uniforms: _n([
              zn.common,
              zn.bumpmap,
              zn.normalmap,
              zn.displacementmap,
              zn.fog,
              { matcap: { value: null } },
            ]),
            vertexShader: Nn.meshmatcap_vert,
            fragmentShader: Nn.meshmatcap_frag,
          },
          points: {
            uniforms: _n([zn.points, zn.fog]),
            vertexShader: Nn.points_vert,
            fragmentShader: Nn.points_frag,
          },
          dashed: {
            uniforms: _n([
              zn.common,
              zn.fog,
              {
                scale: { value: 1 },
                dashSize: { value: 1 },
                totalSize: { value: 2 },
              },
            ]),
            vertexShader: Nn.linedashed_vert,
            fragmentShader: Nn.linedashed_frag,
          },
          depth: {
            uniforms: _n([zn.common, zn.displacementmap]),
            vertexShader: Nn.depth_vert,
            fragmentShader: Nn.depth_frag,
          },
          normal: {
            uniforms: _n([
              zn.common,
              zn.bumpmap,
              zn.normalmap,
              zn.displacementmap,
              { opacity: { value: 1 } },
            ]),
            vertexShader: Nn.meshnormal_vert,
            fragmentShader: Nn.meshnormal_frag,
          },
          sprite: {
            uniforms: _n([zn.sprite, zn.fog]),
            vertexShader: Nn.sprite_vert,
            fragmentShader: Nn.sprite_frag,
          },
          background: {
            uniforms: { uvTransform: { value: new Y() }, t2D: { value: null } },
            vertexShader: Nn.background_vert,
            fragmentShader: Nn.background_frag,
          },
          cube: {
            uniforms: _n([zn.envmap, { opacity: { value: 1 } }]),
            vertexShader: Nn.cube_vert,
            fragmentShader: Nn.cube_frag,
          },
          equirect: {
            uniforms: { tEquirect: { value: null } },
            vertexShader: Nn.equirect_vert,
            fragmentShader: Nn.equirect_frag,
          },
          distanceRGBA: {
            uniforms: _n([
              zn.common,
              zn.displacementmap,
              {
                referencePosition: { value: new xe() },
                nearDistance: { value: 1 },
                farDistance: { value: 1e3 },
              },
            ]),
            vertexShader: Nn.distanceRGBA_vert,
            fragmentShader: Nn.distanceRGBA_frag,
          },
          shadow: {
            uniforms: _n([
              zn.lights,
              zn.fog,
              { color: { value: new oe(0) }, opacity: { value: 1 } },
            ]),
            vertexShader: Nn.shadow_vert,
            fragmentShader: Nn.shadow_frag,
          },
        };
      function Un(e, t, n, i, r, s) {
        const a = new oe(0);
        let o,
          l,
          u = !0 === r ? 0 : 1,
          h = null,
          d = 0,
          p = null;
        function f(e, t) {
          n.buffers.color.setClear(e.r, e.g, e.b, t, s);
        }
        return {
          getClearColor: function () {
            return a;
          },
          setClearColor: function (e, t = 1) {
            a.set(e), (u = t), f(a, u);
          },
          getClearAlpha: function () {
            return u;
          },
          setClearAlpha: function (e) {
            (u = e), f(a, u);
          },
          render: function (n, r) {
            let s = !1,
              m = !0 === r.isScene ? r.background : null;
            m && m.isTexture && (m = t.get(m));
            const g = e.xr,
              v = g.getSession && g.getSession();
            v && "additive" === v.environmentBlendMode && (m = null),
              null === m ? f(a, u) : m && m.isColor && (f(m, 1), (s = !0)),
              (e.autoClear || s) &&
                e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
              m && (m.isCubeTexture || m.mapping === c)
                ? (void 0 === l &&
                    ((l = new fn(
                      new gn(1, 1, 1),
                      new yn({
                        name: "BackgroundCubeMaterial",
                        uniforms: vn(Bn.cube.uniforms),
                        vertexShader: Bn.cube.vertexShader,
                        fragmentShader: Bn.cube.fragmentShader,
                        side: 1,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1,
                      })
                    )),
                    l.geometry.deleteAttribute("normal"),
                    l.geometry.deleteAttribute("uv"),
                    (l.onBeforeRender = function (e, t, n) {
                      this.matrixWorld.copyPosition(n.matrixWorld);
                    }),
                    Object.defineProperty(l.material, "envMap", {
                      get: function () {
                        return this.uniforms.envMap.value;
                      },
                    }),
                    i.update(l)),
                  (l.material.uniforms.envMap.value = m),
                  (l.material.uniforms.flipEnvMap.value =
                    m.isCubeTexture && !1 === m.isRenderTargetTexture ? -1 : 1),
                  (h === m && d === m.version && p === e.toneMapping) ||
                    ((l.material.needsUpdate = !0),
                    (h = m),
                    (d = m.version),
                    (p = e.toneMapping)),
                  l.layers.enableAll(),
                  n.unshift(l, l.geometry, l.material, 0, 0, null))
                : m &&
                  m.isTexture &&
                  (void 0 === o &&
                    ((o = new fn(
                      new On(2, 2),
                      new yn({
                        name: "BackgroundMaterial",
                        uniforms: vn(Bn.background.uniforms),
                        vertexShader: Bn.background.vertexShader,
                        fragmentShader: Bn.background.fragmentShader,
                        side: 0,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1,
                      })
                    )),
                    o.geometry.deleteAttribute("normal"),
                    Object.defineProperty(o.material, "map", {
                      get: function () {
                        return this.uniforms.t2D.value;
                      },
                    }),
                    i.update(o)),
                  (o.material.uniforms.t2D.value = m),
                  !0 === m.matrixAutoUpdate && m.updateMatrix(),
                  o.material.uniforms.uvTransform.value.copy(m.matrix),
                  (h === m && d === m.version && p === e.toneMapping) ||
                    ((o.material.needsUpdate = !0),
                    (h = m),
                    (d = m.version),
                    (p = e.toneMapping)),
                  o.layers.enableAll(),
                  n.unshift(o, o.geometry, o.material, 0, 0, null));
          },
        };
      }
      function Vn(e, t, n, i) {
        const r = e.getParameter(34921),
          s = i.isWebGL2 ? null : t.get("OES_vertex_array_object"),
          a = i.isWebGL2 || null !== s,
          o = {},
          l = p(null);
        let c = l,
          u = !1;
        function h(t) {
          return i.isWebGL2 ? e.bindVertexArray(t) : s.bindVertexArrayOES(t);
        }
        function d(t) {
          return i.isWebGL2
            ? e.deleteVertexArray(t)
            : s.deleteVertexArrayOES(t);
        }
        function p(e) {
          const t = [],
            n = [],
            i = [];
          for (let e = 0; e < r; e++) (t[e] = 0), (n[e] = 0), (i[e] = 0);
          return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: t,
            enabledAttributes: n,
            attributeDivisors: i,
            object: e,
            attributes: {},
            index: null,
          };
        }
        function f() {
          const e = c.newAttributes;
          for (let t = 0, n = e.length; t < n; t++) e[t] = 0;
        }
        function m(e) {
          g(e, 0);
        }
        function g(n, r) {
          const s = c.newAttributes,
            a = c.enabledAttributes,
            o = c.attributeDivisors;
          (s[n] = 1),
            0 === a[n] && (e.enableVertexAttribArray(n), (a[n] = 1)),
            o[n] !== r &&
              ((i.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[
                i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
              ](n, r),
              (o[n] = r));
        }
        function v() {
          const t = c.newAttributes,
            n = c.enabledAttributes;
          for (let i = 0, r = n.length; i < r; i++)
            n[i] !== t[i] && (e.disableVertexAttribArray(i), (n[i] = 0));
        }
        function _(t, n, r, s, a, o) {
          !0 !== i.isWebGL2 || (5124 !== r && 5125 !== r)
            ? e.vertexAttribPointer(t, n, r, s, a, o)
            : e.vertexAttribIPointer(t, n, r, a, o);
        }
        function x() {
          y(), (u = !0), c !== l && ((c = l), h(c.object));
        }
        function y() {
          (l.geometry = null), (l.program = null), (l.wireframe = !1);
        }
        return {
          setup: function (r, l, d, x, y) {
            let b = !1;
            if (a) {
              const t = (function (t, n, r) {
                const a = !0 === r.wireframe;
                let l = o[t.id];
                void 0 === l && ((l = {}), (o[t.id] = l));
                let c = l[n.id];
                void 0 === c && ((c = {}), (l[n.id] = c));
                let u = c[a];
                return (
                  void 0 === u &&
                    ((u = p(
                      i.isWebGL2
                        ? e.createVertexArray()
                        : s.createVertexArrayOES()
                    )),
                    (c[a] = u)),
                  u
                );
              })(x, d, l);
              c !== t && ((c = t), h(c.object)),
                (b = (function (e, t, n, i) {
                  const r = c.attributes,
                    s = t.attributes;
                  let a = 0;
                  const o = n.getAttributes();
                  for (const t in o)
                    if (o[t].location >= 0) {
                      const n = r[t];
                      let i = s[t];
                      if (
                        (void 0 === i &&
                          ("instanceMatrix" === t &&
                            e.instanceMatrix &&
                            (i = e.instanceMatrix),
                          "instanceColor" === t &&
                            e.instanceColor &&
                            (i = e.instanceColor)),
                        void 0 === n)
                      )
                        return !0;
                      if (n.attribute !== i) return !0;
                      if (i && n.data !== i.data) return !0;
                      a++;
                    }
                  return c.attributesNum !== a || c.index !== i;
                })(r, x, d, y)),
                b &&
                  (function (e, t, n, i) {
                    const r = {},
                      s = t.attributes;
                    let a = 0;
                    const o = n.getAttributes();
                    for (const t in o)
                      if (o[t].location >= 0) {
                        let n = s[t];
                        void 0 === n &&
                          ("instanceMatrix" === t &&
                            e.instanceMatrix &&
                            (n = e.instanceMatrix),
                          "instanceColor" === t &&
                            e.instanceColor &&
                            (n = e.instanceColor));
                        const i = {};
                        (i.attribute = n),
                          n && n.data && (i.data = n.data),
                          (r[t] = i),
                          a++;
                      }
                    (c.attributes = r), (c.attributesNum = a), (c.index = i);
                  })(r, x, d, y);
            } else {
              const e = !0 === l.wireframe;
              (c.geometry === x.id &&
                c.program === d.id &&
                c.wireframe === e) ||
                ((c.geometry = x.id),
                (c.program = d.id),
                (c.wireframe = e),
                (b = !0));
            }
            null !== y && n.update(y, 34963),
              (b || u) &&
                ((u = !1),
                (function (r, s, a, o) {
                  if (
                    !1 === i.isWebGL2 &&
                    (r.isInstancedMesh || o.isInstancedBufferGeometry) &&
                    null === t.get("ANGLE_instanced_arrays")
                  )
                    return;
                  f();
                  const l = o.attributes,
                    c = a.getAttributes(),
                    u = s.defaultAttributeValues;
                  for (const t in c) {
                    const i = c[t];
                    if (i.location >= 0) {
                      let s = l[t];
                      if (
                        (void 0 === s &&
                          ("instanceMatrix" === t &&
                            r.instanceMatrix &&
                            (s = r.instanceMatrix),
                          "instanceColor" === t &&
                            r.instanceColor &&
                            (s = r.instanceColor)),
                        void 0 !== s)
                      ) {
                        const t = s.normalized,
                          a = s.itemSize,
                          l = n.get(s);
                        if (void 0 === l) continue;
                        const c = l.buffer,
                          u = l.type,
                          h = l.bytesPerElement;
                        if (s.isInterleavedBufferAttribute) {
                          const n = s.data,
                            l = n.stride,
                            d = s.offset;
                          if (n.isInstancedInterleavedBuffer) {
                            for (let e = 0; e < i.locationSize; e++)
                              g(i.location + e, n.meshPerAttribute);
                            !0 !== r.isInstancedMesh &&
                              void 0 === o._maxInstanceCount &&
                              (o._maxInstanceCount =
                                n.meshPerAttribute * n.count);
                          } else
                            for (let e = 0; e < i.locationSize; e++)
                              m(i.location + e);
                          e.bindBuffer(34962, c);
                          for (let e = 0; e < i.locationSize; e++)
                            _(
                              i.location + e,
                              a / i.locationSize,
                              u,
                              t,
                              l * h,
                              (d + (a / i.locationSize) * e) * h
                            );
                        } else {
                          if (s.isInstancedBufferAttribute) {
                            for (let e = 0; e < i.locationSize; e++)
                              g(i.location + e, s.meshPerAttribute);
                            !0 !== r.isInstancedMesh &&
                              void 0 === o._maxInstanceCount &&
                              (o._maxInstanceCount =
                                s.meshPerAttribute * s.count);
                          } else
                            for (let e = 0; e < i.locationSize; e++)
                              m(i.location + e);
                          e.bindBuffer(34962, c);
                          for (let e = 0; e < i.locationSize; e++)
                            _(
                              i.location + e,
                              a / i.locationSize,
                              u,
                              t,
                              a * h,
                              (a / i.locationSize) * e * h
                            );
                        }
                      } else if (void 0 !== u) {
                        const n = u[t];
                        if (void 0 !== n)
                          switch (n.length) {
                            case 2:
                              e.vertexAttrib2fv(i.location, n);
                              break;
                            case 3:
                              e.vertexAttrib3fv(i.location, n);
                              break;
                            case 4:
                              e.vertexAttrib4fv(i.location, n);
                              break;
                            default:
                              e.vertexAttrib1fv(i.location, n);
                          }
                      }
                    }
                  }
                  v();
                })(r, l, d, x),
                null !== y && e.bindBuffer(34963, n.get(y).buffer));
          },
          reset: x,
          resetDefaultState: y,
          dispose: function () {
            x();
            for (const e in o) {
              const t = o[e];
              for (const e in t) {
                const n = t[e];
                for (const e in n) d(n[e].object), delete n[e];
                delete t[e];
              }
              delete o[e];
            }
          },
          releaseStatesOfGeometry: function (e) {
            if (void 0 === o[e.id]) return;
            const t = o[e.id];
            for (const e in t) {
              const n = t[e];
              for (const e in n) d(n[e].object), delete n[e];
              delete t[e];
            }
            delete o[e.id];
          },
          releaseStatesOfProgram: function (e) {
            for (const t in o) {
              const n = o[t];
              if (void 0 === n[e.id]) continue;
              const i = n[e.id];
              for (const e in i) d(i[e].object), delete i[e];
              delete n[e.id];
            }
          },
          initAttributes: f,
          enableAttribute: m,
          disableUnusedAttributes: v,
        };
      }
      function Gn(e, t, n, i) {
        const r = i.isWebGL2;
        let s;
        (this.setMode = function (e) {
          s = e;
        }),
          (this.render = function (t, i) {
            e.drawArrays(s, t, i), n.update(i, s, 1);
          }),
          (this.renderInstances = function (i, a, o) {
            if (0 === o) return;
            let l, c;
            if (r) (l = e), (c = "drawArraysInstanced");
            else if (
              ((l = t.get("ANGLE_instanced_arrays")),
              (c = "drawArraysInstancedANGLE"),
              null === l)
            )
              return void console.error(
                "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
              );
            l[c](s, i, a, o), n.update(a, s, o);
          });
      }
      function Hn(e, t, n) {
        let i;
        function r(t) {
          if ("highp" === t) {
            if (
              e.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
              e.getShaderPrecisionFormat(35632, 36338).precision > 0
            )
              return "highp";
            t = "mediump";
          }
          return "mediump" === t &&
            e.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
            e.getShaderPrecisionFormat(35632, 36337).precision > 0
            ? "mediump"
            : "lowp";
        }
        const s =
          ("undefined" != typeof WebGL2RenderingContext &&
            e instanceof WebGL2RenderingContext) ||
          ("undefined" != typeof WebGL2ComputeRenderingContext &&
            e instanceof WebGL2ComputeRenderingContext);
        let a = void 0 !== n.precision ? n.precision : "highp";
        const o = r(a);
        o !== a &&
          (console.warn(
            "THREE.WebGLRenderer:",
            a,
            "not supported, using",
            o,
            "instead."
          ),
          (a = o));
        const l = s || t.has("WEBGL_draw_buffers"),
          c = !0 === n.logarithmicDepthBuffer,
          u = e.getParameter(34930),
          h = e.getParameter(35660),
          d = e.getParameter(3379),
          p = e.getParameter(34076),
          f = e.getParameter(34921),
          m = e.getParameter(36347),
          g = e.getParameter(36348),
          v = e.getParameter(36349),
          _ = h > 0,
          x = s || t.has("OES_texture_float");
        return {
          isWebGL2: s,
          drawBuffers: l,
          getMaxAnisotropy: function () {
            if (void 0 !== i) return i;
            if (!0 === t.has("EXT_texture_filter_anisotropic")) {
              const n = t.get("EXT_texture_filter_anisotropic");
              i = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
            } else i = 0;
            return i;
          },
          getMaxPrecision: r,
          precision: a,
          logarithmicDepthBuffer: c,
          maxTextures: u,
          maxVertexTextures: h,
          maxTextureSize: d,
          maxCubemapSize: p,
          maxAttributes: f,
          maxVertexUniforms: m,
          maxVaryings: g,
          maxFragmentUniforms: v,
          vertexTextures: _,
          floatFragmentTextures: x,
          floatVertexTextures: _ && x,
          maxSamples: s ? e.getParameter(36183) : 0,
        };
      }
      function Wn(e) {
        const t = this;
        let n = null,
          i = 0,
          r = !1,
          s = !1;
        const a = new Pn(),
          o = new Y(),
          l = { value: null, needsUpdate: !1 };
        function c() {
          l.value !== n && ((l.value = n), (l.needsUpdate = i > 0)),
            (t.numPlanes = i),
            (t.numIntersection = 0);
        }
        function u(e, n, i, r) {
          const s = null !== e ? e.length : 0;
          let c = null;
          if (0 !== s) {
            if (((c = l.value), !0 !== r || null === c)) {
              const t = i + 4 * s,
                r = n.matrixWorldInverse;
              o.getNormalMatrix(r),
                (null === c || c.length < t) && (c = new Float32Array(t));
              for (let t = 0, n = i; t !== s; ++t, n += 4)
                a.copy(e[t]).applyMatrix4(r, o),
                  a.normal.toArray(c, n),
                  (c[n + 3] = a.constant);
            }
            (l.value = c), (l.needsUpdate = !0);
          }
          return (t.numPlanes = s), (t.numIntersection = 0), c;
        }
        (this.uniform = l),
          (this.numPlanes = 0),
          (this.numIntersection = 0),
          (this.init = function (e, t, s) {
            const a = 0 !== e.length || t || 0 !== i || r;
            return (r = t), (n = u(e, s, 0)), (i = e.length), a;
          }),
          (this.beginShadows = function () {
            (s = !0), u(null);
          }),
          (this.endShadows = function () {
            (s = !1), c();
          }),
          (this.setState = function (t, a, o) {
            const h = t.clippingPlanes,
              d = t.clipIntersection,
              p = t.clipShadows,
              f = e.get(t);
            if (!r || null === h || 0 === h.length || (s && !p))
              s ? u(null) : c();
            else {
              const e = s ? 0 : i,
                t = 4 * e;
              let r = f.clippingState || null;
              (l.value = r), (r = u(h, a, t, o));
              for (let e = 0; e !== t; ++e) r[e] = n[e];
              (f.clippingState = r),
                (this.numIntersection = d ? this.numPlanes : 0),
                (this.numPlanes += e);
            }
          });
      }
      function jn(e) {
        let t = new WeakMap();
        function n(e, t) {
          return 303 === t ? (e.mapping = o) : 304 === t && (e.mapping = l), e;
        }
        function i(e) {
          const n = e.target;
          n.removeEventListener("dispose", i);
          const r = t.get(n);
          void 0 !== r && (t.delete(n), r.dispose());
        }
        return {
          get: function (r) {
            if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
              const s = r.mapping;
              if (303 === s || 304 === s) {
                if (t.has(r)) return n(t.get(r).texture, r.mapping);
                {
                  const s = r.image;
                  if (s && s.height > 0) {
                    const a = new Tn(s.height / 2);
                    return (
                      a.fromEquirectangularTexture(e, r),
                      t.set(r, a),
                      r.addEventListener("dispose", i),
                      n(a.texture, r.mapping)
                    );
                  }
                  return null;
                }
              }
            }
            return r;
          },
          dispose: function () {
            t = new WeakMap();
          },
        };
      }
      Bn.physical = {
        uniforms: _n([
          Bn.standard.uniforms,
          {
            clearcoat: { value: 0 },
            clearcoatMap: { value: null },
            clearcoatRoughness: { value: 0 },
            clearcoatRoughnessMap: { value: null },
            clearcoatNormalScale: { value: new X(1, 1) },
            clearcoatNormalMap: { value: null },
            iridescence: { value: 0 },
            iridescenceMap: { value: null },
            iridescenceIOR: { value: 1.3 },
            iridescenceThicknessMinimum: { value: 100 },
            iridescenceThicknessMaximum: { value: 400 },
            iridescenceThicknessMap: { value: null },
            sheen: { value: 0 },
            sheenColor: { value: new oe(0) },
            sheenColorMap: { value: null },
            sheenRoughness: { value: 1 },
            sheenRoughnessMap: { value: null },
            transmission: { value: 0 },
            transmissionMap: { value: null },
            transmissionSamplerSize: { value: new X() },
            transmissionSamplerMap: { value: null },
            thickness: { value: 0 },
            thicknessMap: { value: null },
            attenuationDistance: { value: 0 },
            attenuationColor: { value: new oe(0) },
            specularIntensity: { value: 1 },
            specularIntensityMap: { value: null },
            specularColor: { value: new oe(1, 1, 1) },
            specularColorMap: { value: null },
          },
        ]),
        vertexShader: Nn.meshphysical_vert,
        fragmentShader: Nn.meshphysical_frag,
      };
      class qn extends bn {
        constructor(e = -1, t = 1, n = 1, i = -1, r = 0.1, s = 2e3) {
          super(),
            (this.isOrthographicCamera = !0),
            (this.type = "OrthographicCamera"),
            (this.zoom = 1),
            (this.view = null),
            (this.left = e),
            (this.right = t),
            (this.top = n),
            (this.bottom = i),
            (this.near = r),
            (this.far = s),
            this.updateProjectionMatrix();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.left = e.left),
            (this.right = e.right),
            (this.top = e.top),
            (this.bottom = e.bottom),
            (this.near = e.near),
            (this.far = e.far),
            (this.zoom = e.zoom),
            (this.view = null === e.view ? null : Object.assign({}, e.view)),
            this
          );
        }
        setViewOffset(e, t, n, i, r, s) {
          null === this.view &&
            (this.view = {
              enabled: !0,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1,
            }),
            (this.view.enabled = !0),
            (this.view.fullWidth = e),
            (this.view.fullHeight = t),
            (this.view.offsetX = n),
            (this.view.offsetY = i),
            (this.view.width = r),
            (this.view.height = s),
            this.updateProjectionMatrix();
        }
        clearViewOffset() {
          null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const e = (this.right - this.left) / (2 * this.zoom),
            t = (this.top - this.bottom) / (2 * this.zoom),
            n = (this.right + this.left) / 2,
            i = (this.top + this.bottom) / 2;
          let r = n - e,
            s = n + e,
            a = i + t,
            o = i - t;
          if (null !== this.view && this.view.enabled) {
            const e =
                (this.right - this.left) / this.view.fullWidth / this.zoom,
              t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            (r += e * this.view.offsetX),
              (s = r + e * this.view.width),
              (a -= t * this.view.offsetY),
              (o = a - t * this.view.height);
          }
          this.projectionMatrix.makeOrthographic(
            r,
            s,
            a,
            o,
            this.near,
            this.far
          ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.zoom = this.zoom),
            (t.object.left = this.left),
            (t.object.right = this.right),
            (t.object.top = this.top),
            (t.object.bottom = this.bottom),
            (t.object.near = this.near),
            (t.object.far = this.far),
            null !== this.view &&
              (t.object.view = Object.assign({}, this.view)),
            t
          );
        }
      }
      const Xn = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
        Yn = new qn(),
        Zn = new oe();
      let $n = null;
      const Kn = (1 + Math.sqrt(5)) / 2,
        Jn = 1 / Kn,
        Qn = [
          new xe(1, 1, 1),
          new xe(-1, 1, 1),
          new xe(1, 1, -1),
          new xe(-1, 1, -1),
          new xe(0, Kn, Jn),
          new xe(0, Kn, -Jn),
          new xe(Jn, 0, Kn),
          new xe(-Jn, 0, Kn),
          new xe(Kn, Jn, 0),
          new xe(-Kn, Jn, 0),
        ];
      class ei {
        constructor(e) {
          (this._renderer = e),
            (this._pingPongRenderTarget = null),
            (this._lodMax = 0),
            (this._cubeSize = 0),
            (this._lodPlanes = []),
            (this._sizeLods = []),
            (this._sigmas = []),
            (this._blurMaterial = null),
            (this._cubemapMaterial = null),
            (this._equirectMaterial = null),
            this._compileMaterial(this._blurMaterial);
        }
        fromScene(e, t = 0, n = 0.1, i = 100) {
          ($n = this._renderer.getRenderTarget()), this._setSize(256);
          const r = this._allocateTargets();
          return (
            (r.depthBuffer = !0),
            this._sceneToCubeUV(e, n, i, r),
            t > 0 && this._blur(r, 0, 0, t),
            this._applyPMREM(r),
            this._cleanup(r),
            r
          );
        }
        fromEquirectangular(e, t = null) {
          return this._fromTexture(e, t);
        }
        fromCubemap(e, t = null) {
          return this._fromTexture(e, t);
        }
        compileCubemapShader() {
          null === this._cubemapMaterial &&
            ((this._cubemapMaterial = ri()),
            this._compileMaterial(this._cubemapMaterial));
        }
        compileEquirectangularShader() {
          null === this._equirectMaterial &&
            ((this._equirectMaterial = ii()),
            this._compileMaterial(this._equirectMaterial));
        }
        dispose() {
          this._dispose(),
            null !== this._cubemapMaterial && this._cubemapMaterial.dispose(),
            null !== this._equirectMaterial && this._equirectMaterial.dispose();
        }
        _setSize(e) {
          (this._lodMax = Math.floor(Math.log2(e))),
            (this._cubeSize = Math.pow(2, this._lodMax));
        }
        _dispose() {
          null !== this._blurMaterial && this._blurMaterial.dispose(),
            null !== this._pingPongRenderTarget &&
              this._pingPongRenderTarget.dispose();
          for (let e = 0; e < this._lodPlanes.length; e++)
            this._lodPlanes[e].dispose();
        }
        _cleanup(e) {
          this._renderer.setRenderTarget($n),
            (e.scissorTest = !1),
            ni(e, 0, 0, e.width, e.height);
        }
        _fromTexture(e, t) {
          e.mapping === o || e.mapping === l
            ? this._setSize(
                0 === e.image.length
                  ? 16
                  : e.image[0].width || e.image[0].image.width
              )
            : this._setSize(e.image.width / 4),
            ($n = this._renderer.getRenderTarget());
          const n = t || this._allocateTargets();
          return (
            this._textureToCubeUV(e, n),
            this._applyPMREM(n),
            this._cleanup(n),
            n
          );
        }
        _allocateTargets() {
          const e = 3 * Math.max(this._cubeSize, 112),
            t = 4 * this._cubeSize,
            n = {
              magFilter: f,
              minFilter: f,
              generateMipmaps: !1,
              type: x,
              format: b,
              encoding: D,
              depthBuffer: !1,
            },
            i = ti(e, t, n);
          if (
            null === this._pingPongRenderTarget ||
            this._pingPongRenderTarget.width !== e
          ) {
            null !== this._pingPongRenderTarget && this._dispose(),
              (this._pingPongRenderTarget = ti(e, t, n));
            const { _lodMax: i } = this;
            ({
              sizeLods: this._sizeLods,
              lodPlanes: this._lodPlanes,
              sigmas: this._sigmas,
            } = (function (e) {
              const t = [],
                n = [],
                i = [];
              let r = e;
              const s = e - 4 + 1 + Xn.length;
              for (let a = 0; a < s; a++) {
                const s = Math.pow(2, r);
                n.push(s);
                let o = 1 / s;
                a > e - 4 ? (o = Xn[a - e + 4 - 1]) : 0 === a && (o = 0),
                  i.push(o);
                const l = 1 / (s - 2),
                  c = -l,
                  u = 1 + l,
                  h = [c, c, u, c, u, u, c, c, u, u, c, u],
                  d = 6,
                  p = 6,
                  f = 3,
                  m = 2,
                  g = 1,
                  v = new Float32Array(f * p * d),
                  _ = new Float32Array(m * p * d),
                  x = new Float32Array(g * p * d);
                for (let e = 0; e < d; e++) {
                  const t = ((e % 3) * 2) / 3 - 1,
                    n = e > 2 ? 0 : -1,
                    i = [
                      t,
                      n,
                      0,
                      t + 2 / 3,
                      n,
                      0,
                      t + 2 / 3,
                      n + 1,
                      0,
                      t,
                      n,
                      0,
                      t + 2 / 3,
                      n + 1,
                      0,
                      t,
                      n + 1,
                      0,
                    ];
                  v.set(i, f * p * e), _.set(h, m * p * e);
                  const r = [e, e, e, e, e, e];
                  x.set(r, g * p * e);
                }
                const y = new Zt();
                y.setAttribute("position", new zt(v, f)),
                  y.setAttribute("uv", new zt(_, m)),
                  y.setAttribute("faceIndex", new zt(x, g)),
                  t.push(y),
                  r > 4 && r--;
              }
              return { lodPlanes: t, sizeLods: n, sigmas: i };
            })(i)),
              (this._blurMaterial = (function (e, t, n) {
                const i = new Float32Array(20),
                  r = new xe(0, 1, 0);
                return new yn({
                  name: "SphericalGaussianBlur",
                  defines: {
                    n: 20,
                    CUBEUV_TEXEL_WIDTH: 1 / t,
                    CUBEUV_TEXEL_HEIGHT: 1 / n,
                    CUBEUV_MAX_MIP: `${e}.0`,
                  },
                  uniforms: {
                    envMap: { value: null },
                    samples: { value: 1 },
                    weights: { value: i },
                    latitudinal: { value: !1 },
                    dTheta: { value: 0 },
                    mipInt: { value: 0 },
                    poleAxis: { value: r },
                  },
                  vertexShader:
                    "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                  fragmentShader:
                    "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                  blending: 0,
                  depthTest: !1,
                  depthWrite: !1,
                });
              })(i, e, t));
          }
          return i;
        }
        _compileMaterial(e) {
          const t = new fn(this._lodPlanes[0], e);
          this._renderer.compile(t, Yn);
        }
        _sceneToCubeUV(e, t, n, i) {
          const r = new wn(90, 1, t, n),
            s = [1, -1, 1, 1, 1, 1],
            a = [1, 1, 1, -1, -1, -1],
            o = this._renderer,
            l = o.autoClear,
            c = o.toneMapping;
          o.getClearColor(Zn), (o.toneMapping = 0), (o.autoClear = !1);
          const u = new Ft({
              name: "PMREM.Background",
              side: 1,
              depthWrite: !1,
              depthTest: !1,
            }),
            h = new fn(new gn(), u);
          let d = !1;
          const p = e.background;
          p
            ? p.isColor && (u.color.copy(p), (e.background = null), (d = !0))
            : (u.color.copy(Zn), (d = !0));
          for (let t = 0; t < 6; t++) {
            const n = t % 3;
            0 === n
              ? (r.up.set(0, s[t], 0), r.lookAt(a[t], 0, 0))
              : 1 === n
              ? (r.up.set(0, 0, s[t]), r.lookAt(0, a[t], 0))
              : (r.up.set(0, s[t], 0), r.lookAt(0, 0, a[t]));
            const l = this._cubeSize;
            ni(i, n * l, t > 2 ? l : 0, l, l),
              o.setRenderTarget(i),
              d && o.render(h, r),
              o.render(e, r);
          }
          h.geometry.dispose(),
            h.material.dispose(),
            (o.toneMapping = c),
            (o.autoClear = l),
            (e.background = p);
        }
        _textureToCubeUV(e, t) {
          const n = this._renderer,
            i = e.mapping === o || e.mapping === l;
          i
            ? (null === this._cubemapMaterial && (this._cubemapMaterial = ri()),
              (this._cubemapMaterial.uniforms.flipEnvMap.value =
                !1 === e.isRenderTargetTexture ? -1 : 1))
            : null === this._equirectMaterial &&
              (this._equirectMaterial = ii());
          const r = i ? this._cubemapMaterial : this._equirectMaterial,
            s = new fn(this._lodPlanes[0], r);
          r.uniforms.envMap.value = e;
          const a = this._cubeSize;
          ni(t, 0, 0, 3 * a, 2 * a), n.setRenderTarget(t), n.render(s, Yn);
        }
        _applyPMREM(e) {
          const t = this._renderer,
            n = t.autoClear;
          t.autoClear = !1;
          for (let t = 1; t < this._lodPlanes.length; t++) {
            const n = Math.sqrt(
                this._sigmas[t] * this._sigmas[t] -
                  this._sigmas[t - 1] * this._sigmas[t - 1]
              ),
              i = Qn[(t - 1) % Qn.length];
            this._blur(e, t - 1, t, n, i);
          }
          t.autoClear = n;
        }
        _blur(e, t, n, i, r) {
          const s = this._pingPongRenderTarget;
          this._halfBlur(e, s, t, n, i, "latitudinal", r),
            this._halfBlur(s, e, n, n, i, "longitudinal", r);
        }
        _halfBlur(e, t, n, i, r, s, a) {
          const o = this._renderer,
            l = this._blurMaterial;
          "latitudinal" !== s &&
            "longitudinal" !== s &&
            console.error(
              "blur direction must be either latitudinal or longitudinal!"
            );
          const c = new fn(this._lodPlanes[i], l),
            u = l.uniforms,
            h = this._sizeLods[n] - 1,
            d = isFinite(r) ? Math.PI / (2 * h) : (2 * Math.PI) / 39,
            p = r / d,
            f = isFinite(r) ? 1 + Math.floor(3 * p) : 20;
          f > 20 &&
            console.warn(
              `sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`
            );
          const m = [];
          let g = 0;
          for (let e = 0; e < 20; ++e) {
            const t = e / p,
              n = Math.exp((-t * t) / 2);
            m.push(n), 0 === e ? (g += n) : e < f && (g += 2 * n);
          }
          for (let e = 0; e < m.length; e++) m[e] = m[e] / g;
          (u.envMap.value = e.texture),
            (u.samples.value = f),
            (u.weights.value = m),
            (u.latitudinal.value = "latitudinal" === s),
            a && (u.poleAxis.value = a);
          const { _lodMax: v } = this;
          (u.dTheta.value = d), (u.mipInt.value = v - n);
          const _ = this._sizeLods[i];
          ni(
            t,
            3 * _ * (i > v - 4 ? i - v + 4 : 0),
            4 * (this._cubeSize - _),
            3 * _,
            2 * _
          ),
            o.setRenderTarget(t),
            o.render(c, Yn);
        }
      }
      function ti(e, t, n) {
        const i = new me(e, t, n);
        return (
          (i.texture.mapping = c),
          (i.texture.name = "PMREM.cubeUv"),
          (i.scissorTest = !0),
          i
        );
      }
      function ni(e, t, n, i, r) {
        e.viewport.set(t, n, i, r), e.scissor.set(t, n, i, r);
      }
      function ii() {
        return new yn({
          name: "EquirectangularToCubeUV",
          uniforms: { envMap: { value: null } },
          vertexShader:
            "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
          fragmentShader:
            "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
          blending: 0,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function ri() {
        return new yn({
          name: "CubemapToCubeUV",
          uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
          vertexShader:
            "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
          fragmentShader:
            "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
          blending: 0,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function si(e) {
        let t = new WeakMap(),
          n = null;
        function i(e) {
          const n = e.target;
          n.removeEventListener("dispose", i);
          const r = t.get(n);
          void 0 !== r && (t.delete(n), r.dispose());
        }
        return {
          get: function (r) {
            if (r && r.isTexture) {
              const s = r.mapping,
                a = 303 === s || 304 === s,
                c = s === o || s === l;
              if (a || c) {
                if (r.isRenderTargetTexture && !0 === r.needsPMREMUpdate) {
                  r.needsPMREMUpdate = !1;
                  let i = t.get(r);
                  return (
                    null === n && (n = new ei(e)),
                    (i = a ? n.fromEquirectangular(r, i) : n.fromCubemap(r, i)),
                    t.set(r, i),
                    i.texture
                  );
                }
                if (t.has(r)) return t.get(r).texture;
                {
                  const s = r.image;
                  if (
                    (a && s && s.height > 0) ||
                    (c &&
                      s &&
                      (function (e) {
                        let t = 0;
                        for (let n = 0; n < 6; n++) void 0 !== e[n] && t++;
                        return 6 === t;
                      })(s))
                  ) {
                    null === n && (n = new ei(e));
                    const s = a ? n.fromEquirectangular(r) : n.fromCubemap(r);
                    return (
                      t.set(r, s), r.addEventListener("dispose", i), s.texture
                    );
                  }
                  return null;
                }
              }
            }
            return r;
          },
          dispose: function () {
            (t = new WeakMap()), null !== n && (n.dispose(), (n = null));
          },
        };
      }
      function ai(e) {
        const t = {};
        function n(n) {
          if (void 0 !== t[n]) return t[n];
          let i;
          switch (n) {
            case "WEBGL_depth_texture":
              i =
                e.getExtension("WEBGL_depth_texture") ||
                e.getExtension("MOZ_WEBGL_depth_texture") ||
                e.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              i =
                e.getExtension("EXT_texture_filter_anisotropic") ||
                e.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              i =
                e.getExtension("WEBGL_compressed_texture_s3tc") ||
                e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              i =
                e.getExtension("WEBGL_compressed_texture_pvrtc") ||
                e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              i = e.getExtension(n);
          }
          return (t[n] = i), i;
        }
        return {
          has: function (e) {
            return null !== n(e);
          },
          init: function (e) {
            e.isWebGL2
              ? n("EXT_color_buffer_float")
              : (n("WEBGL_depth_texture"),
                n("OES_texture_float"),
                n("OES_texture_half_float"),
                n("OES_texture_half_float_linear"),
                n("OES_standard_derivatives"),
                n("OES_element_index_uint"),
                n("OES_vertex_array_object"),
                n("ANGLE_instanced_arrays")),
              n("OES_texture_float_linear"),
              n("EXT_color_buffer_half_float"),
              n("WEBGL_multisampled_render_to_texture");
          },
          get: function (e) {
            const t = n(e);
            return (
              null === t &&
                console.warn(
                  "THREE.WebGLRenderer: " + e + " extension not supported."
                ),
              t
            );
          },
        };
      }
      function oi(e, t, n, i) {
        const r = {},
          s = new WeakMap();
        function a(e) {
          const o = e.target;
          null !== o.index && t.remove(o.index);
          for (const e in o.attributes) t.remove(o.attributes[e]);
          o.removeEventListener("dispose", a), delete r[o.id];
          const l = s.get(o);
          l && (t.remove(l), s.delete(o)),
            i.releaseStatesOfGeometry(o),
            !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount,
            n.memory.geometries--;
        }
        function o(e) {
          const n = [],
            i = e.index,
            r = e.attributes.position;
          let a = 0;
          if (null !== i) {
            const e = i.array;
            a = i.version;
            for (let t = 0, i = e.length; t < i; t += 3) {
              const i = e[t + 0],
                r = e[t + 1],
                s = e[t + 2];
              n.push(i, r, r, s, s, i);
            }
          } else {
            const e = r.array;
            a = r.version;
            for (let t = 0, i = e.length / 3 - 1; t < i; t += 3) {
              const e = t + 0,
                i = t + 1,
                r = t + 2;
              n.push(e, i, i, r, r, e);
            }
          }
          const o = new (Z(n) ? Ut : Bt)(n, 1);
          o.version = a;
          const l = s.get(e);
          l && t.remove(l), s.set(e, o);
        }
        return {
          get: function (e, t) {
            return (
              !0 === r[t.id] ||
                (t.addEventListener("dispose", a),
                (r[t.id] = !0),
                n.memory.geometries++),
              t
            );
          },
          update: function (e) {
            const n = e.attributes;
            for (const e in n) t.update(n[e], 34962);
            const i = e.morphAttributes;
            for (const e in i) {
              const n = i[e];
              for (let e = 0, i = n.length; e < i; e++) t.update(n[e], 34962);
            }
          },
          getWireframeAttribute: function (e) {
            const t = s.get(e);
            if (t) {
              const n = e.index;
              null !== n && t.version < n.version && o(e);
            } else o(e);
            return s.get(e);
          },
        };
      }
      function li(e, t, n, i) {
        const r = i.isWebGL2;
        let s, a, o;
        (this.setMode = function (e) {
          s = e;
        }),
          (this.setIndex = function (e) {
            (a = e.type), (o = e.bytesPerElement);
          }),
          (this.render = function (t, i) {
            e.drawElements(s, i, a, t * o), n.update(i, s, 1);
          }),
          (this.renderInstances = function (i, l, c) {
            if (0 === c) return;
            let u, h;
            if (r) (u = e), (h = "drawElementsInstanced");
            else if (
              ((u = t.get("ANGLE_instanced_arrays")),
              (h = "drawElementsInstancedANGLE"),
              null === u)
            )
              return void console.error(
                "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
              );
            u[h](s, l, a, i * o, c), n.update(l, s, c);
          });
      }
      function ci(e) {
        const t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
        return {
          memory: { geometries: 0, textures: 0 },
          render: t,
          programs: null,
          autoReset: !0,
          reset: function () {
            t.frame++,
              (t.calls = 0),
              (t.triangles = 0),
              (t.points = 0),
              (t.lines = 0);
          },
          update: function (e, n, i) {
            switch ((t.calls++, n)) {
              case 4:
                t.triangles += i * (e / 3);
                break;
              case 1:
                t.lines += i * (e / 2);
                break;
              case 3:
                t.lines += i * (e - 1);
                break;
              case 2:
                t.lines += i * e;
                break;
              case 0:
                t.points += i * e;
                break;
              default:
                console.error("THREE.WebGLInfo: Unknown draw mode:", n);
            }
          },
        };
      }
      function ui(e, t) {
        return e[0] - t[0];
      }
      function hi(e, t) {
        return Math.abs(t[1]) - Math.abs(e[1]);
      }
      function di(e, t) {
        let n = 1;
        const i = t.isInterleavedBufferAttribute ? t.data.array : t.array;
        i instanceof Int8Array
          ? (n = 127)
          : i instanceof Uint8Array
          ? (n = 255)
          : i instanceof Uint16Array
          ? (n = 65535)
          : i instanceof Int16Array
          ? (n = 32767)
          : i instanceof Int32Array
          ? (n = 2147483647)
          : console.error(
              "THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",
              i
            ),
          e.divideScalar(n);
      }
      function pi(e, t, n) {
        const i = {},
          r = new Float32Array(8),
          s = new WeakMap(),
          a = new fe(),
          o = [];
        for (let e = 0; e < 8; e++) o[e] = [e, 0];
        return {
          update: function (l, c, u, h) {
            const d = l.morphTargetInfluences;
            if (!0 === t.isWebGL2) {
              const p =
                  c.morphAttributes.position ||
                  c.morphAttributes.normal ||
                  c.morphAttributes.color,
                f = void 0 !== p ? p.length : 0;
              let m = s.get(c);
              if (void 0 === m || m.count !== f) {
                void 0 !== m && m.texture.dispose();
                const x = void 0 !== c.morphAttributes.position,
                  y = void 0 !== c.morphAttributes.normal,
                  b = void 0 !== c.morphAttributes.color,
                  w = c.morphAttributes.position || [],
                  S = c.morphAttributes.normal || [],
                  M = c.morphAttributes.color || [];
                let E = 0;
                !0 === x && (E = 1), !0 === y && (E = 2), !0 === b && (E = 3);
                let T = c.attributes.position.count * E,
                  A = 1;
                T > t.maxTextureSize &&
                  ((A = Math.ceil(T / t.maxTextureSize)),
                  (T = t.maxTextureSize));
                const C = new Float32Array(T * A * 4 * f),
                  L = new ge(C, T, A, f);
                (L.type = _), (L.needsUpdate = !0);
                const P = 4 * E;
                for (let k = 0; k < f; k++) {
                  const R = w[k],
                    I = S[k],
                    F = M[k],
                    O = T * A * 4 * k;
                  for (let N = 0; N < R.count; N++) {
                    const z = N * P;
                    !0 === x &&
                      (a.fromBufferAttribute(R, N),
                      !0 === R.normalized && di(a, R),
                      (C[O + z + 0] = a.x),
                      (C[O + z + 1] = a.y),
                      (C[O + z + 2] = a.z),
                      (C[O + z + 3] = 0)),
                      !0 === y &&
                        (a.fromBufferAttribute(I, N),
                        !0 === I.normalized && di(a, I),
                        (C[O + z + 4] = a.x),
                        (C[O + z + 5] = a.y),
                        (C[O + z + 6] = a.z),
                        (C[O + z + 7] = 0)),
                      !0 === b &&
                        (a.fromBufferAttribute(F, N),
                        !0 === F.normalized && di(a, F),
                        (C[O + z + 8] = a.x),
                        (C[O + z + 9] = a.y),
                        (C[O + z + 10] = a.z),
                        (C[O + z + 11] = 4 === F.itemSize ? a.w : 1));
                  }
                }
                function D() {
                  L.dispose(), s.delete(c), c.removeEventListener("dispose", D);
                }
                (m = { count: f, texture: L, size: new X(T, A) }),
                  s.set(c, m),
                  c.addEventListener("dispose", D);
              }
              let g = 0;
              for (let B = 0; B < d.length; B++) g += d[B];
              const v = c.morphTargetsRelative ? 1 : 1 - g;
              h.getUniforms().setValue(e, "morphTargetBaseInfluence", v),
                h.getUniforms().setValue(e, "morphTargetInfluences", d),
                h
                  .getUniforms()
                  .setValue(e, "morphTargetsTexture", m.texture, n),
                h.getUniforms().setValue(e, "morphTargetsTextureSize", m.size);
            } else {
              const U = void 0 === d ? 0 : d.length;
              let V = i[c.id];
              if (void 0 === V || V.length !== U) {
                V = [];
                for (let q = 0; q < U; q++) V[q] = [q, 0];
                i[c.id] = V;
              }
              for (let Y = 0; Y < U; Y++) {
                const Z = V[Y];
                (Z[0] = Y), (Z[1] = d[Y]);
              }
              V.sort(hi);
              for (let $ = 0; $ < 8; $++)
                $ < U && V[$][1]
                  ? ((o[$][0] = V[$][0]), (o[$][1] = V[$][1]))
                  : ((o[$][0] = Number.MAX_SAFE_INTEGER), (o[$][1] = 0));
              o.sort(ui);
              const G = c.morphAttributes.position,
                H = c.morphAttributes.normal;
              let W = 0;
              for (let K = 0; K < 8; K++) {
                const J = o[K],
                  Q = J[0],
                  ee = J[1];
                Q !== Number.MAX_SAFE_INTEGER && ee
                  ? (G &&
                      c.getAttribute("morphTarget" + K) !== G[Q] &&
                      c.setAttribute("morphTarget" + K, G[Q]),
                    H &&
                      c.getAttribute("morphNormal" + K) !== H[Q] &&
                      c.setAttribute("morphNormal" + K, H[Q]),
                    (r[K] = ee),
                    (W += ee))
                  : (G &&
                      !0 === c.hasAttribute("morphTarget" + K) &&
                      c.deleteAttribute("morphTarget" + K),
                    H &&
                      !0 === c.hasAttribute("morphNormal" + K) &&
                      c.deleteAttribute("morphNormal" + K),
                    (r[K] = 0));
              }
              const j = c.morphTargetsRelative ? 1 : 1 - W;
              h.getUniforms().setValue(e, "morphTargetBaseInfluence", j),
                h.getUniforms().setValue(e, "morphTargetInfluences", r);
            }
          },
        };
      }
      function fi(e, t, n, i) {
        let r = new WeakMap();
        function s(e) {
          const t = e.target;
          t.removeEventListener("dispose", s),
            n.remove(t.instanceMatrix),
            null !== t.instanceColor && n.remove(t.instanceColor);
        }
        return {
          update: function (e) {
            const a = i.render.frame,
              o = e.geometry,
              l = t.get(e, o);
            return (
              r.get(l) !== a && (t.update(l), r.set(l, a)),
              e.isInstancedMesh &&
                (!1 === e.hasEventListener("dispose", s) &&
                  e.addEventListener("dispose", s),
                n.update(e.instanceMatrix, 34962),
                null !== e.instanceColor && n.update(e.instanceColor, 34962)),
              l
            );
          },
          dispose: function () {
            r = new WeakMap();
          },
        };
      }
      const mi = new pe(),
        gi = new ge(),
        vi = new ve(),
        _i = new En(),
        xi = [],
        yi = [],
        bi = new Float32Array(16),
        wi = new Float32Array(9),
        Si = new Float32Array(4);
      function Mi(e, t, n) {
        const i = e[0];
        if (i <= 0 || i > 0) return e;
        const r = t * n;
        let s = xi[r];
        if (
          (void 0 === s && ((s = new Float32Array(r)), (xi[r] = s)), 0 !== t)
        ) {
          i.toArray(s, 0);
          for (let i = 1, r = 0; i !== t; ++i) (r += n), e[i].toArray(s, r);
        }
        return s;
      }
      function Ei(e, t) {
        if (e.length !== t.length) return !1;
        for (let n = 0, i = e.length; n < i; n++) if (e[n] !== t[n]) return !1;
        return !0;
      }
      function Ti(e, t) {
        for (let n = 0, i = t.length; n < i; n++) e[n] = t[n];
      }
      function Ai(e, t) {
        let n = yi[t];
        void 0 === n && ((n = new Int32Array(t)), (yi[t] = n));
        for (let i = 0; i !== t; ++i) n[i] = e.allocateTextureUnit();
        return n;
      }
      function Ci(e, t) {
        const n = this.cache;
        n[0] !== t && (e.uniform1f(this.addr, t), (n[0] = t));
      }
      function Li(e, t) {
        const n = this.cache;
        if (void 0 !== t.x)
          (n[0] === t.x && n[1] === t.y) ||
            (e.uniform2f(this.addr, t.x, t.y), (n[0] = t.x), (n[1] = t.y));
        else {
          if (Ei(n, t)) return;
          e.uniform2fv(this.addr, t), Ti(n, t);
        }
      }
      function Pi(e, t) {
        const n = this.cache;
        if (void 0 !== t.x)
          (n[0] === t.x && n[1] === t.y && n[2] === t.z) ||
            (e.uniform3f(this.addr, t.x, t.y, t.z),
            (n[0] = t.x),
            (n[1] = t.y),
            (n[2] = t.z));
        else if (void 0 !== t.r)
          (n[0] === t.r && n[1] === t.g && n[2] === t.b) ||
            (e.uniform3f(this.addr, t.r, t.g, t.b),
            (n[0] = t.r),
            (n[1] = t.g),
            (n[2] = t.b));
        else {
          if (Ei(n, t)) return;
          e.uniform3fv(this.addr, t), Ti(n, t);
        }
      }
      function Di(e, t) {
        const n = this.cache;
        if (void 0 !== t.x)
          (n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w) ||
            (e.uniform4f(this.addr, t.x, t.y, t.z, t.w),
            (n[0] = t.x),
            (n[1] = t.y),
            (n[2] = t.z),
            (n[3] = t.w));
        else {
          if (Ei(n, t)) return;
          e.uniform4fv(this.addr, t), Ti(n, t);
        }
      }
      function ki(e, t) {
        const n = this.cache,
          i = t.elements;
        if (void 0 === i) {
          if (Ei(n, t)) return;
          e.uniformMatrix2fv(this.addr, !1, t), Ti(n, t);
        } else {
          if (Ei(n, i)) return;
          Si.set(i), e.uniformMatrix2fv(this.addr, !1, Si), Ti(n, i);
        }
      }
      function Ri(e, t) {
        const n = this.cache,
          i = t.elements;
        if (void 0 === i) {
          if (Ei(n, t)) return;
          e.uniformMatrix3fv(this.addr, !1, t), Ti(n, t);
        } else {
          if (Ei(n, i)) return;
          wi.set(i), e.uniformMatrix3fv(this.addr, !1, wi), Ti(n, i);
        }
      }
      function Ii(e, t) {
        const n = this.cache,
          i = t.elements;
        if (void 0 === i) {
          if (Ei(n, t)) return;
          e.uniformMatrix4fv(this.addr, !1, t), Ti(n, t);
        } else {
          if (Ei(n, i)) return;
          bi.set(i), e.uniformMatrix4fv(this.addr, !1, bi), Ti(n, i);
        }
      }
      function Fi(e, t) {
        const n = this.cache;
        n[0] !== t && (e.uniform1i(this.addr, t), (n[0] = t));
      }
      function Oi(e, t) {
        const n = this.cache;
        Ei(n, t) || (e.uniform2iv(this.addr, t), Ti(n, t));
      }
      function Ni(e, t) {
        const n = this.cache;
        Ei(n, t) || (e.uniform3iv(this.addr, t), Ti(n, t));
      }
      function zi(e, t) {
        const n = this.cache;
        Ei(n, t) || (e.uniform4iv(this.addr, t), Ti(n, t));
      }
      function Bi(e, t) {
        const n = this.cache;
        n[0] !== t && (e.uniform1ui(this.addr, t), (n[0] = t));
      }
      function Ui(e, t) {
        const n = this.cache;
        Ei(n, t) || (e.uniform2uiv(this.addr, t), Ti(n, t));
      }
      function Vi(e, t) {
        const n = this.cache;
        Ei(n, t) || (e.uniform3uiv(this.addr, t), Ti(n, t));
      }
      function Gi(e, t) {
        const n = this.cache;
        Ei(n, t) || (e.uniform4uiv(this.addr, t), Ti(n, t));
      }
      function Hi(e, t, n) {
        const i = this.cache,
          r = n.allocateTextureUnit();
        i[0] !== r && (e.uniform1i(this.addr, r), (i[0] = r)),
          n.setTexture2D(t || mi, r);
      }
      function Wi(e, t, n) {
        const i = this.cache,
          r = n.allocateTextureUnit();
        i[0] !== r && (e.uniform1i(this.addr, r), (i[0] = r)),
          n.setTexture3D(t || vi, r);
      }
      function ji(e, t, n) {
        const i = this.cache,
          r = n.allocateTextureUnit();
        i[0] !== r && (e.uniform1i(this.addr, r), (i[0] = r)),
          n.setTextureCube(t || _i, r);
      }
      function qi(e, t, n) {
        const i = this.cache,
          r = n.allocateTextureUnit();
        i[0] !== r && (e.uniform1i(this.addr, r), (i[0] = r)),
          n.setTexture2DArray(t || gi, r);
      }
      function Xi(e, t) {
        e.uniform1fv(this.addr, t);
      }
      function Yi(e, t) {
        const n = Mi(t, this.size, 2);
        e.uniform2fv(this.addr, n);
      }
      function Zi(e, t) {
        const n = Mi(t, this.size, 3);
        e.uniform3fv(this.addr, n);
      }
      function $i(e, t) {
        const n = Mi(t, this.size, 4);
        e.uniform4fv(this.addr, n);
      }
      function Ki(e, t) {
        const n = Mi(t, this.size, 4);
        e.uniformMatrix2fv(this.addr, !1, n);
      }
      function Ji(e, t) {
        const n = Mi(t, this.size, 9);
        e.uniformMatrix3fv(this.addr, !1, n);
      }
      function Qi(e, t) {
        const n = Mi(t, this.size, 16);
        e.uniformMatrix4fv(this.addr, !1, n);
      }
      function er(e, t) {
        e.uniform1iv(this.addr, t);
      }
      function tr(e, t) {
        e.uniform2iv(this.addr, t);
      }
      function nr(e, t) {
        e.uniform3iv(this.addr, t);
      }
      function ir(e, t) {
        e.uniform4iv(this.addr, t);
      }
      function rr(e, t) {
        e.uniform1uiv(this.addr, t);
      }
      function sr(e, t) {
        e.uniform2uiv(this.addr, t);
      }
      function ar(e, t) {
        e.uniform3uiv(this.addr, t);
      }
      function or(e, t) {
        e.uniform4uiv(this.addr, t);
      }
      function lr(e, t, n) {
        const i = t.length,
          r = Ai(n, i);
        e.uniform1iv(this.addr, r);
        for (let e = 0; e !== i; ++e) n.setTexture2D(t[e] || mi, r[e]);
      }
      function cr(e, t, n) {
        const i = t.length,
          r = Ai(n, i);
        e.uniform1iv(this.addr, r);
        for (let e = 0; e !== i; ++e) n.setTexture3D(t[e] || vi, r[e]);
      }
      function ur(e, t, n) {
        const i = t.length,
          r = Ai(n, i);
        e.uniform1iv(this.addr, r);
        for (let e = 0; e !== i; ++e) n.setTextureCube(t[e] || _i, r[e]);
      }
      function hr(e, t, n) {
        const i = t.length,
          r = Ai(n, i);
        e.uniform1iv(this.addr, r);
        for (let e = 0; e !== i; ++e) n.setTexture2DArray(t[e] || gi, r[e]);
      }
      class dr {
        constructor(e, t, n) {
          (this.id = e),
            (this.addr = n),
            (this.cache = []),
            (this.setValue = (function (e) {
              switch (e) {
                case 5126:
                  return Ci;
                case 35664:
                  return Li;
                case 35665:
                  return Pi;
                case 35666:
                  return Di;
                case 35674:
                  return ki;
                case 35675:
                  return Ri;
                case 35676:
                  return Ii;
                case 5124:
                case 35670:
                  return Fi;
                case 35667:
                case 35671:
                  return Oi;
                case 35668:
                case 35672:
                  return Ni;
                case 35669:
                case 35673:
                  return zi;
                case 5125:
                  return Bi;
                case 36294:
                  return Ui;
                case 36295:
                  return Vi;
                case 36296:
                  return Gi;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                  return Hi;
                case 35679:
                case 36299:
                case 36307:
                  return Wi;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                  return ji;
                case 36289:
                case 36303:
                case 36311:
                case 36292:
                  return qi;
              }
            })(t.type));
        }
      }
      class pr {
        constructor(e, t, n) {
          (this.id = e),
            (this.addr = n),
            (this.cache = []),
            (this.size = t.size),
            (this.setValue = (function (e) {
              switch (e) {
                case 5126:
                  return Xi;
                case 35664:
                  return Yi;
                case 35665:
                  return Zi;
                case 35666:
                  return $i;
                case 35674:
                  return Ki;
                case 35675:
                  return Ji;
                case 35676:
                  return Qi;
                case 5124:
                case 35670:
                  return er;
                case 35667:
                case 35671:
                  return tr;
                case 35668:
                case 35672:
                  return nr;
                case 35669:
                case 35673:
                  return ir;
                case 5125:
                  return rr;
                case 36294:
                  return sr;
                case 36295:
                  return ar;
                case 36296:
                  return or;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                  return lr;
                case 35679:
                case 36299:
                case 36307:
                  return cr;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                  return ur;
                case 36289:
                case 36303:
                case 36311:
                case 36292:
                  return hr;
              }
            })(t.type));
        }
      }
      class fr {
        constructor(e) {
          (this.id = e), (this.seq = []), (this.map = {});
        }
        setValue(e, t, n) {
          const i = this.seq;
          for (let r = 0, s = i.length; r !== s; ++r) {
            const s = i[r];
            s.setValue(e, t[s.id], n);
          }
        }
      }
      const mr = /(\w+)(\])?(\[|\.)?/g;
      function gr(e, t) {
        e.seq.push(t), (e.map[t.id] = t);
      }
      function vr(e, t, n) {
        const i = e.name,
          r = i.length;
        for (mr.lastIndex = 0; ; ) {
          const s = mr.exec(i),
            a = mr.lastIndex;
          let o = s[1];
          const l = "]" === s[2],
            c = s[3];
          if ((l && (o |= 0), void 0 === c || ("[" === c && a + 2 === r))) {
            gr(n, void 0 === c ? new dr(o, e, t) : new pr(o, e, t));
            break;
          }
          {
            let e = n.map[o];
            void 0 === e && ((e = new fr(o)), gr(n, e)), (n = e);
          }
        }
      }
      class _r {
        constructor(e, t) {
          (this.seq = []), (this.map = {});
          const n = e.getProgramParameter(t, 35718);
          for (let i = 0; i < n; ++i) {
            const n = e.getActiveUniform(t, i);
            vr(n, e.getUniformLocation(t, n.name), this);
          }
        }
        setValue(e, t, n, i) {
          const r = this.map[t];
          void 0 !== r && r.setValue(e, n, i);
        }
        setOptional(e, t, n) {
          const i = t[n];
          void 0 !== i && this.setValue(e, n, i);
        }
        static upload(e, t, n, i) {
          for (let r = 0, s = t.length; r !== s; ++r) {
            const s = t[r],
              a = n[s.id];
            !1 !== a.needsUpdate && s.setValue(e, a.value, i);
          }
        }
        static seqWithValue(e, t) {
          const n = [];
          for (let i = 0, r = e.length; i !== r; ++i) {
            const r = e[i];
            r.id in t && n.push(r);
          }
          return n;
        }
      }
      function xr(e, t, n) {
        const i = e.createShader(t);
        return e.shaderSource(i, n), e.compileShader(i), i;
      }
      let yr = 0;
      function br(e, t, n) {
        const i = e.getShaderParameter(t, 35713),
          r = e.getShaderInfoLog(t).trim();
        if (i && "" === r) return "";
        const s = /ERROR: 0:(\d+)/.exec(r);
        if (s) {
          const i = parseInt(s[1]);
          return (
            n.toUpperCase() +
            "\n\n" +
            r +
            "\n\n" +
            (function (e, t) {
              const n = e.split("\n"),
                i = [],
                r = Math.max(t - 6, 0),
                s = Math.min(t + 6, n.length);
              for (let e = r; e < s; e++) {
                const r = e + 1;
                i.push(`${r === t ? ">" : " "} ${r}: ${n[e]}`);
              }
              return i.join("\n");
            })(e.getShaderSource(t), i)
          );
        }
        return r;
      }
      function wr(e, t) {
        const n = (function (e) {
          switch (e) {
            case D:
              return ["Linear", "( value )"];
            case k:
              return ["sRGB", "( value )"];
            default:
              return (
                console.warn("THREE.WebGLProgram: Unsupported encoding:", e),
                ["Linear", "( value )"]
              );
          }
        })(t);
        return (
          "vec4 " + e + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
        );
      }
      function Sr(e, t) {
        let n;
        switch (t) {
          case 1:
            n = "Linear";
            break;
          case 2:
            n = "Reinhard";
            break;
          case 3:
            n = "OptimizedCineon";
            break;
          case 4:
            n = "ACESFilmic";
            break;
          case 5:
            n = "Custom";
            break;
          default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t),
              (n = "Linear");
        }
        return (
          "vec3 " +
          e +
          "( vec3 color ) { return " +
          n +
          "ToneMapping( color ); }"
        );
      }
      function Mr(e) {
        return "" !== e;
      }
      function Er(e, t) {
        return e
          .replace(/NUM_DIR_LIGHTS/g, t.numDirLights)
          .replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights)
          .replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights)
          .replace(/NUM_POINT_LIGHTS/g, t.numPointLights)
          .replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
          .replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows)
          .replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows)
          .replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows);
      }
      function Tr(e, t) {
        return e
          .replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes)
          .replace(
            /UNION_CLIPPING_PLANES/g,
            t.numClippingPlanes - t.numClipIntersection
          );
      }
      const Ar = /^[ \t]*#include +<([\w\d./]+)>/gm;
      function Cr(e) {
        return e.replace(Ar, Lr);
      }
      function Lr(e, t) {
        const n = Nn[t];
        if (void 0 === n)
          throw new Error("Can not resolve #include <" + t + ">");
        return Cr(n);
      }
      const Pr =
          /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
        Dr =
          /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
      function kr(e) {
        return e.replace(Dr, Ir).replace(Pr, Rr);
      }
      function Rr(e, t, n, i) {
        return (
          console.warn(
            "WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."
          ),
          Ir(0, t, n, i)
        );
      }
      function Ir(e, t, n, i) {
        let r = "";
        for (let e = parseInt(t); e < parseInt(n); e++)
          r += i
            .replace(/\[\s*i\s*\]/g, "[ " + e + " ]")
            .replace(/UNROLLED_LOOP_INDEX/g, e);
        return r;
      }
      function Fr(e) {
        let t =
          "precision " +
          e.precision +
          " float;\nprecision " +
          e.precision +
          " int;";
        return (
          "highp" === e.precision
            ? (t += "\n#define HIGH_PRECISION")
            : "mediump" === e.precision
            ? (t += "\n#define MEDIUM_PRECISION")
            : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"),
          t
        );
      }
      function Or(e, t, n, i) {
        const r = e.getContext(),
          s = n.defines;
        let a = n.vertexShader,
          u = n.fragmentShader;
        const h = (function (e) {
            let t = "SHADOWMAP_TYPE_BASIC";
            return (
              1 === e.shadowMapType
                ? (t = "SHADOWMAP_TYPE_PCF")
                : 2 === e.shadowMapType
                ? (t = "SHADOWMAP_TYPE_PCF_SOFT")
                : 3 === e.shadowMapType && (t = "SHADOWMAP_TYPE_VSM"),
              t
            );
          })(n),
          d = (function (e) {
            let t = "ENVMAP_TYPE_CUBE";
            if (e.envMap)
              switch (e.envMapMode) {
                case o:
                case l:
                  t = "ENVMAP_TYPE_CUBE";
                  break;
                case c:
                  t = "ENVMAP_TYPE_CUBE_UV";
              }
            return t;
          })(n),
          p = (function (e) {
            let t = "ENVMAP_MODE_REFLECTION";
            return (
              e.envMap && e.envMapMode === l && (t = "ENVMAP_MODE_REFRACTION"),
              t
            );
          })(n),
          f = (function (e) {
            let t = "ENVMAP_BLENDING_NONE";
            if (e.envMap)
              switch (e.combine) {
                case 0:
                  t = "ENVMAP_BLENDING_MULTIPLY";
                  break;
                case 1:
                  t = "ENVMAP_BLENDING_MIX";
                  break;
                case 2:
                  t = "ENVMAP_BLENDING_ADD";
              }
            return t;
          })(n),
          m = (function (e) {
            const t = e.envMapCubeUVHeight;
            if (null === t) return null;
            const n = Math.log2(t) - 2,
              i = 1 / t;
            return {
              texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
              texelHeight: i,
              maxMip: n,
            };
          })(n),
          g = n.isWebGL2
            ? ""
            : (function (e) {
                return [
                  e.extensionDerivatives ||
                  e.envMapCubeUVHeight ||
                  e.bumpMap ||
                  e.tangentSpaceNormalMap ||
                  e.clearcoatNormalMap ||
                  e.flatShading ||
                  "physical" === e.shaderID
                    ? "#extension GL_OES_standard_derivatives : enable"
                    : "",
                  (e.extensionFragDepth || e.logarithmicDepthBuffer) &&
                  e.rendererExtensionFragDepth
                    ? "#extension GL_EXT_frag_depth : enable"
                    : "",
                  e.extensionDrawBuffers && e.rendererExtensionDrawBuffers
                    ? "#extension GL_EXT_draw_buffers : require"
                    : "",
                  (e.extensionShaderTextureLOD || e.envMap || e.transmission) &&
                  e.rendererExtensionShaderTextureLod
                    ? "#extension GL_EXT_shader_texture_lod : enable"
                    : "",
                ]
                  .filter(Mr)
                  .join("\n");
              })(n),
          v = (function (e) {
            const t = [];
            for (const n in e) {
              const i = e[n];
              !1 !== i && t.push("#define " + n + " " + i);
            }
            return t.join("\n");
          })(s),
          _ = r.createProgram();
        let x,
          y,
          b = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
        n.isRawShaderMaterial
          ? ((x = [v].filter(Mr).join("\n")),
            x.length > 0 && (x += "\n"),
            (y = [g, v].filter(Mr).join("\n")),
            y.length > 0 && (y += "\n"))
          : ((x = [
              Fr(n),
              "#define SHADER_NAME " + n.shaderName,
              v,
              n.instancing ? "#define USE_INSTANCING" : "",
              n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
              n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
              n.useFog && n.fog ? "#define USE_FOG" : "",
              n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
              n.map ? "#define USE_MAP" : "",
              n.envMap ? "#define USE_ENVMAP" : "",
              n.envMap ? "#define " + p : "",
              n.lightMap ? "#define USE_LIGHTMAP" : "",
              n.aoMap ? "#define USE_AOMAP" : "",
              n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              n.bumpMap ? "#define USE_BUMPMAP" : "",
              n.normalMap ? "#define USE_NORMALMAP" : "",
              n.normalMap && n.objectSpaceNormalMap
                ? "#define OBJECTSPACE_NORMALMAP"
                : "",
              n.normalMap && n.tangentSpaceNormalMap
                ? "#define TANGENTSPACE_NORMALMAP"
                : "",
              n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              n.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
              n.iridescenceThicknessMap
                ? "#define USE_IRIDESCENCE_THICKNESSMAP"
                : "",
              n.displacementMap && n.supportsVertexTextures
                ? "#define USE_DISPLACEMENTMAP"
                : "",
              n.specularMap ? "#define USE_SPECULARMAP" : "",
              n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
              n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
              n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              n.metalnessMap ? "#define USE_METALNESSMAP" : "",
              n.alphaMap ? "#define USE_ALPHAMAP" : "",
              n.transmission ? "#define USE_TRANSMISSION" : "",
              n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
              n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
              n.vertexTangents ? "#define USE_TANGENT" : "",
              n.vertexColors ? "#define USE_COLOR" : "",
              n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              n.vertexUvs ? "#define USE_UV" : "",
              n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
              n.flatShading ? "#define FLAT_SHADED" : "",
              n.skinning ? "#define USE_SKINNING" : "",
              n.morphTargets ? "#define USE_MORPHTARGETS" : "",
              n.morphNormals && !1 === n.flatShading
                ? "#define USE_MORPHNORMALS"
                : "",
              n.morphColors && n.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
              n.morphTargetsCount > 0 && n.isWebGL2
                ? "#define MORPHTARGETS_TEXTURE"
                : "",
              n.morphTargetsCount > 0 && n.isWebGL2
                ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride
                : "",
              n.morphTargetsCount > 0 && n.isWebGL2
                ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount
                : "",
              n.doubleSided ? "#define DOUBLE_SIDED" : "",
              n.flipSided ? "#define FLIP_SIDED" : "",
              n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              n.shadowMapEnabled ? "#define " + h : "",
              n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
              n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              "uniform mat4 modelMatrix;",
              "uniform mat4 modelViewMatrix;",
              "uniform mat4 projectionMatrix;",
              "uniform mat4 viewMatrix;",
              "uniform mat3 normalMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              "#ifdef USE_INSTANCING",
              "\tattribute mat4 instanceMatrix;",
              "#endif",
              "#ifdef USE_INSTANCING_COLOR",
              "\tattribute vec3 instanceColor;",
              "#endif",
              "attribute vec3 position;",
              "attribute vec3 normal;",
              "attribute vec2 uv;",
              "#ifdef USE_TANGENT",
              "\tattribute vec4 tangent;",
              "#endif",
              "#if defined( USE_COLOR_ALPHA )",
              "\tattribute vec4 color;",
              "#elif defined( USE_COLOR )",
              "\tattribute vec3 color;",
              "#endif",
              "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
              "\tattribute vec3 morphTarget0;",
              "\tattribute vec3 morphTarget1;",
              "\tattribute vec3 morphTarget2;",
              "\tattribute vec3 morphTarget3;",
              "\t#ifdef USE_MORPHNORMALS",
              "\t\tattribute vec3 morphNormal0;",
              "\t\tattribute vec3 morphNormal1;",
              "\t\tattribute vec3 morphNormal2;",
              "\t\tattribute vec3 morphNormal3;",
              "\t#else",
              "\t\tattribute vec3 morphTarget4;",
              "\t\tattribute vec3 morphTarget5;",
              "\t\tattribute vec3 morphTarget6;",
              "\t\tattribute vec3 morphTarget7;",
              "\t#endif",
              "#endif",
              "#ifdef USE_SKINNING",
              "\tattribute vec4 skinIndex;",
              "\tattribute vec4 skinWeight;",
              "#endif",
              "\n",
            ]
              .filter(Mr)
              .join("\n")),
            (y = [
              g,
              Fr(n),
              "#define SHADER_NAME " + n.shaderName,
              v,
              n.useFog && n.fog ? "#define USE_FOG" : "",
              n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
              n.map ? "#define USE_MAP" : "",
              n.matcap ? "#define USE_MATCAP" : "",
              n.envMap ? "#define USE_ENVMAP" : "",
              n.envMap ? "#define " + d : "",
              n.envMap ? "#define " + p : "",
              n.envMap ? "#define " + f : "",
              m ? "#define CUBEUV_TEXEL_WIDTH " + m.texelWidth : "",
              m ? "#define CUBEUV_TEXEL_HEIGHT " + m.texelHeight : "",
              m ? "#define CUBEUV_MAX_MIP " + m.maxMip + ".0" : "",
              n.lightMap ? "#define USE_LIGHTMAP" : "",
              n.aoMap ? "#define USE_AOMAP" : "",
              n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              n.bumpMap ? "#define USE_BUMPMAP" : "",
              n.normalMap ? "#define USE_NORMALMAP" : "",
              n.normalMap && n.objectSpaceNormalMap
                ? "#define OBJECTSPACE_NORMALMAP"
                : "",
              n.normalMap && n.tangentSpaceNormalMap
                ? "#define TANGENTSPACE_NORMALMAP"
                : "",
              n.clearcoat ? "#define USE_CLEARCOAT" : "",
              n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              n.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              n.iridescence ? "#define USE_IRIDESCENCE" : "",
              n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
              n.iridescenceThicknessMap
                ? "#define USE_IRIDESCENCE_THICKNESSMAP"
                : "",
              n.specularMap ? "#define USE_SPECULARMAP" : "",
              n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
              n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
              n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              n.metalnessMap ? "#define USE_METALNESSMAP" : "",
              n.alphaMap ? "#define USE_ALPHAMAP" : "",
              n.alphaTest ? "#define USE_ALPHATEST" : "",
              n.sheen ? "#define USE_SHEEN" : "",
              n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
              n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
              n.transmission ? "#define USE_TRANSMISSION" : "",
              n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
              n.vertexTangents ? "#define USE_TANGENT" : "",
              n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "",
              n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              n.vertexUvs ? "#define USE_UV" : "",
              n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
              n.gradientMap ? "#define USE_GRADIENTMAP" : "",
              n.flatShading ? "#define FLAT_SHADED" : "",
              n.doubleSided ? "#define DOUBLE_SIDED" : "",
              n.flipSided ? "#define FLIP_SIDED" : "",
              n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              n.shadowMapEnabled ? "#define " + h : "",
              n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
              n.physicallyCorrectLights
                ? "#define PHYSICALLY_CORRECT_LIGHTS"
                : "",
              n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              "uniform mat4 viewMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              0 !== n.toneMapping ? "#define TONE_MAPPING" : "",
              0 !== n.toneMapping ? Nn.tonemapping_pars_fragment : "",
              0 !== n.toneMapping ? Sr("toneMapping", n.toneMapping) : "",
              n.dithering ? "#define DITHERING" : "",
              n.opaque ? "#define OPAQUE" : "",
              Nn.encodings_pars_fragment,
              wr("linearToOutputTexel", n.outputEncoding),
              n.useDepthPacking
                ? "#define DEPTH_PACKING " + n.depthPacking
                : "",
              "\n",
            ]
              .filter(Mr)
              .join("\n"))),
          (a = Cr(a)),
          (a = Er(a, n)),
          (a = Tr(a, n)),
          (u = Cr(u)),
          (u = Er(u, n)),
          (u = Tr(u, n)),
          (a = kr(a)),
          (u = kr(u)),
          n.isWebGL2 &&
            !0 !== n.isRawShaderMaterial &&
            ((b = "#version 300 es\n"),
            (x =
              [
                "precision mediump sampler2DArray;",
                "#define attribute in",
                "#define varying out",
                "#define texture2D texture",
              ].join("\n") +
              "\n" +
              x),
            (y =
              [
                "#define varying in",
                n.glslVersion === O
                  ? ""
                  : "layout(location = 0) out highp vec4 pc_fragColor;",
                n.glslVersion === O ? "" : "#define gl_FragColor pc_fragColor",
                "#define gl_FragDepthEXT gl_FragDepth",
                "#define texture2D texture",
                "#define textureCube texture",
                "#define texture2DProj textureProj",
                "#define texture2DLodEXT textureLod",
                "#define texture2DProjLodEXT textureProjLod",
                "#define textureCubeLodEXT textureLod",
                "#define texture2DGradEXT textureGrad",
                "#define texture2DProjGradEXT textureProjGrad",
                "#define textureCubeGradEXT textureGrad",
              ].join("\n") +
              "\n" +
              y));
        const w = b + y + u,
          S = xr(r, 35633, b + x + a),
          M = xr(r, 35632, w);
        if (
          (r.attachShader(_, S),
          r.attachShader(_, M),
          void 0 !== n.index0AttributeName
            ? r.bindAttribLocation(_, 0, n.index0AttributeName)
            : !0 === n.morphTargets && r.bindAttribLocation(_, 0, "position"),
          r.linkProgram(_),
          e.debug.checkShaderErrors)
        ) {
          const e = r.getProgramInfoLog(_).trim(),
            t = r.getShaderInfoLog(S).trim(),
            n = r.getShaderInfoLog(M).trim();
          let i = !0,
            s = !0;
          if (!1 === r.getProgramParameter(_, 35714)) {
            i = !1;
            const t = br(r, S, "vertex"),
              n = br(r, M, "fragment");
            console.error(
              "THREE.WebGLProgram: Shader Error " +
                r.getError() +
                " - VALIDATE_STATUS " +
                r.getProgramParameter(_, 35715) +
                "\n\nProgram Info Log: " +
                e +
                "\n" +
                t +
                "\n" +
                n
            );
          } else
            "" !== e
              ? console.warn("THREE.WebGLProgram: Program Info Log:", e)
              : ("" !== t && "" !== n) || (s = !1);
          s &&
            (this.diagnostics = {
              runnable: i,
              programLog: e,
              vertexShader: { log: t, prefix: x },
              fragmentShader: { log: n, prefix: y },
            });
        }
        let E, T;
        return (
          r.deleteShader(S),
          r.deleteShader(M),
          (this.getUniforms = function () {
            return void 0 === E && (E = new _r(r, _)), E;
          }),
          (this.getAttributes = function () {
            return (
              void 0 === T &&
                (T = (function (e, t) {
                  const n = {},
                    i = e.getProgramParameter(t, 35721);
                  for (let r = 0; r < i; r++) {
                    const i = e.getActiveAttrib(t, r),
                      s = i.name;
                    let a = 1;
                    35674 === i.type && (a = 2),
                      35675 === i.type && (a = 3),
                      35676 === i.type && (a = 4),
                      (n[s] = {
                        type: i.type,
                        location: e.getAttribLocation(t, s),
                        locationSize: a,
                      });
                  }
                  return n;
                })(r, _)),
              T
            );
          }),
          (this.destroy = function () {
            i.releaseStatesOfProgram(this),
              r.deleteProgram(_),
              (this.program = void 0);
          }),
          (this.name = n.shaderName),
          (this.id = yr++),
          (this.cacheKey = t),
          (this.usedTimes = 1),
          (this.program = _),
          (this.vertexShader = S),
          (this.fragmentShader = M),
          this
        );
      }
      let Nr = 0;
      class zr {
        constructor() {
          (this.shaderCache = new Map()), (this.materialCache = new Map());
        }
        update(e) {
          const t = e.vertexShader,
            n = e.fragmentShader,
            i = this._getShaderStage(t),
            r = this._getShaderStage(n),
            s = this._getShaderCacheForMaterial(e);
          return (
            !1 === s.has(i) && (s.add(i), i.usedTimes++),
            !1 === s.has(r) && (s.add(r), r.usedTimes++),
            this
          );
        }
        remove(e) {
          const t = this.materialCache.get(e);
          for (const e of t)
            e.usedTimes--, 0 === e.usedTimes && this.shaderCache.delete(e.code);
          return this.materialCache.delete(e), this;
        }
        getVertexShaderID(e) {
          return this._getShaderStage(e.vertexShader).id;
        }
        getFragmentShaderID(e) {
          return this._getShaderStage(e.fragmentShader).id;
        }
        dispose() {
          this.shaderCache.clear(), this.materialCache.clear();
        }
        _getShaderCacheForMaterial(e) {
          const t = this.materialCache;
          return !1 === t.has(e) && t.set(e, new Set()), t.get(e);
        }
        _getShaderStage(e) {
          const t = this.shaderCache;
          if (!1 === t.has(e)) {
            const n = new Br(e);
            t.set(e, n);
          }
          return t.get(e);
        }
      }
      class Br {
        constructor(e) {
          (this.id = Nr++), (this.code = e), (this.usedTimes = 0);
        }
      }
      function Ur(e, t, n, i, r, s, a) {
        const o = new ot(),
          l = new zr(),
          u = [],
          h = r.isWebGL2,
          d = r.logarithmicDepthBuffer,
          p = r.vertexTextures;
        let f = r.precision;
        const m = {
          MeshDepthMaterial: "depth",
          MeshDistanceMaterial: "distanceRGBA",
          MeshNormalMaterial: "normal",
          MeshBasicMaterial: "basic",
          MeshLambertMaterial: "lambert",
          MeshPhongMaterial: "phong",
          MeshToonMaterial: "toon",
          MeshStandardMaterial: "physical",
          MeshPhysicalMaterial: "physical",
          MeshMatcapMaterial: "matcap",
          LineBasicMaterial: "basic",
          LineDashedMaterial: "dashed",
          PointsMaterial: "points",
          ShadowMaterial: "shadow",
          SpriteMaterial: "sprite",
        };
        return {
          getParameters: function (s, o, u, g, v) {
            const _ = g.fog,
              x = v.geometry,
              y = s.isMeshStandardMaterial ? g.environment : null,
              b = (s.isMeshStandardMaterial ? n : t).get(s.envMap || y),
              w = b && b.mapping === c ? b.image.height : null,
              S = m[s.type];
            null !== s.precision &&
              ((f = r.getMaxPrecision(s.precision)),
              f !== s.precision &&
                console.warn(
                  "THREE.WebGLProgram.getParameters:",
                  s.precision,
                  "not supported, using",
                  f,
                  "instead."
                ));
            const M =
                x.morphAttributes.position ||
                x.morphAttributes.normal ||
                x.morphAttributes.color,
              E = void 0 !== M ? M.length : 0;
            let T,
              A,
              C,
              L,
              P = 0;
            if (
              (void 0 !== x.morphAttributes.position && (P = 1),
              void 0 !== x.morphAttributes.normal && (P = 2),
              void 0 !== x.morphAttributes.color && (P = 3),
              S)
            ) {
              const e = Bn[S];
              (T = e.vertexShader), (A = e.fragmentShader);
            } else
              (T = s.vertexShader),
                (A = s.fragmentShader),
                l.update(s),
                (C = l.getVertexShaderID(s)),
                (L = l.getFragmentShaderID(s));
            const R = e.getRenderTarget(),
              I = s.alphaTest > 0,
              F = s.clearcoat > 0,
              O = s.iridescence > 0;
            return {
              isWebGL2: h,
              shaderID: S,
              shaderName: s.type,
              vertexShader: T,
              fragmentShader: A,
              defines: s.defines,
              customVertexShaderID: C,
              customFragmentShaderID: L,
              isRawShaderMaterial: !0 === s.isRawShaderMaterial,
              glslVersion: s.glslVersion,
              precision: f,
              instancing: !0 === v.isInstancedMesh,
              instancingColor:
                !0 === v.isInstancedMesh && null !== v.instanceColor,
              supportsVertexTextures: p,
              outputEncoding:
                null === R
                  ? e.outputEncoding
                  : !0 === R.isXRRenderTarget
                  ? R.texture.encoding
                  : D,
              map: !!s.map,
              matcap: !!s.matcap,
              envMap: !!b,
              envMapMode: b && b.mapping,
              envMapCubeUVHeight: w,
              lightMap: !!s.lightMap,
              aoMap: !!s.aoMap,
              emissiveMap: !!s.emissiveMap,
              bumpMap: !!s.bumpMap,
              normalMap: !!s.normalMap,
              objectSpaceNormalMap: 1 === s.normalMapType,
              tangentSpaceNormalMap: 0 === s.normalMapType,
              decodeVideoTexture:
                !!s.map && !0 === s.map.isVideoTexture && s.map.encoding === k,
              clearcoat: F,
              clearcoatMap: F && !!s.clearcoatMap,
              clearcoatRoughnessMap: F && !!s.clearcoatRoughnessMap,
              clearcoatNormalMap: F && !!s.clearcoatNormalMap,
              iridescence: O,
              iridescenceMap: O && !!s.iridescenceMap,
              iridescenceThicknessMap: O && !!s.iridescenceThicknessMap,
              displacementMap: !!s.displacementMap,
              roughnessMap: !!s.roughnessMap,
              metalnessMap: !!s.metalnessMap,
              specularMap: !!s.specularMap,
              specularIntensityMap: !!s.specularIntensityMap,
              specularColorMap: !!s.specularColorMap,
              opaque: !1 === s.transparent && 1 === s.blending,
              alphaMap: !!s.alphaMap,
              alphaTest: I,
              gradientMap: !!s.gradientMap,
              sheen: s.sheen > 0,
              sheenColorMap: !!s.sheenColorMap,
              sheenRoughnessMap: !!s.sheenRoughnessMap,
              transmission: s.transmission > 0,
              transmissionMap: !!s.transmissionMap,
              thicknessMap: !!s.thicknessMap,
              combine: s.combine,
              vertexTangents: !!s.normalMap && !!x.attributes.tangent,
              vertexColors: s.vertexColors,
              vertexAlphas:
                !0 === s.vertexColors &&
                !!x.attributes.color &&
                4 === x.attributes.color.itemSize,
              vertexUvs: !!(
                s.map ||
                s.bumpMap ||
                s.normalMap ||
                s.specularMap ||
                s.alphaMap ||
                s.emissiveMap ||
                s.roughnessMap ||
                s.metalnessMap ||
                s.clearcoatMap ||
                s.clearcoatRoughnessMap ||
                s.clearcoatNormalMap ||
                s.iridescenceMap ||
                s.iridescenceThicknessMap ||
                s.displacementMap ||
                s.transmissionMap ||
                s.thicknessMap ||
                s.specularIntensityMap ||
                s.specularColorMap ||
                s.sheenColorMap ||
                s.sheenRoughnessMap
              ),
              uvsVertexOnly: !(
                s.map ||
                s.bumpMap ||
                s.normalMap ||
                s.specularMap ||
                s.alphaMap ||
                s.emissiveMap ||
                s.roughnessMap ||
                s.metalnessMap ||
                s.clearcoatNormalMap ||
                s.iridescenceMap ||
                s.iridescenceThicknessMap ||
                s.transmission > 0 ||
                s.transmissionMap ||
                s.thicknessMap ||
                s.specularIntensityMap ||
                s.specularColorMap ||
                s.sheen > 0 ||
                s.sheenColorMap ||
                s.sheenRoughnessMap ||
                !s.displacementMap
              ),
              fog: !!_,
              useFog: !0 === s.fog,
              fogExp2: _ && _.isFogExp2,
              flatShading: !!s.flatShading,
              sizeAttenuation: s.sizeAttenuation,
              logarithmicDepthBuffer: d,
              skinning: !0 === v.isSkinnedMesh,
              morphTargets: void 0 !== x.morphAttributes.position,
              morphNormals: void 0 !== x.morphAttributes.normal,
              morphColors: void 0 !== x.morphAttributes.color,
              morphTargetsCount: E,
              morphTextureStride: P,
              numDirLights: o.directional.length,
              numPointLights: o.point.length,
              numSpotLights: o.spot.length,
              numRectAreaLights: o.rectArea.length,
              numHemiLights: o.hemi.length,
              numDirLightShadows: o.directionalShadowMap.length,
              numPointLightShadows: o.pointShadowMap.length,
              numSpotLightShadows: o.spotShadowMap.length,
              numClippingPlanes: a.numPlanes,
              numClipIntersection: a.numIntersection,
              dithering: s.dithering,
              shadowMapEnabled: e.shadowMap.enabled && u.length > 0,
              shadowMapType: e.shadowMap.type,
              toneMapping: s.toneMapped ? e.toneMapping : 0,
              physicallyCorrectLights: e.physicallyCorrectLights,
              premultipliedAlpha: s.premultipliedAlpha,
              doubleSided: 2 === s.side,
              flipSided: 1 === s.side,
              useDepthPacking: !!s.depthPacking,
              depthPacking: s.depthPacking || 0,
              index0AttributeName: s.index0AttributeName,
              extensionDerivatives: s.extensions && s.extensions.derivatives,
              extensionFragDepth: s.extensions && s.extensions.fragDepth,
              extensionDrawBuffers: s.extensions && s.extensions.drawBuffers,
              extensionShaderTextureLOD:
                s.extensions && s.extensions.shaderTextureLOD,
              rendererExtensionFragDepth: h || i.has("EXT_frag_depth"),
              rendererExtensionDrawBuffers: h || i.has("WEBGL_draw_buffers"),
              rendererExtensionShaderTextureLod:
                h || i.has("EXT_shader_texture_lod"),
              customProgramCacheKey: s.customProgramCacheKey(),
            };
          },
          getProgramCacheKey: function (t) {
            const n = [];
            if (
              (t.shaderID
                ? n.push(t.shaderID)
                : (n.push(t.customVertexShaderID),
                  n.push(t.customFragmentShaderID)),
              void 0 !== t.defines)
            )
              for (const e in t.defines) n.push(e), n.push(t.defines[e]);
            return (
              !1 === t.isRawShaderMaterial &&
                ((function (e, t) {
                  e.push(t.precision),
                    e.push(t.outputEncoding),
                    e.push(t.envMapMode),
                    e.push(t.envMapCubeUVHeight),
                    e.push(t.combine),
                    e.push(t.vertexUvs),
                    e.push(t.fogExp2),
                    e.push(t.sizeAttenuation),
                    e.push(t.morphTargetsCount),
                    e.push(t.morphAttributeCount),
                    e.push(t.numDirLights),
                    e.push(t.numPointLights),
                    e.push(t.numSpotLights),
                    e.push(t.numHemiLights),
                    e.push(t.numRectAreaLights),
                    e.push(t.numDirLightShadows),
                    e.push(t.numPointLightShadows),
                    e.push(t.numSpotLightShadows),
                    e.push(t.shadowMapType),
                    e.push(t.toneMapping),
                    e.push(t.numClippingPlanes),
                    e.push(t.numClipIntersection),
                    e.push(t.depthPacking);
                })(n, t),
                (function (e, t) {
                  o.disableAll(),
                    t.isWebGL2 && o.enable(0),
                    t.supportsVertexTextures && o.enable(1),
                    t.instancing && o.enable(2),
                    t.instancingColor && o.enable(3),
                    t.map && o.enable(4),
                    t.matcap && o.enable(5),
                    t.envMap && o.enable(6),
                    t.lightMap && o.enable(7),
                    t.aoMap && o.enable(8),
                    t.emissiveMap && o.enable(9),
                    t.bumpMap && o.enable(10),
                    t.normalMap && o.enable(11),
                    t.objectSpaceNormalMap && o.enable(12),
                    t.tangentSpaceNormalMap && o.enable(13),
                    t.clearcoat && o.enable(14),
                    t.clearcoatMap && o.enable(15),
                    t.clearcoatRoughnessMap && o.enable(16),
                    t.clearcoatNormalMap && o.enable(17),
                    t.iridescence && o.enable(18),
                    t.iridescenceMap && o.enable(19),
                    t.iridescenceThicknessMap && o.enable(20),
                    t.displacementMap && o.enable(21),
                    t.specularMap && o.enable(22),
                    t.roughnessMap && o.enable(23),
                    t.metalnessMap && o.enable(24),
                    t.gradientMap && o.enable(25),
                    t.alphaMap && o.enable(26),
                    t.alphaTest && o.enable(27),
                    t.vertexColors && o.enable(28),
                    t.vertexAlphas && o.enable(29),
                    t.vertexUvs && o.enable(30),
                    t.vertexTangents && o.enable(31),
                    t.uvsVertexOnly && o.enable(32),
                    t.fog && o.enable(33),
                    e.push(o.mask),
                    o.disableAll(),
                    t.useFog && o.enable(0),
                    t.flatShading && o.enable(1),
                    t.logarithmicDepthBuffer && o.enable(2),
                    t.skinning && o.enable(3),
                    t.morphTargets && o.enable(4),
                    t.morphNormals && o.enable(5),
                    t.morphColors && o.enable(6),
                    t.premultipliedAlpha && o.enable(7),
                    t.shadowMapEnabled && o.enable(8),
                    t.physicallyCorrectLights && o.enable(9),
                    t.doubleSided && o.enable(10),
                    t.flipSided && o.enable(11),
                    t.useDepthPacking && o.enable(12),
                    t.dithering && o.enable(13),
                    t.specularIntensityMap && o.enable(14),
                    t.specularColorMap && o.enable(15),
                    t.transmission && o.enable(16),
                    t.transmissionMap && o.enable(17),
                    t.thicknessMap && o.enable(18),
                    t.sheen && o.enable(19),
                    t.sheenColorMap && o.enable(20),
                    t.sheenRoughnessMap && o.enable(21),
                    t.decodeVideoTexture && o.enable(22),
                    t.opaque && o.enable(23),
                    e.push(o.mask);
                })(n, t),
                n.push(e.outputEncoding)),
              n.push(t.customProgramCacheKey),
              n.join()
            );
          },
          getUniforms: function (e) {
            const t = m[e.type];
            let n;
            if (t) {
              const e = Bn[t];
              n = xn.clone(e.uniforms);
            } else n = e.uniforms;
            return n;
          },
          acquireProgram: function (t, n) {
            let i;
            for (let e = 0, t = u.length; e < t; e++) {
              const t = u[e];
              if (t.cacheKey === n) {
                (i = t), ++i.usedTimes;
                break;
              }
            }
            return void 0 === i && ((i = new Or(e, n, t, s)), u.push(i)), i;
          },
          releaseProgram: function (e) {
            if (0 == --e.usedTimes) {
              const t = u.indexOf(e);
              (u[t] = u[u.length - 1]), u.pop(), e.destroy();
            }
          },
          releaseShaderCache: function (e) {
            l.remove(e);
          },
          programs: u,
          dispose: function () {
            l.dispose();
          },
        };
      }
      function Vr() {
        let e = new WeakMap();
        return {
          get: function (t) {
            let n = e.get(t);
            return void 0 === n && ((n = {}), e.set(t, n)), n;
          },
          remove: function (t) {
            e.delete(t);
          },
          update: function (t, n, i) {
            e.get(t)[n] = i;
          },
          dispose: function () {
            e = new WeakMap();
          },
        };
      }
      function Gr(e, t) {
        return e.groupOrder !== t.groupOrder
          ? e.groupOrder - t.groupOrder
          : e.renderOrder !== t.renderOrder
          ? e.renderOrder - t.renderOrder
          : e.material.id !== t.material.id
          ? e.material.id - t.material.id
          : e.z !== t.z
          ? e.z - t.z
          : e.id - t.id;
      }
      function Hr(e, t) {
        return e.groupOrder !== t.groupOrder
          ? e.groupOrder - t.groupOrder
          : e.renderOrder !== t.renderOrder
          ? e.renderOrder - t.renderOrder
          : e.z !== t.z
          ? t.z - e.z
          : e.id - t.id;
      }
      function Wr() {
        const e = [];
        let t = 0;
        const n = [],
          i = [],
          r = [];
        function s(n, i, r, s, a, o) {
          let l = e[t];
          return (
            void 0 === l
              ? ((l = {
                  id: n.id,
                  object: n,
                  geometry: i,
                  material: r,
                  groupOrder: s,
                  renderOrder: n.renderOrder,
                  z: a,
                  group: o,
                }),
                (e[t] = l))
              : ((l.id = n.id),
                (l.object = n),
                (l.geometry = i),
                (l.material = r),
                (l.groupOrder = s),
                (l.renderOrder = n.renderOrder),
                (l.z = a),
                (l.group = o)),
            t++,
            l
          );
        }
        return {
          opaque: n,
          transmissive: i,
          transparent: r,
          init: function () {
            (t = 0), (n.length = 0), (i.length = 0), (r.length = 0);
          },
          push: function (e, t, a, o, l, c) {
            const u = s(e, t, a, o, l, c);
            a.transmission > 0
              ? i.push(u)
              : !0 === a.transparent
              ? r.push(u)
              : n.push(u);
          },
          unshift: function (e, t, a, o, l, c) {
            const u = s(e, t, a, o, l, c);
            a.transmission > 0
              ? i.unshift(u)
              : !0 === a.transparent
              ? r.unshift(u)
              : n.unshift(u);
          },
          finish: function () {
            for (let n = t, i = e.length; n < i; n++) {
              const t = e[n];
              if (null === t.id) break;
              (t.id = null),
                (t.object = null),
                (t.geometry = null),
                (t.material = null),
                (t.group = null);
            }
          },
          sort: function (e, t) {
            n.length > 1 && n.sort(e || Gr),
              i.length > 1 && i.sort(t || Hr),
              r.length > 1 && r.sort(t || Hr);
          },
        };
      }
      function jr() {
        let e = new WeakMap();
        return {
          get: function (t, n) {
            let i;
            return (
              !1 === e.has(t)
                ? ((i = new Wr()), e.set(t, [i]))
                : n >= e.get(t).length
                ? ((i = new Wr()), e.get(t).push(i))
                : (i = e.get(t)[n]),
              i
            );
          },
          dispose: function () {
            e = new WeakMap();
          },
        };
      }
      function qr() {
        const e = {};
        return {
          get: function (t) {
            if (void 0 !== e[t.id]) return e[t.id];
            let n;
            switch (t.type) {
              case "DirectionalLight":
                n = { direction: new xe(), color: new oe() };
                break;
              case "SpotLight":
                n = {
                  position: new xe(),
                  direction: new xe(),
                  color: new oe(),
                  distance: 0,
                  coneCos: 0,
                  penumbraCos: 0,
                  decay: 0,
                };
                break;
              case "PointLight":
                n = {
                  position: new xe(),
                  color: new oe(),
                  distance: 0,
                  decay: 0,
                };
                break;
              case "HemisphereLight":
                n = {
                  direction: new xe(),
                  skyColor: new oe(),
                  groundColor: new oe(),
                };
                break;
              case "RectAreaLight":
                n = {
                  color: new oe(),
                  position: new xe(),
                  halfWidth: new xe(),
                  halfHeight: new xe(),
                };
            }
            return (e[t.id] = n), n;
          },
        };
      }
      let Xr = 0;
      function Yr(e, t) {
        return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0);
      }
      function Zr(e, t) {
        const n = new qr(),
          i = (function () {
            const e = {};
            return {
              get: function (t) {
                if (void 0 !== e[t.id]) return e[t.id];
                let n;
                switch (t.type) {
                  case "DirectionalLight":
                  case "SpotLight":
                    n = {
                      shadowBias: 0,
                      shadowNormalBias: 0,
                      shadowRadius: 1,
                      shadowMapSize: new X(),
                    };
                    break;
                  case "PointLight":
                    n = {
                      shadowBias: 0,
                      shadowNormalBias: 0,
                      shadowRadius: 1,
                      shadowMapSize: new X(),
                      shadowCameraNear: 1,
                      shadowCameraFar: 1e3,
                    };
                }
                return (e[t.id] = n), n;
              },
            };
          })(),
          r = {
            version: 0,
            hash: {
              directionalLength: -1,
              pointLength: -1,
              spotLength: -1,
              rectAreaLength: -1,
              hemiLength: -1,
              numDirectionalShadows: -1,
              numPointShadows: -1,
              numSpotShadows: -1,
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadow: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
          };
        for (let e = 0; e < 9; e++) r.probe.push(new xe());
        const s = new xe(),
          a = new $e(),
          o = new $e();
        return {
          setup: function (s, a) {
            let o = 0,
              l = 0,
              c = 0;
            for (let e = 0; e < 9; e++) r.probe[e].set(0, 0, 0);
            let u = 0,
              h = 0,
              d = 0,
              p = 0,
              f = 0,
              m = 0,
              g = 0,
              v = 0;
            s.sort(Yr);
            const _ = !0 !== a ? Math.PI : 1;
            for (let e = 0, t = s.length; e < t; e++) {
              const t = s[e],
                a = t.color,
                x = t.intensity,
                y = t.distance,
                b = t.shadow && t.shadow.map ? t.shadow.map.texture : null;
              if (t.isAmbientLight)
                (o += a.r * x * _), (l += a.g * x * _), (c += a.b * x * _);
              else if (t.isLightProbe)
                for (let e = 0; e < 9; e++)
                  r.probe[e].addScaledVector(t.sh.coefficients[e], x);
              else if (t.isDirectionalLight) {
                const e = n.get(t);
                if (
                  (e.color.copy(t.color).multiplyScalar(t.intensity * _),
                  t.castShadow)
                ) {
                  const e = t.shadow,
                    n = i.get(t);
                  (n.shadowBias = e.bias),
                    (n.shadowNormalBias = e.normalBias),
                    (n.shadowRadius = e.radius),
                    (n.shadowMapSize = e.mapSize),
                    (r.directionalShadow[u] = n),
                    (r.directionalShadowMap[u] = b),
                    (r.directionalShadowMatrix[u] = t.shadow.matrix),
                    m++;
                }
                (r.directional[u] = e), u++;
              } else if (t.isSpotLight) {
                const e = n.get(t);
                if (
                  (e.position.setFromMatrixPosition(t.matrixWorld),
                  e.color.copy(a).multiplyScalar(x * _),
                  (e.distance = y),
                  (e.coneCos = Math.cos(t.angle)),
                  (e.penumbraCos = Math.cos(t.angle * (1 - t.penumbra))),
                  (e.decay = t.decay),
                  t.castShadow)
                ) {
                  const e = t.shadow,
                    n = i.get(t);
                  (n.shadowBias = e.bias),
                    (n.shadowNormalBias = e.normalBias),
                    (n.shadowRadius = e.radius),
                    (n.shadowMapSize = e.mapSize),
                    (r.spotShadow[d] = n),
                    (r.spotShadowMap[d] = b),
                    (r.spotShadowMatrix[d] = t.shadow.matrix),
                    v++;
                }
                (r.spot[d] = e), d++;
              } else if (t.isRectAreaLight) {
                const e = n.get(t);
                e.color.copy(a).multiplyScalar(x),
                  e.halfWidth.set(0.5 * t.width, 0, 0),
                  e.halfHeight.set(0, 0.5 * t.height, 0),
                  (r.rectArea[p] = e),
                  p++;
              } else if (t.isPointLight) {
                const e = n.get(t);
                if (
                  (e.color.copy(t.color).multiplyScalar(t.intensity * _),
                  (e.distance = t.distance),
                  (e.decay = t.decay),
                  t.castShadow)
                ) {
                  const e = t.shadow,
                    n = i.get(t);
                  (n.shadowBias = e.bias),
                    (n.shadowNormalBias = e.normalBias),
                    (n.shadowRadius = e.radius),
                    (n.shadowMapSize = e.mapSize),
                    (n.shadowCameraNear = e.camera.near),
                    (n.shadowCameraFar = e.camera.far),
                    (r.pointShadow[h] = n),
                    (r.pointShadowMap[h] = b),
                    (r.pointShadowMatrix[h] = t.shadow.matrix),
                    g++;
                }
                (r.point[h] = e), h++;
              } else if (t.isHemisphereLight) {
                const e = n.get(t);
                e.skyColor.copy(t.color).multiplyScalar(x * _),
                  e.groundColor.copy(t.groundColor).multiplyScalar(x * _),
                  (r.hemi[f] = e),
                  f++;
              }
            }
            p > 0 &&
              (t.isWebGL2 || !0 === e.has("OES_texture_float_linear")
                ? ((r.rectAreaLTC1 = zn.LTC_FLOAT_1),
                  (r.rectAreaLTC2 = zn.LTC_FLOAT_2))
                : !0 === e.has("OES_texture_half_float_linear")
                ? ((r.rectAreaLTC1 = zn.LTC_HALF_1),
                  (r.rectAreaLTC2 = zn.LTC_HALF_2))
                : console.error(
                    "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
                  )),
              (r.ambient[0] = o),
              (r.ambient[1] = l),
              (r.ambient[2] = c);
            const x = r.hash;
            (x.directionalLength === u &&
              x.pointLength === h &&
              x.spotLength === d &&
              x.rectAreaLength === p &&
              x.hemiLength === f &&
              x.numDirectionalShadows === m &&
              x.numPointShadows === g &&
              x.numSpotShadows === v) ||
              ((r.directional.length = u),
              (r.spot.length = d),
              (r.rectArea.length = p),
              (r.point.length = h),
              (r.hemi.length = f),
              (r.directionalShadow.length = m),
              (r.directionalShadowMap.length = m),
              (r.pointShadow.length = g),
              (r.pointShadowMap.length = g),
              (r.spotShadow.length = v),
              (r.spotShadowMap.length = v),
              (r.directionalShadowMatrix.length = m),
              (r.pointShadowMatrix.length = g),
              (r.spotShadowMatrix.length = v),
              (x.directionalLength = u),
              (x.pointLength = h),
              (x.spotLength = d),
              (x.rectAreaLength = p),
              (x.hemiLength = f),
              (x.numDirectionalShadows = m),
              (x.numPointShadows = g),
              (x.numSpotShadows = v),
              (r.version = Xr++));
          },
          setupView: function (e, t) {
            let n = 0,
              i = 0,
              l = 0,
              c = 0,
              u = 0;
            const h = t.matrixWorldInverse;
            for (let t = 0, d = e.length; t < d; t++) {
              const d = e[t];
              if (d.isDirectionalLight) {
                const e = r.directional[n];
                e.direction.setFromMatrixPosition(d.matrixWorld),
                  s.setFromMatrixPosition(d.target.matrixWorld),
                  e.direction.sub(s),
                  e.direction.transformDirection(h),
                  n++;
              } else if (d.isSpotLight) {
                const e = r.spot[l];
                e.position.setFromMatrixPosition(d.matrixWorld),
                  e.position.applyMatrix4(h),
                  e.direction.setFromMatrixPosition(d.matrixWorld),
                  s.setFromMatrixPosition(d.target.matrixWorld),
                  e.direction.sub(s),
                  e.direction.transformDirection(h),
                  l++;
              } else if (d.isRectAreaLight) {
                const e = r.rectArea[c];
                e.position.setFromMatrixPosition(d.matrixWorld),
                  e.position.applyMatrix4(h),
                  o.identity(),
                  a.copy(d.matrixWorld),
                  a.premultiply(h),
                  o.extractRotation(a),
                  e.halfWidth.set(0.5 * d.width, 0, 0),
                  e.halfHeight.set(0, 0.5 * d.height, 0),
                  e.halfWidth.applyMatrix4(o),
                  e.halfHeight.applyMatrix4(o),
                  c++;
              } else if (d.isPointLight) {
                const e = r.point[i];
                e.position.setFromMatrixPosition(d.matrixWorld),
                  e.position.applyMatrix4(h),
                  i++;
              } else if (d.isHemisphereLight) {
                const e = r.hemi[u];
                e.direction.setFromMatrixPosition(d.matrixWorld),
                  e.direction.transformDirection(h),
                  u++;
              }
            }
          },
          state: r,
        };
      }
      function $r(e, t) {
        const n = new Zr(e, t),
          i = [],
          r = [];
        return {
          init: function () {
            (i.length = 0), (r.length = 0);
          },
          state: { lightsArray: i, shadowsArray: r, lights: n },
          setupLights: function (e) {
            n.setup(i, e);
          },
          setupLightsView: function (e) {
            n.setupView(i, e);
          },
          pushLight: function (e) {
            i.push(e);
          },
          pushShadow: function (e) {
            r.push(e);
          },
        };
      }
      function Kr(e, t) {
        let n = new WeakMap();
        return {
          get: function (i, r = 0) {
            let s;
            return (
              !1 === n.has(i)
                ? ((s = new $r(e, t)), n.set(i, [s]))
                : r >= n.get(i).length
                ? ((s = new $r(e, t)), n.get(i).push(s))
                : (s = n.get(i)[r]),
              s
            );
          },
          dispose: function () {
            n = new WeakMap();
          },
        };
      }
      class Jr extends It {
        constructor(e) {
          super(),
            (this.isMeshDepthMaterial = !0),
            (this.type = "MeshDepthMaterial"),
            (this.depthPacking = 3200),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.depthPacking = e.depthPacking),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            this
          );
        }
      }
      class Qr extends It {
        constructor(e) {
          super(),
            (this.isMeshDistanceMaterial = !0),
            (this.type = "MeshDistanceMaterial"),
            (this.referencePosition = new xe()),
            (this.nearDistance = 1),
            (this.farDistance = 1e3),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.referencePosition.copy(e.referencePosition),
            (this.nearDistance = e.nearDistance),
            (this.farDistance = e.farDistance),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            this
          );
        }
      }
      function es(e, t, n) {
        let i = new Rn();
        const r = new X(),
          s = new X(),
          a = new fe(),
          o = new Jr({ depthPacking: 3201 }),
          l = new Qr(),
          c = {},
          u = n.maxTextureSize,
          h = { 0: 1, 1: 0, 2: 2 },
          d = new yn({
            defines: { VSM_SAMPLES: 8 },
            uniforms: {
              shadow_pass: { value: null },
              resolution: { value: new X() },
              radius: { value: 4 },
            },
            vertexShader:
              "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
            fragmentShader:
              "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
          }),
          f = d.clone();
        f.defines.HORIZONTAL_PASS = 1;
        const m = new Zt();
        m.setAttribute(
          "position",
          new zt(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
        );
        const g = new fn(m, d),
          v = this;
        function _(n, i) {
          const s = t.update(g);
          d.defines.VSM_SAMPLES !== n.blurSamples &&
            ((d.defines.VSM_SAMPLES = n.blurSamples),
            (f.defines.VSM_SAMPLES = n.blurSamples),
            (d.needsUpdate = !0),
            (f.needsUpdate = !0)),
            null === n.mapPass && (n.mapPass = new me(r.x, r.y)),
            (d.uniforms.shadow_pass.value = n.map.texture),
            (d.uniforms.resolution.value = n.mapSize),
            (d.uniforms.radius.value = n.radius),
            e.setRenderTarget(n.mapPass),
            e.clear(),
            e.renderBufferDirect(i, null, s, d, g, null),
            (f.uniforms.shadow_pass.value = n.mapPass.texture),
            (f.uniforms.resolution.value = n.mapSize),
            (f.uniforms.radius.value = n.radius),
            e.setRenderTarget(n.map),
            e.clear(),
            e.renderBufferDirect(i, null, s, f, g, null);
        }
        function x(t, n, i, r, s, a) {
          let u = null;
          const d =
            !0 === i.isPointLight
              ? t.customDistanceMaterial
              : t.customDepthMaterial;
          if (
            ((u = void 0 !== d ? d : !0 === i.isPointLight ? l : o),
            (e.localClippingEnabled &&
              !0 === n.clipShadows &&
              Array.isArray(n.clippingPlanes) &&
              0 !== n.clippingPlanes.length) ||
              (n.displacementMap && 0 !== n.displacementScale) ||
              (n.alphaMap && n.alphaTest > 0))
          ) {
            const e = u.uuid,
              t = n.uuid;
            let i = c[e];
            void 0 === i && ((i = {}), (c[e] = i));
            let r = i[t];
            void 0 === r && ((r = u.clone()), (i[t] = r)), (u = r);
          }
          return (
            (u.visible = n.visible),
            (u.wireframe = n.wireframe),
            (u.side =
              3 === a
                ? null !== n.shadowSide
                  ? n.shadowSide
                  : n.side
                : null !== n.shadowSide
                ? n.shadowSide
                : h[n.side]),
            (u.alphaMap = n.alphaMap),
            (u.alphaTest = n.alphaTest),
            (u.clipShadows = n.clipShadows),
            (u.clippingPlanes = n.clippingPlanes),
            (u.clipIntersection = n.clipIntersection),
            (u.displacementMap = n.displacementMap),
            (u.displacementScale = n.displacementScale),
            (u.displacementBias = n.displacementBias),
            (u.wireframeLinewidth = n.wireframeLinewidth),
            (u.linewidth = n.linewidth),
            !0 === i.isPointLight &&
              !0 === u.isMeshDistanceMaterial &&
              (u.referencePosition.setFromMatrixPosition(i.matrixWorld),
              (u.nearDistance = r),
              (u.farDistance = s)),
            u
          );
        }
        function y(n, r, s, a, o) {
          if (!1 === n.visible) return;
          if (
            n.layers.test(r.layers) &&
            (n.isMesh || n.isLine || n.isPoints) &&
            (n.castShadow || (n.receiveShadow && 3 === o)) &&
            (!n.frustumCulled || i.intersectsObject(n))
          ) {
            n.modelViewMatrix.multiplyMatrices(
              s.matrixWorldInverse,
              n.matrixWorld
            );
            const i = t.update(n),
              r = n.material;
            if (Array.isArray(r)) {
              const t = i.groups;
              for (let l = 0, c = t.length; l < c; l++) {
                const c = t[l],
                  u = r[c.materialIndex];
                if (u && u.visible) {
                  const t = x(n, u, a, s.near, s.far, o);
                  e.renderBufferDirect(s, null, i, t, n, c);
                }
              }
            } else if (r.visible) {
              const t = x(n, r, a, s.near, s.far, o);
              e.renderBufferDirect(s, null, i, t, n, null);
            }
          }
          const l = n.children;
          for (let e = 0, t = l.length; e < t; e++) y(l[e], r, s, a, o);
        }
        (this.enabled = !1),
          (this.autoUpdate = !0),
          (this.needsUpdate = !1),
          (this.type = 1),
          (this.render = function (t, n, o) {
            if (!1 === v.enabled) return;
            if (!1 === v.autoUpdate && !1 === v.needsUpdate) return;
            if (0 === t.length) return;
            const l = e.getRenderTarget(),
              c = e.getActiveCubeFace(),
              h = e.getActiveMipmapLevel(),
              d = e.state;
            d.setBlending(0),
              d.buffers.color.setClear(1, 1, 1, 1),
              d.buffers.depth.setTest(!0),
              d.setScissorTest(!1);
            for (let l = 0, c = t.length; l < c; l++) {
              const c = t[l],
                h = c.shadow;
              if (void 0 === h) {
                console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
                continue;
              }
              if (!1 === h.autoUpdate && !1 === h.needsUpdate) continue;
              r.copy(h.mapSize);
              const f = h.getFrameExtents();
              if (
                (r.multiply(f),
                s.copy(h.mapSize),
                (r.x > u || r.y > u) &&
                  (r.x > u &&
                    ((s.x = Math.floor(u / f.x)),
                    (r.x = s.x * f.x),
                    (h.mapSize.x = s.x)),
                  r.y > u &&
                    ((s.y = Math.floor(u / f.y)),
                    (r.y = s.y * f.y),
                    (h.mapSize.y = s.y))),
                null === h.map)
              ) {
                const e = 3 !== this.type ? { minFilter: p, magFilter: p } : {};
                (h.map = new me(r.x, r.y, e)),
                  (h.map.texture.name = c.name + ".shadowMap"),
                  h.camera.updateProjectionMatrix();
              }
              e.setRenderTarget(h.map), e.clear();
              const m = h.getViewportCount();
              for (let e = 0; e < m; e++) {
                const t = h.getViewport(e);
                a.set(s.x * t.x, s.y * t.y, s.x * t.z, s.y * t.w),
                  d.viewport(a),
                  h.updateMatrices(c, e),
                  (i = h.getFrustum()),
                  y(n, o, h.camera, c, this.type);
              }
              !0 !== h.isPointLightShadow && 3 === this.type && _(h, o),
                (h.needsUpdate = !1);
            }
            (v.needsUpdate = !1), e.setRenderTarget(l, c, h);
          });
      }
      function ts(e, t, n) {
        const i = n.isWebGL2,
          r = new (function () {
            let t = !1;
            const n = new fe();
            let i = null;
            const r = new fe(0, 0, 0, 0);
            return {
              setMask: function (n) {
                i === n || t || (e.colorMask(n, n, n, n), (i = n));
              },
              setLocked: function (e) {
                t = e;
              },
              setClear: function (t, i, s, a, o) {
                !0 === o && ((t *= a), (i *= a), (s *= a)),
                  n.set(t, i, s, a),
                  !1 === r.equals(n) && (e.clearColor(t, i, s, a), r.copy(n));
              },
              reset: function () {
                (t = !1), (i = null), r.set(-1, 0, 0, 0);
              },
            };
          })(),
          s = new (function () {
            let t = !1,
              n = null,
              i = null,
              r = null;
            return {
              setTest: function (e) {
                e ? B(2929) : U(2929);
              },
              setMask: function (i) {
                n === i || t || (e.depthMask(i), (n = i));
              },
              setFunc: function (t) {
                if (i !== t) {
                  if (t)
                    switch (t) {
                      case 0:
                        e.depthFunc(512);
                        break;
                      case 1:
                        e.depthFunc(519);
                        break;
                      case 2:
                        e.depthFunc(513);
                        break;
                      case 3:
                      default:
                        e.depthFunc(515);
                        break;
                      case 4:
                        e.depthFunc(514);
                        break;
                      case 5:
                        e.depthFunc(518);
                        break;
                      case 6:
                        e.depthFunc(516);
                        break;
                      case 7:
                        e.depthFunc(517);
                    }
                  else e.depthFunc(515);
                  i = t;
                }
              },
              setLocked: function (e) {
                t = e;
              },
              setClear: function (t) {
                r !== t && (e.clearDepth(t), (r = t));
              },
              reset: function () {
                (t = !1), (n = null), (i = null), (r = null);
              },
            };
          })(),
          o = new (function () {
            let t = !1,
              n = null,
              i = null,
              r = null,
              s = null,
              a = null,
              o = null,
              l = null,
              c = null;
            return {
              setTest: function (e) {
                t || (e ? B(2960) : U(2960));
              },
              setMask: function (i) {
                n === i || t || (e.stencilMask(i), (n = i));
              },
              setFunc: function (t, n, a) {
                (i === t && r === n && s === a) ||
                  (e.stencilFunc(t, n, a), (i = t), (r = n), (s = a));
              },
              setOp: function (t, n, i) {
                (a === t && o === n && l === i) ||
                  (e.stencilOp(t, n, i), (a = t), (o = n), (l = i));
              },
              setLocked: function (e) {
                t = e;
              },
              setClear: function (t) {
                c !== t && (e.clearStencil(t), (c = t));
              },
              reset: function () {
                (t = !1),
                  (n = null),
                  (i = null),
                  (r = null),
                  (s = null),
                  (a = null),
                  (o = null),
                  (l = null),
                  (c = null);
              },
            };
          })();
        let l = {},
          c = {},
          u = new WeakMap(),
          h = [],
          d = null,
          p = !1,
          f = null,
          m = null,
          g = null,
          v = null,
          _ = null,
          x = null,
          y = null,
          b = !1,
          w = null,
          S = null,
          M = null,
          E = null,
          T = null;
        const A = e.getParameter(35661);
        let C = !1,
          L = 0;
        const P = e.getParameter(7938);
        -1 !== P.indexOf("WebGL")
          ? ((L = parseFloat(/^WebGL (\d)/.exec(P)[1])), (C = L >= 1))
          : -1 !== P.indexOf("OpenGL ES") &&
            ((L = parseFloat(/^OpenGL ES (\d)/.exec(P)[1])), (C = L >= 2));
        let D = null,
          k = {};
        const R = e.getParameter(3088),
          I = e.getParameter(2978),
          F = new fe().fromArray(R),
          O = new fe().fromArray(I);
        function N(t, n, i) {
          const r = new Uint8Array(4),
            s = e.createTexture();
          e.bindTexture(t, s),
            e.texParameteri(t, 10241, 9728),
            e.texParameteri(t, 10240, 9728);
          for (let t = 0; t < i; t++)
            e.texImage2D(n + t, 0, 6408, 1, 1, 0, 6408, 5121, r);
          return s;
        }
        const z = {};
        function B(t) {
          !0 !== l[t] && (e.enable(t), (l[t] = !0));
        }
        function U(t) {
          !1 !== l[t] && (e.disable(t), (l[t] = !1));
        }
        (z[3553] = N(3553, 3553, 1)),
          (z[34067] = N(34067, 34069, 6)),
          r.setClear(0, 0, 0, 1),
          s.setClear(1),
          o.setClear(0),
          B(2929),
          s.setFunc(3),
          W(!1),
          j(1),
          B(2884),
          H(0);
        const V = { [a]: 32774, 101: 32778, 102: 32779 };
        if (i) (V[103] = 32775), (V[104] = 32776);
        else {
          const e = t.get("EXT_blend_minmax");
          null !== e && ((V[103] = e.MIN_EXT), (V[104] = e.MAX_EXT));
        }
        const G = {
          200: 0,
          201: 1,
          202: 768,
          204: 770,
          210: 776,
          208: 774,
          206: 772,
          203: 769,
          205: 771,
          209: 775,
          207: 773,
        };
        function H(t, n, i, r, s, o, l, c) {
          if (0 !== t) {
            if ((!1 === p && (B(3042), (p = !0)), 5 === t))
              (s = s || n),
                (o = o || i),
                (l = l || r),
                (n === m && s === _) ||
                  (e.blendEquationSeparate(V[n], V[s]), (m = n), (_ = s)),
                (i === g && r === v && o === x && l === y) ||
                  (e.blendFuncSeparate(G[i], G[r], G[o], G[l]),
                  (g = i),
                  (v = r),
                  (x = o),
                  (y = l)),
                (f = t),
                (b = null);
            else if (t !== f || c !== b) {
              if (
                ((m === a && _ === a) ||
                  (e.blendEquation(32774), (m = a), (_ = a)),
                c)
              )
                switch (t) {
                  case 1:
                    e.blendFuncSeparate(1, 771, 1, 771);
                    break;
                  case 2:
                    e.blendFunc(1, 1);
                    break;
                  case 3:
                    e.blendFuncSeparate(0, 769, 0, 1);
                    break;
                  case 4:
                    e.blendFuncSeparate(0, 768, 0, 770);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", t);
                }
              else
                switch (t) {
                  case 1:
                    e.blendFuncSeparate(770, 771, 1, 771);
                    break;
                  case 2:
                    e.blendFunc(770, 1);
                    break;
                  case 3:
                    e.blendFuncSeparate(0, 769, 0, 1);
                    break;
                  case 4:
                    e.blendFunc(0, 768);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", t);
                }
              (g = null), (v = null), (x = null), (y = null), (f = t), (b = c);
            }
          } else !0 === p && (U(3042), (p = !1));
        }
        function W(t) {
          w !== t && (t ? e.frontFace(2304) : e.frontFace(2305), (w = t));
        }
        function j(t) {
          0 !== t
            ? (B(2884),
              t !== S &&
                (1 === t
                  ? e.cullFace(1029)
                  : 2 === t
                  ? e.cullFace(1028)
                  : e.cullFace(1032)))
            : U(2884),
            (S = t);
        }
        function q(t, n, i) {
          t
            ? (B(32823),
              (E === n && T === i) || (e.polygonOffset(n, i), (E = n), (T = i)))
            : U(32823);
        }
        function X(t) {
          void 0 === t && (t = 33984 + A - 1),
            D !== t && (e.activeTexture(t), (D = t));
        }
        return {
          buffers: { color: r, depth: s, stencil: o },
          enable: B,
          disable: U,
          bindFramebuffer: function (t, n) {
            return (
              c[t] !== n &&
              (e.bindFramebuffer(t, n),
              (c[t] = n),
              i &&
                (36009 === t && (c[36160] = n), 36160 === t && (c[36009] = n)),
              !0)
            );
          },
          drawBuffers: function (i, r) {
            let s = h,
              a = !1;
            if (i)
              if (
                ((s = u.get(r)),
                void 0 === s && ((s = []), u.set(r, s)),
                i.isWebGLMultipleRenderTargets)
              ) {
                const e = i.texture;
                if (s.length !== e.length || 36064 !== s[0]) {
                  for (let t = 0, n = e.length; t < n; t++) s[t] = 36064 + t;
                  (s.length = e.length), (a = !0);
                }
              } else 36064 !== s[0] && ((s[0] = 36064), (a = !0));
            else 1029 !== s[0] && ((s[0] = 1029), (a = !0));
            a &&
              (n.isWebGL2
                ? e.drawBuffers(s)
                : t.get("WEBGL_draw_buffers").drawBuffersWEBGL(s));
          },
          useProgram: function (t) {
            return d !== t && (e.useProgram(t), (d = t), !0);
          },
          setBlending: H,
          setMaterial: function (e, t) {
            2 === e.side ? U(2884) : B(2884);
            let n = 1 === e.side;
            t && (n = !n),
              W(n),
              1 === e.blending && !1 === e.transparent
                ? H(0)
                : H(
                    e.blending,
                    e.blendEquation,
                    e.blendSrc,
                    e.blendDst,
                    e.blendEquationAlpha,
                    e.blendSrcAlpha,
                    e.blendDstAlpha,
                    e.premultipliedAlpha
                  ),
              s.setFunc(e.depthFunc),
              s.setTest(e.depthTest),
              s.setMask(e.depthWrite),
              r.setMask(e.colorWrite);
            const i = e.stencilWrite;
            o.setTest(i),
              i &&
                (o.setMask(e.stencilWriteMask),
                o.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask),
                o.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)),
              q(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits),
              !0 === e.alphaToCoverage ? B(32926) : U(32926);
          },
          setFlipSided: W,
          setCullFace: j,
          setLineWidth: function (t) {
            t !== M && (C && e.lineWidth(t), (M = t));
          },
          setPolygonOffset: q,
          setScissorTest: function (e) {
            e ? B(3089) : U(3089);
          },
          activeTexture: X,
          bindTexture: function (t, n) {
            null === D && X();
            let i = k[D];
            void 0 === i &&
              ((i = { type: void 0, texture: void 0 }), (k[D] = i)),
              (i.type === t && i.texture === n) ||
                (e.bindTexture(t, n || z[t]), (i.type = t), (i.texture = n));
          },
          unbindTexture: function () {
            const t = k[D];
            void 0 !== t &&
              void 0 !== t.type &&
              (e.bindTexture(t.type, null),
              (t.type = void 0),
              (t.texture = void 0));
          },
          compressedTexImage2D: function () {
            try {
              e.compressedTexImage2D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          texImage2D: function () {
            try {
              e.texImage2D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          texImage3D: function () {
            try {
              e.texImage3D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          texStorage2D: function () {
            try {
              e.texStorage2D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          texStorage3D: function () {
            try {
              e.texStorage3D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          texSubImage2D: function () {
            try {
              e.texSubImage2D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          texSubImage3D: function () {
            try {
              e.texSubImage3D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          compressedTexSubImage2D: function () {
            try {
              e.compressedTexSubImage2D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          scissor: function (t) {
            !1 === F.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), F.copy(t));
          },
          viewport: function (t) {
            !1 === O.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), O.copy(t));
          },
          reset: function () {
            e.disable(3042),
              e.disable(2884),
              e.disable(2929),
              e.disable(32823),
              e.disable(3089),
              e.disable(2960),
              e.disable(32926),
              e.blendEquation(32774),
              e.blendFunc(1, 0),
              e.blendFuncSeparate(1, 0, 1, 0),
              e.colorMask(!0, !0, !0, !0),
              e.clearColor(0, 0, 0, 0),
              e.depthMask(!0),
              e.depthFunc(513),
              e.clearDepth(1),
              e.stencilMask(4294967295),
              e.stencilFunc(519, 0, 4294967295),
              e.stencilOp(7680, 7680, 7680),
              e.clearStencil(0),
              e.cullFace(1029),
              e.frontFace(2305),
              e.polygonOffset(0, 0),
              e.activeTexture(33984),
              e.bindFramebuffer(36160, null),
              !0 === i &&
                (e.bindFramebuffer(36009, null),
                e.bindFramebuffer(36008, null)),
              e.useProgram(null),
              e.lineWidth(1),
              e.scissor(0, 0, e.canvas.width, e.canvas.height),
              e.viewport(0, 0, e.canvas.width, e.canvas.height),
              (l = {}),
              (D = null),
              (k = {}),
              (c = {}),
              (u = new WeakMap()),
              (h = []),
              (d = null),
              (p = !1),
              (f = null),
              (m = null),
              (g = null),
              (v = null),
              (_ = null),
              (x = null),
              (y = null),
              (b = !1),
              (w = null),
              (S = null),
              (M = null),
              (E = null),
              (T = null),
              F.set(0, 0, e.canvas.width, e.canvas.height),
              O.set(0, 0, e.canvas.width, e.canvas.height),
              r.reset(),
              s.reset(),
              o.reset();
          },
        };
      }
      function ns(e, t, n, i, r, s, a) {
        const o = r.isWebGL2,
          l = r.maxTextures,
          c = r.maxCubemapSize,
          M = r.maxTextureSize,
          E = r.maxSamples,
          T = t.has("WEBGL_multisampled_render_to_texture")
            ? t.get("WEBGL_multisampled_render_to_texture")
            : null,
          A = /OculusBrowser/g.test(navigator.userAgent),
          C = new WeakMap();
        let L;
        const P = new WeakMap();
        let R = !1;
        try {
          R =
            "undefined" != typeof OffscreenCanvas &&
            null !== new OffscreenCanvas(1, 1).getContext("2d");
        } catch (e) {}
        function I(e, t) {
          return R ? new OffscreenCanvas(e, t) : $("canvas");
        }
        function F(e, t, n, i) {
          let r = 1;
          if (
            ((e.width > i || e.height > i) &&
              (r = i / Math.max(e.width, e.height)),
            r < 1 || !0 === t)
          ) {
            if (
              ("undefined" != typeof HTMLImageElement &&
                e instanceof HTMLImageElement) ||
              ("undefined" != typeof HTMLCanvasElement &&
                e instanceof HTMLCanvasElement) ||
              ("undefined" != typeof ImageBitmap && e instanceof ImageBitmap)
            ) {
              const i = t ? q : Math.floor,
                s = i(r * e.width),
                a = i(r * e.height);
              void 0 === L && (L = I(s, a));
              const o = n ? I(s, a) : L;
              return (
                (o.width = s),
                (o.height = a),
                o.getContext("2d").drawImage(e, 0, 0, s, a),
                console.warn(
                  "THREE.WebGLRenderer: Texture has been resized from (" +
                    e.width +
                    "x" +
                    e.height +
                    ") to (" +
                    s +
                    "x" +
                    a +
                    ")."
                ),
                o
              );
            }
            return (
              "data" in e &&
                console.warn(
                  "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                    e.width +
                    "x" +
                    e.height +
                    ")."
                ),
              e
            );
          }
          return e;
        }
        function O(e) {
          return j(e.width) && j(e.height);
        }
        function z(e, t) {
          return (
            e.generateMipmaps && t && e.minFilter !== p && e.minFilter !== f
          );
        }
        function B(t) {
          e.generateMipmap(t);
        }
        function U(n, i, r, s, a = !1) {
          if (!1 === o) return i;
          if (null !== n) {
            if (void 0 !== e[n]) return e[n];
            console.warn(
              "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
                n +
                "'"
            );
          }
          let l = i;
          return (
            6403 === i &&
              (5126 === r && (l = 33326),
              5131 === r && (l = 33325),
              5121 === r && (l = 33321)),
            33319 === i &&
              (5126 === r && (l = 33328),
              5131 === r && (l = 33327),
              5121 === r && (l = 33323)),
            6408 === i &&
              (5126 === r && (l = 34836),
              5131 === r && (l = 34842),
              5121 === r && (l = s === k && !1 === a ? 35907 : 32856),
              32819 === r && (l = 32854),
              32820 === r && (l = 32855)),
            (33325 !== l &&
              33326 !== l &&
              33327 !== l &&
              33328 !== l &&
              34842 !== l &&
              34836 !== l) ||
              t.get("EXT_color_buffer_float"),
            l
          );
        }
        function V(e, t, n) {
          return !0 === z(e, n) ||
            (e.isFramebufferTexture && e.minFilter !== p && e.minFilter !== f)
            ? Math.log2(Math.max(t.width, t.height)) + 1
            : void 0 !== e.mipmaps && e.mipmaps.length > 0
            ? e.mipmaps.length
            : e.isCompressedTexture && Array.isArray(e.image)
            ? t.mipmaps.length
            : 1;
        }
        function G(e) {
          return e === p || 1004 === e || 1005 === e ? 9728 : 9729;
        }
        function H(e) {
          const t = e.target;
          t.removeEventListener("dispose", H),
            (function (e) {
              const t = i.get(e);
              if (void 0 === t.__webglInit) return;
              const n = e.source,
                r = P.get(n);
              if (r) {
                const i = r[t.__cacheKey];
                i.usedTimes--,
                  0 === i.usedTimes && X(e),
                  0 === Object.keys(r).length && P.delete(n);
              }
              i.remove(e);
            })(t),
            t.isVideoTexture && C.delete(t);
        }
        function W(t) {
          const n = t.target;
          n.removeEventListener("dispose", W),
            (function (t) {
              const n = t.texture,
                r = i.get(t),
                s = i.get(n);
              if (
                (void 0 !== s.__webglTexture &&
                  (e.deleteTexture(s.__webglTexture), a.memory.textures--),
                t.depthTexture && t.depthTexture.dispose(),
                t.isWebGLCubeRenderTarget)
              )
                for (let t = 0; t < 6; t++)
                  e.deleteFramebuffer(r.__webglFramebuffer[t]),
                    r.__webglDepthbuffer &&
                      e.deleteRenderbuffer(r.__webglDepthbuffer[t]);
              else {
                if (
                  (e.deleteFramebuffer(r.__webglFramebuffer),
                  r.__webglDepthbuffer &&
                    e.deleteRenderbuffer(r.__webglDepthbuffer),
                  r.__webglMultisampledFramebuffer &&
                    e.deleteFramebuffer(r.__webglMultisampledFramebuffer),
                  r.__webglColorRenderbuffer)
                )
                  for (let t = 0; t < r.__webglColorRenderbuffer.length; t++)
                    r.__webglColorRenderbuffer[t] &&
                      e.deleteRenderbuffer(r.__webglColorRenderbuffer[t]);
                r.__webglDepthRenderbuffer &&
                  e.deleteRenderbuffer(r.__webglDepthRenderbuffer);
              }
              if (t.isWebGLMultipleRenderTargets)
                for (let t = 0, r = n.length; t < r; t++) {
                  const r = i.get(n[t]);
                  r.__webglTexture &&
                    (e.deleteTexture(r.__webglTexture), a.memory.textures--),
                    i.remove(n[t]);
                }
              i.remove(n), i.remove(t);
            })(n);
        }
        function X(t) {
          const n = i.get(t);
          e.deleteTexture(n.__webglTexture);
          const r = t.source;
          delete P.get(r)[n.__cacheKey], a.memory.textures--;
        }
        let Y = 0;
        function Z(e, t) {
          const r = i.get(e);
          if (
            (e.isVideoTexture &&
              (function (e) {
                const t = a.render.frame;
                C.get(e) !== t && (C.set(e, t), e.update());
              })(e),
            !1 === e.isRenderTargetTexture &&
              e.version > 0 &&
              r.__version !== e.version)
          ) {
            const n = e.image;
            if (null === n)
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but no image data found."
              );
            else {
              if (!1 !== n.complete) return void te(r, e, t);
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
              );
            }
          }
          n.activeTexture(33984 + t), n.bindTexture(3553, r.__webglTexture);
        }
        const K = { [u]: 10497, [h]: 33071, [d]: 33648 },
          J = {
            [p]: 9728,
            1004: 9984,
            1005: 9986,
            [f]: 9729,
            1007: 9985,
            [m]: 9987,
          };
        function Q(n, s, a) {
          if (
            (a
              ? (e.texParameteri(n, 10242, K[s.wrapS]),
                e.texParameteri(n, 10243, K[s.wrapT]),
                (32879 !== n && 35866 !== n) ||
                  e.texParameteri(n, 32882, K[s.wrapR]),
                e.texParameteri(n, 10240, J[s.magFilter]),
                e.texParameteri(n, 10241, J[s.minFilter]))
              : (e.texParameteri(n, 10242, 33071),
                e.texParameteri(n, 10243, 33071),
                (32879 !== n && 35866 !== n) ||
                  e.texParameteri(n, 32882, 33071),
                (s.wrapS === h && s.wrapT === h) ||
                  console.warn(
                    "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
                  ),
                e.texParameteri(n, 10240, G(s.magFilter)),
                e.texParameteri(n, 10241, G(s.minFilter)),
                s.minFilter !== p &&
                  s.minFilter !== f &&
                  console.warn(
                    "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
                  )),
            !0 === t.has("EXT_texture_filter_anisotropic"))
          ) {
            const a = t.get("EXT_texture_filter_anisotropic");
            if (s.type === _ && !1 === t.has("OES_texture_float_linear"))
              return;
            if (
              !1 === o &&
              s.type === x &&
              !1 === t.has("OES_texture_half_float_linear")
            )
              return;
            (s.anisotropy > 1 || i.get(s).__currentAnisotropy) &&
              (e.texParameterf(
                n,
                a.TEXTURE_MAX_ANISOTROPY_EXT,
                Math.min(s.anisotropy, r.getMaxAnisotropy())
              ),
              (i.get(s).__currentAnisotropy = s.anisotropy));
          }
        }
        function ee(t, n) {
          let i = !1;
          void 0 === t.__webglInit &&
            ((t.__webglInit = !0), n.addEventListener("dispose", H));
          const r = n.source;
          let s = P.get(r);
          void 0 === s && ((s = {}), P.set(r, s));
          const o = (function (e) {
            const t = [];
            return (
              t.push(e.wrapS),
              t.push(e.wrapT),
              t.push(e.magFilter),
              t.push(e.minFilter),
              t.push(e.anisotropy),
              t.push(e.internalFormat),
              t.push(e.format),
              t.push(e.type),
              t.push(e.generateMipmaps),
              t.push(e.premultiplyAlpha),
              t.push(e.flipY),
              t.push(e.unpackAlignment),
              t.push(e.encoding),
              t.join()
            );
          })(n);
          if (o !== t.__cacheKey) {
            void 0 === s[o] &&
              ((s[o] = { texture: e.createTexture(), usedTimes: 0 }),
              a.memory.textures++,
              (i = !0)),
              s[o].usedTimes++;
            const r = s[t.__cacheKey];
            void 0 !== r &&
              (s[t.__cacheKey].usedTimes--, 0 === r.usedTimes && X(n)),
              (t.__cacheKey = o),
              (t.__webglTexture = s[o].texture);
          }
          return i;
        }
        function te(t, i, r) {
          let a = 3553;
          i.isDataArrayTexture && (a = 35866), i.isData3DTexture && (a = 32879);
          const l = ee(t, i),
            c = i.source;
          if (
            (n.activeTexture(33984 + r),
            n.bindTexture(a, t.__webglTexture),
            c.version !== c.__currentVersion || !0 === l)
          ) {
            e.pixelStorei(37440, i.flipY),
              e.pixelStorei(37441, i.premultiplyAlpha),
              e.pixelStorei(3317, i.unpackAlignment),
              e.pixelStorei(37443, 0);
            const t =
              (function (e) {
                return (
                  !o &&
                  (e.wrapS !== h ||
                    e.wrapT !== h ||
                    (e.minFilter !== p && e.minFilter !== f))
                );
              })(i) && !1 === O(i.image);
            let r = F(i.image, t, !1, M);
            r = oe(i, r);
            const u = O(r) || o,
              d = s.convert(i.format, i.encoding);
            let m,
              g = s.convert(i.type),
              x = U(i.internalFormat, d, g, i.encoding, i.isVideoTexture);
            Q(a, i, u);
            const E = i.mipmaps,
              T = o && !0 !== i.isVideoTexture,
              A = void 0 === c.__currentVersion || !0 === l,
              C = V(i, r, u);
            if (i.isDepthTexture)
              (x = 6402),
                o
                  ? (x =
                      i.type === _
                        ? 36012
                        : i.type === v
                        ? 33190
                        : i.type === y
                        ? 35056
                        : 33189)
                  : i.type === _ &&
                    console.error(
                      "WebGLRenderer: Floating point depth texture requires WebGL2."
                    ),
                i.format === w &&
                  6402 === x &&
                  1012 !== i.type &&
                  i.type !== v &&
                  (console.warn(
                    "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
                  ),
                  (i.type = v),
                  (g = s.convert(i.type))),
                i.format === S &&
                  6402 === x &&
                  ((x = 34041),
                  i.type !== y &&
                    (console.warn(
                      "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                    ),
                    (i.type = y),
                    (g = s.convert(i.type)))),
                A &&
                  (T
                    ? n.texStorage2D(3553, 1, x, r.width, r.height)
                    : n.texImage2D(
                        3553,
                        0,
                        x,
                        r.width,
                        r.height,
                        0,
                        d,
                        g,
                        null
                      ));
            else if (i.isDataTexture)
              if (E.length > 0 && u) {
                T && A && n.texStorage2D(3553, C, x, E[0].width, E[0].height);
                for (let e = 0, t = E.length; e < t; e++)
                  (m = E[e]),
                    T
                      ? n.texSubImage2D(
                          3553,
                          e,
                          0,
                          0,
                          m.width,
                          m.height,
                          d,
                          g,
                          m.data
                        )
                      : n.texImage2D(
                          3553,
                          e,
                          x,
                          m.width,
                          m.height,
                          0,
                          d,
                          g,
                          m.data
                        );
                i.generateMipmaps = !1;
              } else
                T
                  ? (A && n.texStorage2D(3553, C, x, r.width, r.height),
                    n.texSubImage2D(
                      3553,
                      0,
                      0,
                      0,
                      r.width,
                      r.height,
                      d,
                      g,
                      r.data
                    ))
                  : n.texImage2D(
                      3553,
                      0,
                      x,
                      r.width,
                      r.height,
                      0,
                      d,
                      g,
                      r.data
                    );
            else if (i.isCompressedTexture) {
              T && A && n.texStorage2D(3553, C, x, E[0].width, E[0].height);
              for (let e = 0, t = E.length; e < t; e++)
                (m = E[e]),
                  i.format !== b
                    ? null !== d
                      ? T
                        ? n.compressedTexSubImage2D(
                            3553,
                            e,
                            0,
                            0,
                            m.width,
                            m.height,
                            d,
                            m.data
                          )
                        : n.compressedTexImage2D(
                            3553,
                            e,
                            x,
                            m.width,
                            m.height,
                            0,
                            m.data
                          )
                      : console.warn(
                          "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                        )
                    : T
                    ? n.texSubImage2D(
                        3553,
                        e,
                        0,
                        0,
                        m.width,
                        m.height,
                        d,
                        g,
                        m.data
                      )
                    : n.texImage2D(
                        3553,
                        e,
                        x,
                        m.width,
                        m.height,
                        0,
                        d,
                        g,
                        m.data
                      );
            } else if (i.isDataArrayTexture)
              T
                ? (A && n.texStorage3D(35866, C, x, r.width, r.height, r.depth),
                  n.texSubImage3D(
                    35866,
                    0,
                    0,
                    0,
                    0,
                    r.width,
                    r.height,
                    r.depth,
                    d,
                    g,
                    r.data
                  ))
                : n.texImage3D(
                    35866,
                    0,
                    x,
                    r.width,
                    r.height,
                    r.depth,
                    0,
                    d,
                    g,
                    r.data
                  );
            else if (i.isData3DTexture)
              T
                ? (A && n.texStorage3D(32879, C, x, r.width, r.height, r.depth),
                  n.texSubImage3D(
                    32879,
                    0,
                    0,
                    0,
                    0,
                    r.width,
                    r.height,
                    r.depth,
                    d,
                    g,
                    r.data
                  ))
                : n.texImage3D(
                    32879,
                    0,
                    x,
                    r.width,
                    r.height,
                    r.depth,
                    0,
                    d,
                    g,
                    r.data
                  );
            else if (i.isFramebufferTexture) {
              if (A)
                if (T) n.texStorage2D(3553, C, x, r.width, r.height);
                else {
                  let e = r.width,
                    t = r.height;
                  for (let i = 0; i < C; i++)
                    n.texImage2D(3553, i, x, e, t, 0, d, g, null),
                      (e >>= 1),
                      (t >>= 1);
                }
            } else if (E.length > 0 && u) {
              T && A && n.texStorage2D(3553, C, x, E[0].width, E[0].height);
              for (let e = 0, t = E.length; e < t; e++)
                (m = E[e]),
                  T
                    ? n.texSubImage2D(3553, e, 0, 0, d, g, m)
                    : n.texImage2D(3553, e, x, d, g, m);
              i.generateMipmaps = !1;
            } else
              T
                ? (A && n.texStorage2D(3553, C, x, r.width, r.height),
                  n.texSubImage2D(3553, 0, 0, 0, d, g, r))
                : n.texImage2D(3553, 0, x, d, g, r);
            z(i, u) && B(a),
              (c.__currentVersion = c.version),
              i.onUpdate && i.onUpdate(i);
          }
          t.__version = i.version;
        }
        function ne(t, r, a, o, l) {
          const c = s.convert(a.format, a.encoding),
            u = s.convert(a.type),
            h = U(a.internalFormat, c, u, a.encoding);
          i.get(r).__hasExternalTextures ||
            (32879 === l || 35866 === l
              ? n.texImage3D(l, 0, h, r.width, r.height, r.depth, 0, c, u, null)
              : n.texImage2D(l, 0, h, r.width, r.height, 0, c, u, null)),
            n.bindFramebuffer(36160, t),
            ae(r)
              ? T.framebufferTexture2DMultisampleEXT(
                  36160,
                  o,
                  l,
                  i.get(a).__webglTexture,
                  0,
                  se(r)
                )
              : e.framebufferTexture2D(36160, o, l, i.get(a).__webglTexture, 0),
            n.bindFramebuffer(36160, null);
        }
        function ie(t, n, i) {
          if (
            (e.bindRenderbuffer(36161, t), n.depthBuffer && !n.stencilBuffer)
          ) {
            let r = 33189;
            if (i || ae(n)) {
              const t = n.depthTexture;
              t &&
                t.isDepthTexture &&
                (t.type === _ ? (r = 36012) : t.type === v && (r = 33190));
              const i = se(n);
              ae(n)
                ? T.renderbufferStorageMultisampleEXT(
                    36161,
                    i,
                    r,
                    n.width,
                    n.height
                  )
                : e.renderbufferStorageMultisample(
                    36161,
                    i,
                    r,
                    n.width,
                    n.height
                  );
            } else e.renderbufferStorage(36161, r, n.width, n.height);
            e.framebufferRenderbuffer(36160, 36096, 36161, t);
          } else if (n.depthBuffer && n.stencilBuffer) {
            const r = se(n);
            i && !1 === ae(n)
              ? e.renderbufferStorageMultisample(
                  36161,
                  r,
                  35056,
                  n.width,
                  n.height
                )
              : ae(n)
              ? T.renderbufferStorageMultisampleEXT(
                  36161,
                  r,
                  35056,
                  n.width,
                  n.height
                )
              : e.renderbufferStorage(36161, 34041, n.width, n.height),
              e.framebufferRenderbuffer(36160, 33306, 36161, t);
          } else {
            const t =
              !0 === n.isWebGLMultipleRenderTargets ? n.texture : [n.texture];
            for (let r = 0; r < t.length; r++) {
              const a = t[r],
                o = s.convert(a.format, a.encoding),
                l = s.convert(a.type),
                c = U(a.internalFormat, o, l, a.encoding),
                u = se(n);
              i && !1 === ae(n)
                ? e.renderbufferStorageMultisample(
                    36161,
                    u,
                    c,
                    n.width,
                    n.height
                  )
                : ae(n)
                ? T.renderbufferStorageMultisampleEXT(
                    36161,
                    u,
                    c,
                    n.width,
                    n.height
                  )
                : e.renderbufferStorage(36161, c, n.width, n.height);
            }
          }
          e.bindRenderbuffer(36161, null);
        }
        function re(t) {
          const r = i.get(t),
            s = !0 === t.isWebGLCubeRenderTarget;
          if (t.depthTexture && !r.__autoAllocateDepthBuffer) {
            if (s)
              throw new Error(
                "target.depthTexture not supported in Cube render targets"
              );
            !(function (t, r) {
              if (r && r.isWebGLCubeRenderTarget)
                throw new Error(
                  "Depth Texture with cube render targets is not supported"
                );
              if (
                (n.bindFramebuffer(36160, t),
                !r.depthTexture || !r.depthTexture.isDepthTexture)
              )
                throw new Error(
                  "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
                );
              (i.get(r.depthTexture).__webglTexture &&
                r.depthTexture.image.width === r.width &&
                r.depthTexture.image.height === r.height) ||
                ((r.depthTexture.image.width = r.width),
                (r.depthTexture.image.height = r.height),
                (r.depthTexture.needsUpdate = !0)),
                Z(r.depthTexture, 0);
              const s = i.get(r.depthTexture).__webglTexture,
                a = se(r);
              if (r.depthTexture.format === w)
                ae(r)
                  ? T.framebufferTexture2DMultisampleEXT(
                      36160,
                      36096,
                      3553,
                      s,
                      0,
                      a
                    )
                  : e.framebufferTexture2D(36160, 36096, 3553, s, 0);
              else {
                if (r.depthTexture.format !== S)
                  throw new Error("Unknown depthTexture format");
                ae(r)
                  ? T.framebufferTexture2DMultisampleEXT(
                      36160,
                      33306,
                      3553,
                      s,
                      0,
                      a
                    )
                  : e.framebufferTexture2D(36160, 33306, 3553, s, 0);
              }
            })(r.__webglFramebuffer, t);
          } else if (s) {
            r.__webglDepthbuffer = [];
            for (let i = 0; i < 6; i++)
              n.bindFramebuffer(36160, r.__webglFramebuffer[i]),
                (r.__webglDepthbuffer[i] = e.createRenderbuffer()),
                ie(r.__webglDepthbuffer[i], t, !1);
          } else
            n.bindFramebuffer(36160, r.__webglFramebuffer),
              (r.__webglDepthbuffer = e.createRenderbuffer()),
              ie(r.__webglDepthbuffer, t, !1);
          n.bindFramebuffer(36160, null);
        }
        function se(e) {
          return Math.min(E, e.samples);
        }
        function ae(e) {
          const n = i.get(e);
          return (
            o &&
            e.samples > 0 &&
            !0 === t.has("WEBGL_multisampled_render_to_texture") &&
            !1 !== n.__useRenderToTexture
          );
        }
        function oe(e, n) {
          const i = e.encoding,
            r = e.format,
            s = e.type;
          return (
            !0 === e.isCompressedTexture ||
              !0 === e.isVideoTexture ||
              e.format === N ||
              (i !== D &&
                (i === k
                  ? !1 === o
                    ? !0 === t.has("EXT_sRGB") && r === b
                      ? ((e.format = N),
                        (e.minFilter = f),
                        (e.generateMipmaps = !1))
                      : (n = ce.sRGBToLinear(n))
                    : (r === b && s === g) ||
                      console.warn(
                        "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                      )
                  : console.error(
                      "THREE.WebGLTextures: Unsupported texture encoding:",
                      i
                    ))),
            n
          );
        }
        (this.allocateTextureUnit = function () {
          const e = Y;
          return (
            e >= l &&
              console.warn(
                "THREE.WebGLTextures: Trying to use " +
                  e +
                  " texture units while this GPU supports only " +
                  l
              ),
            (Y += 1),
            e
          );
        }),
          (this.resetTextureUnits = function () {
            Y = 0;
          }),
          (this.setTexture2D = Z),
          (this.setTexture2DArray = function (e, t) {
            const r = i.get(e);
            e.version > 0 && r.__version !== e.version
              ? te(r, e, t)
              : (n.activeTexture(33984 + t),
                n.bindTexture(35866, r.__webglTexture));
          }),
          (this.setTexture3D = function (e, t) {
            const r = i.get(e);
            e.version > 0 && r.__version !== e.version
              ? te(r, e, t)
              : (n.activeTexture(33984 + t),
                n.bindTexture(32879, r.__webglTexture));
          }),
          (this.setTextureCube = function (t, r) {
            const a = i.get(t);
            t.version > 0 && a.__version !== t.version
              ? (function (t, i, r) {
                  if (6 !== i.image.length) return;
                  const a = ee(t, i),
                    l = i.source;
                  if (
                    (n.activeTexture(33984 + r),
                    n.bindTexture(34067, t.__webglTexture),
                    l.version !== l.__currentVersion || !0 === a)
                  ) {
                    e.pixelStorei(37440, i.flipY),
                      e.pixelStorei(37441, i.premultiplyAlpha),
                      e.pixelStorei(3317, i.unpackAlignment),
                      e.pixelStorei(37443, 0);
                    const t =
                        i.isCompressedTexture || i.image[0].isCompressedTexture,
                      r = i.image[0] && i.image[0].isDataTexture,
                      u = [];
                    for (let e = 0; e < 6; e++)
                      (u[e] =
                        t || r
                          ? r
                            ? i.image[e].image
                            : i.image[e]
                          : F(i.image[e], !1, !0, c)),
                        (u[e] = oe(i, u[e]));
                    const h = u[0],
                      d = O(h) || o,
                      p = s.convert(i.format, i.encoding),
                      f = s.convert(i.type),
                      m = U(i.internalFormat, p, f, i.encoding),
                      g = o && !0 !== i.isVideoTexture,
                      v = void 0 === l.__currentVersion || !0 === a;
                    let _,
                      x = V(i, h, d);
                    if ((Q(34067, i, d), t)) {
                      g && v && n.texStorage2D(34067, x, m, h.width, h.height);
                      for (let e = 0; e < 6; e++) {
                        _ = u[e].mipmaps;
                        for (let t = 0; t < _.length; t++) {
                          const r = _[t];
                          i.format !== b
                            ? null !== p
                              ? g
                                ? n.compressedTexSubImage2D(
                                    34069 + e,
                                    t,
                                    0,
                                    0,
                                    r.width,
                                    r.height,
                                    p,
                                    r.data
                                  )
                                : n.compressedTexImage2D(
                                    34069 + e,
                                    t,
                                    m,
                                    r.width,
                                    r.height,
                                    0,
                                    r.data
                                  )
                              : console.warn(
                                  "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                                )
                            : g
                            ? n.texSubImage2D(
                                34069 + e,
                                t,
                                0,
                                0,
                                r.width,
                                r.height,
                                p,
                                f,
                                r.data
                              )
                            : n.texImage2D(
                                34069 + e,
                                t,
                                m,
                                r.width,
                                r.height,
                                0,
                                p,
                                f,
                                r.data
                              );
                        }
                      }
                    } else {
                      (_ = i.mipmaps),
                        g &&
                          v &&
                          (_.length > 0 && x++,
                          n.texStorage2D(34067, x, m, u[0].width, u[0].height));
                      for (let e = 0; e < 6; e++)
                        if (r) {
                          g
                            ? n.texSubImage2D(
                                34069 + e,
                                0,
                                0,
                                0,
                                u[e].width,
                                u[e].height,
                                p,
                                f,
                                u[e].data
                              )
                            : n.texImage2D(
                                34069 + e,
                                0,
                                m,
                                u[e].width,
                                u[e].height,
                                0,
                                p,
                                f,
                                u[e].data
                              );
                          for (let t = 0; t < _.length; t++) {
                            const i = _[t].image[e].image;
                            g
                              ? n.texSubImage2D(
                                  34069 + e,
                                  t + 1,
                                  0,
                                  0,
                                  i.width,
                                  i.height,
                                  p,
                                  f,
                                  i.data
                                )
                              : n.texImage2D(
                                  34069 + e,
                                  t + 1,
                                  m,
                                  i.width,
                                  i.height,
                                  0,
                                  p,
                                  f,
                                  i.data
                                );
                          }
                        } else {
                          g
                            ? n.texSubImage2D(34069 + e, 0, 0, 0, p, f, u[e])
                            : n.texImage2D(34069 + e, 0, m, p, f, u[e]);
                          for (let t = 0; t < _.length; t++) {
                            const i = _[t];
                            g
                              ? n.texSubImage2D(
                                  34069 + e,
                                  t + 1,
                                  0,
                                  0,
                                  p,
                                  f,
                                  i.image[e]
                                )
                              : n.texImage2D(
                                  34069 + e,
                                  t + 1,
                                  m,
                                  p,
                                  f,
                                  i.image[e]
                                );
                          }
                        }
                    }
                    z(i, d) && B(34067),
                      (l.__currentVersion = l.version),
                      i.onUpdate && i.onUpdate(i);
                  }
                  t.__version = i.version;
                })(a, t, r)
              : (n.activeTexture(33984 + r),
                n.bindTexture(34067, a.__webglTexture));
          }),
          (this.rebindTextures = function (e, t, n) {
            const r = i.get(e);
            void 0 !== t && ne(r.__webglFramebuffer, e, e.texture, 36064, 3553),
              void 0 !== n && re(e);
          }),
          (this.setupRenderTarget = function (t) {
            const l = t.texture,
              c = i.get(t),
              u = i.get(l);
            t.addEventListener("dispose", W),
              !0 !== t.isWebGLMultipleRenderTargets &&
                (void 0 === u.__webglTexture &&
                  (u.__webglTexture = e.createTexture()),
                (u.__version = l.version),
                a.memory.textures++);
            const h = !0 === t.isWebGLCubeRenderTarget,
              d = !0 === t.isWebGLMultipleRenderTargets,
              p = O(t) || o;
            if (h) {
              c.__webglFramebuffer = [];
              for (let t = 0; t < 6; t++)
                c.__webglFramebuffer[t] = e.createFramebuffer();
            } else {
              if (((c.__webglFramebuffer = e.createFramebuffer()), d))
                if (r.drawBuffers) {
                  const n = t.texture;
                  for (let t = 0, r = n.length; t < r; t++) {
                    const r = i.get(n[t]);
                    void 0 === r.__webglTexture &&
                      ((r.__webglTexture = e.createTexture()),
                      a.memory.textures++);
                  }
                } else
                  console.warn(
                    "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
                  );
              if (o && t.samples > 0 && !1 === ae(t)) {
                const i = d ? l : [l];
                (c.__webglMultisampledFramebuffer = e.createFramebuffer()),
                  (c.__webglColorRenderbuffer = []),
                  n.bindFramebuffer(36160, c.__webglMultisampledFramebuffer);
                for (let n = 0; n < i.length; n++) {
                  const r = i[n];
                  (c.__webglColorRenderbuffer[n] = e.createRenderbuffer()),
                    e.bindRenderbuffer(36161, c.__webglColorRenderbuffer[n]);
                  const a = s.convert(r.format, r.encoding),
                    o = s.convert(r.type),
                    l = U(r.internalFormat, a, o, r.encoding),
                    u = se(t);
                  e.renderbufferStorageMultisample(
                    36161,
                    u,
                    l,
                    t.width,
                    t.height
                  ),
                    e.framebufferRenderbuffer(
                      36160,
                      36064 + n,
                      36161,
                      c.__webglColorRenderbuffer[n]
                    );
                }
                e.bindRenderbuffer(36161, null),
                  t.depthBuffer &&
                    ((c.__webglDepthRenderbuffer = e.createRenderbuffer()),
                    ie(c.__webglDepthRenderbuffer, t, !0)),
                  n.bindFramebuffer(36160, null);
              }
            }
            if (h) {
              n.bindTexture(34067, u.__webglTexture), Q(34067, l, p);
              for (let e = 0; e < 6; e++)
                ne(c.__webglFramebuffer[e], t, l, 36064, 34069 + e);
              z(l, p) && B(34067), n.unbindTexture();
            } else if (d) {
              const e = t.texture;
              for (let r = 0, s = e.length; r < s; r++) {
                const s = e[r],
                  a = i.get(s);
                n.bindTexture(3553, a.__webglTexture),
                  Q(3553, s, p),
                  ne(c.__webglFramebuffer, t, s, 36064 + r, 3553),
                  z(s, p) && B(3553);
              }
              n.unbindTexture();
            } else {
              let e = 3553;
              (t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) &&
                (o
                  ? (e = t.isWebGL3DRenderTarget ? 32879 : 35866)
                  : console.error(
                      "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2."
                    )),
                n.bindTexture(e, u.__webglTexture),
                Q(e, l, p),
                ne(c.__webglFramebuffer, t, l, 36064, e),
                z(l, p) && B(e),
                n.unbindTexture();
            }
            t.depthBuffer && re(t);
          }),
          (this.updateRenderTargetMipmap = function (e) {
            const t = O(e) || o,
              r =
                !0 === e.isWebGLMultipleRenderTargets ? e.texture : [e.texture];
            for (let s = 0, a = r.length; s < a; s++) {
              const a = r[s];
              if (z(a, t)) {
                const t = e.isWebGLCubeRenderTarget ? 34067 : 3553,
                  r = i.get(a).__webglTexture;
                n.bindTexture(t, r), B(t), n.unbindTexture();
              }
            }
          }),
          (this.updateMultisampleRenderTarget = function (t) {
            if (o && t.samples > 0 && !1 === ae(t)) {
              const r = t.isWebGLMultipleRenderTargets
                  ? t.texture
                  : [t.texture],
                s = t.width,
                a = t.height;
              let o = 16384;
              const l = [],
                c = t.stencilBuffer ? 33306 : 36096,
                u = i.get(t),
                h = !0 === t.isWebGLMultipleRenderTargets;
              if (h)
                for (let t = 0; t < r.length; t++)
                  n.bindFramebuffer(36160, u.__webglMultisampledFramebuffer),
                    e.framebufferRenderbuffer(36160, 36064 + t, 36161, null),
                    n.bindFramebuffer(36160, u.__webglFramebuffer),
                    e.framebufferTexture2D(36009, 36064 + t, 3553, null, 0);
              n.bindFramebuffer(36008, u.__webglMultisampledFramebuffer),
                n.bindFramebuffer(36009, u.__webglFramebuffer);
              for (let n = 0; n < r.length; n++) {
                l.push(36064 + n), t.depthBuffer && l.push(c);
                const d =
                  void 0 !== u.__ignoreDepthValues && u.__ignoreDepthValues;
                if (
                  (!1 === d &&
                    (t.depthBuffer && (o |= 256),
                    t.stencilBuffer && (o |= 1024)),
                  h &&
                    e.framebufferRenderbuffer(
                      36008,
                      36064,
                      36161,
                      u.__webglColorRenderbuffer[n]
                    ),
                  !0 === d &&
                    (e.invalidateFramebuffer(36008, [c]),
                    e.invalidateFramebuffer(36009, [c])),
                  h)
                ) {
                  const t = i.get(r[n]).__webglTexture;
                  e.framebufferTexture2D(36009, 36064, 3553, t, 0);
                }
                e.blitFramebuffer(0, 0, s, a, 0, 0, s, a, o, 9728),
                  A && e.invalidateFramebuffer(36008, l);
              }
              if (
                (n.bindFramebuffer(36008, null),
                n.bindFramebuffer(36009, null),
                h)
              )
                for (let t = 0; t < r.length; t++) {
                  n.bindFramebuffer(36160, u.__webglMultisampledFramebuffer),
                    e.framebufferRenderbuffer(
                      36160,
                      36064 + t,
                      36161,
                      u.__webglColorRenderbuffer[t]
                    );
                  const s = i.get(r[t]).__webglTexture;
                  n.bindFramebuffer(36160, u.__webglFramebuffer),
                    e.framebufferTexture2D(36009, 36064 + t, 3553, s, 0);
                }
              n.bindFramebuffer(36009, u.__webglMultisampledFramebuffer);
            }
          }),
          (this.setupDepthRenderbuffer = re),
          (this.setupFrameBufferTexture = ne),
          (this.useMultisampledRTT = ae);
      }
      function is(e, t, n) {
        const i = n.isWebGL2;
        return {
          convert: function (n, r = null) {
            let s;
            if (n === g) return 5121;
            if (1017 === n) return 32819;
            if (1018 === n) return 32820;
            if (1010 === n) return 5120;
            if (1011 === n) return 5122;
            if (1012 === n) return 5123;
            if (1013 === n) return 5124;
            if (n === v) return 5125;
            if (n === _) return 5126;
            if (n === x)
              return i
                ? 5131
                : ((s = t.get("OES_texture_half_float")),
                  null !== s ? s.HALF_FLOAT_OES : null);
            if (1021 === n) return 6406;
            if (n === b) return 6408;
            if (1024 === n) return 6409;
            if (1025 === n) return 6410;
            if (n === w) return 6402;
            if (n === S) return 34041;
            if (1028 === n) return 6403;
            if (1022 === n)
              return (
                console.warn(
                  "THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"
                ),
                6408
              );
            if (n === N)
              return (
                (s = t.get("EXT_sRGB")), null !== s ? s.SRGB_ALPHA_EXT : null
              );
            if (1029 === n) return 36244;
            if (1030 === n) return 33319;
            if (1031 === n) return 33320;
            if (1033 === n) return 36249;
            if (n === M || n === E || n === T || n === A)
              if (r === k) {
                if (
                  ((s = t.get("WEBGL_compressed_texture_s3tc_srgb")),
                  null === s)
                )
                  return null;
                if (n === M) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                if (n === E) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                if (n === T) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                if (n === A) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
              } else {
                if (((s = t.get("WEBGL_compressed_texture_s3tc")), null === s))
                  return null;
                if (n === M) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (n === E) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (n === T) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (n === A) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT;
              }
            if (35840 === n || 35841 === n || 35842 === n || 35843 === n) {
              if (((s = t.get("WEBGL_compressed_texture_pvrtc")), null === s))
                return null;
              if (35840 === n) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
              if (35841 === n) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
              if (35842 === n) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
              if (35843 === n) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            }
            if (36196 === n)
              return (
                (s = t.get("WEBGL_compressed_texture_etc1")),
                null !== s ? s.COMPRESSED_RGB_ETC1_WEBGL : null
              );
            if (37492 === n || 37496 === n) {
              if (((s = t.get("WEBGL_compressed_texture_etc")), null === s))
                return null;
              if (37492 === n)
                return r === k
                  ? s.COMPRESSED_SRGB8_ETC2
                  : s.COMPRESSED_RGB8_ETC2;
              if (37496 === n)
                return r === k
                  ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
                  : s.COMPRESSED_RGBA8_ETC2_EAC;
            }
            if (
              37808 === n ||
              37809 === n ||
              37810 === n ||
              37811 === n ||
              37812 === n ||
              37813 === n ||
              37814 === n ||
              37815 === n ||
              37816 === n ||
              37817 === n ||
              37818 === n ||
              37819 === n ||
              37820 === n ||
              37821 === n
            ) {
              if (((s = t.get("WEBGL_compressed_texture_astc")), null === s))
                return null;
              if (37808 === n)
                return r === k
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
                  : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
              if (37809 === n)
                return r === k
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
                  : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
              if (37810 === n)
                return r === k
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
                  : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
              if (37811 === n)
                return r === k
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
                  : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
              if (37812 === n)
                return r === k
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
                  : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
              if (37813 === n)
                return r === k
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
                  : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
              if (37814 === n)
                return r === k
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
                  : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
              if (37815 === n)
                return r === k
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
                  : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
              if (37816 === n)
                return r === k
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
                  : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
              if (37817 === n)
                return r === k
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
                  : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
              if (37818 === n)
                return r === k
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
                  : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
              if (37819 === n)
                return r === k
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
                  : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
              if (37820 === n)
                return r === k
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
                  : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
              if (37821 === n)
                return r === k
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
                  : s.COMPRESSED_RGBA_ASTC_12x12_KHR;
            }
            if (36492 === n) {
              if (((s = t.get("EXT_texture_compression_bptc")), null === s))
                return null;
              if (36492 === n)
                return r === k
                  ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
                  : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
            }
            return n === y
              ? i
                ? 34042
                : ((s = t.get("WEBGL_depth_texture")),
                  null !== s ? s.UNSIGNED_INT_24_8_WEBGL : null)
              : void 0 !== e[n]
              ? e[n]
              : null;
          },
        };
      }
      class rs extends wn {
        constructor(e = []) {
          super(), (this.isArrayCamera = !0), (this.cameras = e);
        }
      }
      class ss extends bt {
        constructor() {
          super(), (this.isGroup = !0), (this.type = "Group");
        }
      }
      const as = { type: "move" };
      class os {
        constructor() {
          (this._targetRay = null), (this._grip = null), (this._hand = null);
        }
        getHandSpace() {
          return (
            null === this._hand &&
              ((this._hand = new ss()),
              (this._hand.matrixAutoUpdate = !1),
              (this._hand.visible = !1),
              (this._hand.joints = {}),
              (this._hand.inputState = { pinching: !1 })),
            this._hand
          );
        }
        getTargetRaySpace() {
          return (
            null === this._targetRay &&
              ((this._targetRay = new ss()),
              (this._targetRay.matrixAutoUpdate = !1),
              (this._targetRay.visible = !1),
              (this._targetRay.hasLinearVelocity = !1),
              (this._targetRay.linearVelocity = new xe()),
              (this._targetRay.hasAngularVelocity = !1),
              (this._targetRay.angularVelocity = new xe())),
            this._targetRay
          );
        }
        getGripSpace() {
          return (
            null === this._grip &&
              ((this._grip = new ss()),
              (this._grip.matrixAutoUpdate = !1),
              (this._grip.visible = !1),
              (this._grip.hasLinearVelocity = !1),
              (this._grip.linearVelocity = new xe()),
              (this._grip.hasAngularVelocity = !1),
              (this._grip.angularVelocity = new xe())),
            this._grip
          );
        }
        dispatchEvent(e) {
          return (
            null !== this._targetRay && this._targetRay.dispatchEvent(e),
            null !== this._grip && this._grip.dispatchEvent(e),
            null !== this._hand && this._hand.dispatchEvent(e),
            this
          );
        }
        disconnect(e) {
          return (
            this.dispatchEvent({ type: "disconnected", data: e }),
            null !== this._targetRay && (this._targetRay.visible = !1),
            null !== this._grip && (this._grip.visible = !1),
            null !== this._hand && (this._hand.visible = !1),
            this
          );
        }
        update(e, t, n) {
          let i = null,
            r = null,
            s = null;
          const a = this._targetRay,
            o = this._grip,
            l = this._hand;
          if (e && "visible-blurred" !== t.session.visibilityState) {
            if (l && e.hand) {
              s = !0;
              for (const i of e.hand.values()) {
                const e = t.getJointPose(i, n);
                if (void 0 === l.joints[i.jointName]) {
                  const e = new ss();
                  (e.matrixAutoUpdate = !1),
                    (e.visible = !1),
                    (l.joints[i.jointName] = e),
                    l.add(e);
                }
                const r = l.joints[i.jointName];
                null !== e &&
                  (r.matrix.fromArray(e.transform.matrix),
                  r.matrix.decompose(r.position, r.rotation, r.scale),
                  (r.jointRadius = e.radius)),
                  (r.visible = null !== e);
              }
              const i = l.joints["index-finger-tip"],
                r = l.joints["thumb-tip"],
                a = i.position.distanceTo(r.position),
                o = 0.02,
                c = 0.005;
              l.inputState.pinching && a > o + c
                ? ((l.inputState.pinching = !1),
                  this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this,
                  }))
                : !l.inputState.pinching &&
                  a <= o - c &&
                  ((l.inputState.pinching = !0),
                  this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this,
                  }));
            } else
              null !== o &&
                e.gripSpace &&
                ((r = t.getPose(e.gripSpace, n)),
                null !== r &&
                  (o.matrix.fromArray(r.transform.matrix),
                  o.matrix.decompose(o.position, o.rotation, o.scale),
                  r.linearVelocity
                    ? ((o.hasLinearVelocity = !0),
                      o.linearVelocity.copy(r.linearVelocity))
                    : (o.hasLinearVelocity = !1),
                  r.angularVelocity
                    ? ((o.hasAngularVelocity = !0),
                      o.angularVelocity.copy(r.angularVelocity))
                    : (o.hasAngularVelocity = !1)));
            null !== a &&
              ((i = t.getPose(e.targetRaySpace, n)),
              null === i && null !== r && (i = r),
              null !== i &&
                (a.matrix.fromArray(i.transform.matrix),
                a.matrix.decompose(a.position, a.rotation, a.scale),
                i.linearVelocity
                  ? ((a.hasLinearVelocity = !0),
                    a.linearVelocity.copy(i.linearVelocity))
                  : (a.hasLinearVelocity = !1),
                i.angularVelocity
                  ? ((a.hasAngularVelocity = !0),
                    a.angularVelocity.copy(i.angularVelocity))
                  : (a.hasAngularVelocity = !1),
                this.dispatchEvent(as)));
          }
          return (
            null !== a && (a.visible = null !== i),
            null !== o && (o.visible = null !== r),
            null !== l && (l.visible = null !== s),
            this
          );
        }
      }
      class ls extends pe {
        constructor(e, t, n, i, r, s, a, o, l, c) {
          if ((c = void 0 !== c ? c : w) !== w && c !== S)
            throw new Error(
              "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
            );
          void 0 === n && c === w && (n = v),
            void 0 === n && c === S && (n = y),
            super(null, i, r, s, a, o, c, n, l),
            (this.isDepthTexture = !0),
            (this.image = { width: e, height: t }),
            (this.magFilter = void 0 !== a ? a : p),
            (this.minFilter = void 0 !== o ? o : p),
            (this.flipY = !1),
            (this.generateMipmaps = !1);
        }
      }
      class cs extends z {
        constructor(e, t) {
          super();
          const n = this;
          let i = null,
            r = 1,
            s = null,
            a = "local-floor",
            o = null,
            l = null,
            c = null,
            u = null,
            h = null,
            d = null;
          const p = t.getContextAttributes();
          let f = null,
            m = null;
          const _ = [],
            x = [],
            M = new wn();
          M.layers.enable(1), (M.viewport = new fe());
          const E = new wn();
          E.layers.enable(2), (E.viewport = new fe());
          const T = [M, E],
            A = new rs();
          A.layers.enable(1), A.layers.enable(2);
          let C = null,
            L = null;
          function P(e) {
            const t = x.indexOf(e.inputSource);
            if (-1 === t) return;
            const n = _[t];
            void 0 !== n &&
              n.dispatchEvent({ type: e.type, data: e.inputSource });
          }
          function D() {
            i.removeEventListener("select", P),
              i.removeEventListener("selectstart", P),
              i.removeEventListener("selectend", P),
              i.removeEventListener("squeeze", P),
              i.removeEventListener("squeezestart", P),
              i.removeEventListener("squeezeend", P),
              i.removeEventListener("end", D),
              i.removeEventListener("inputsourceschange", k);
            for (let e = 0; e < _.length; e++) {
              const t = x[e];
              null !== t && ((x[e] = null), _[e].disconnect(t));
            }
            (C = null),
              (L = null),
              e.setRenderTarget(f),
              (h = null),
              (u = null),
              (c = null),
              (i = null),
              (m = null),
              N.stop(),
              (n.isPresenting = !1),
              n.dispatchEvent({ type: "sessionend" });
          }
          function k(e) {
            for (let t = 0; t < e.removed.length; t++) {
              const n = e.removed[t],
                i = x.indexOf(n);
              i >= 0 &&
                ((x[i] = null),
                _[i].dispatchEvent({ type: "disconnected", data: n }));
            }
            for (let t = 0; t < e.added.length; t++) {
              const n = e.added[t];
              let i = x.indexOf(n);
              if (-1 === i) {
                for (let e = 0; e < _.length; e++) {
                  if (e >= x.length) {
                    x.push(n), (i = e);
                    break;
                  }
                  if (null === x[e]) {
                    (x[e] = n), (i = e);
                    break;
                  }
                }
                if (-1 === i) break;
              }
              const r = _[i];
              r && r.dispatchEvent({ type: "connected", data: n });
            }
          }
          (this.cameraAutoUpdate = !0),
            (this.enabled = !1),
            (this.isPresenting = !1),
            (this.getController = function (e) {
              let t = _[e];
              return (
                void 0 === t && ((t = new os()), (_[e] = t)),
                t.getTargetRaySpace()
              );
            }),
            (this.getControllerGrip = function (e) {
              let t = _[e];
              return (
                void 0 === t && ((t = new os()), (_[e] = t)), t.getGripSpace()
              );
            }),
            (this.getHand = function (e) {
              let t = _[e];
              return (
                void 0 === t && ((t = new os()), (_[e] = t)), t.getHandSpace()
              );
            }),
            (this.setFramebufferScaleFactor = function (e) {
              (r = e),
                !0 === n.isPresenting &&
                  console.warn(
                    "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
                  );
            }),
            (this.setReferenceSpaceType = function (e) {
              (a = e),
                !0 === n.isPresenting &&
                  console.warn(
                    "THREE.WebXRManager: Cannot change reference space type while presenting."
                  );
            }),
            (this.getReferenceSpace = function () {
              return o || s;
            }),
            (this.setReferenceSpace = function (e) {
              o = e;
            }),
            (this.getBaseLayer = function () {
              return null !== u ? u : h;
            }),
            (this.getBinding = function () {
              return c;
            }),
            (this.getFrame = function () {
              return d;
            }),
            (this.getSession = function () {
              return i;
            }),
            (this.setSession = async function (l) {
              if (((i = l), null !== i)) {
                if (
                  ((f = e.getRenderTarget()),
                  i.addEventListener("select", P),
                  i.addEventListener("selectstart", P),
                  i.addEventListener("selectend", P),
                  i.addEventListener("squeeze", P),
                  i.addEventListener("squeezestart", P),
                  i.addEventListener("squeezeend", P),
                  i.addEventListener("end", D),
                  i.addEventListener("inputsourceschange", k),
                  !0 !== p.xrCompatible && (await t.makeXRCompatible()),
                  void 0 === i.renderState.layers ||
                    !1 === e.capabilities.isWebGL2)
                ) {
                  const n = {
                    antialias: void 0 !== i.renderState.layers || p.antialias,
                    alpha: p.alpha,
                    depth: p.depth,
                    stencil: p.stencil,
                    framebufferScaleFactor: r,
                  };
                  (h = new XRWebGLLayer(i, t, n)),
                    i.updateRenderState({ baseLayer: h }),
                    (m = new me(h.framebufferWidth, h.framebufferHeight, {
                      format: b,
                      type: g,
                      encoding: e.outputEncoding,
                    }));
                } else {
                  let n = null,
                    s = null,
                    a = null;
                  p.depth &&
                    ((a = p.stencil ? 35056 : 33190),
                    (n = p.stencil ? S : w),
                    (s = p.stencil ? y : v));
                  const o = {
                    colorFormat: 32856,
                    depthFormat: a,
                    scaleFactor: r,
                  };
                  (c = new XRWebGLBinding(i, t)),
                    (u = c.createProjectionLayer(o)),
                    i.updateRenderState({ layers: [u] }),
                    (m = new me(u.textureWidth, u.textureHeight, {
                      format: b,
                      type: g,
                      depthTexture: new ls(
                        u.textureWidth,
                        u.textureHeight,
                        s,
                        void 0,
                        void 0,
                        void 0,
                        void 0,
                        void 0,
                        void 0,
                        n
                      ),
                      stencilBuffer: p.stencil,
                      encoding: e.outputEncoding,
                      samples: p.antialias ? 4 : 0,
                    })),
                    (e.properties.get(m).__ignoreDepthValues =
                      u.ignoreDepthValues);
                }
                (m.isXRRenderTarget = !0),
                  this.setFoveation(1),
                  (o = null),
                  (s = await i.requestReferenceSpace(a)),
                  N.setContext(i),
                  N.start(),
                  (n.isPresenting = !0),
                  n.dispatchEvent({ type: "sessionstart" });
              }
            });
          const R = new xe(),
            I = new xe();
          function F(e, t) {
            null === t
              ? e.matrixWorld.copy(e.matrix)
              : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix),
              e.matrixWorldInverse.copy(e.matrixWorld).invert();
          }
          (this.updateCamera = function (e) {
            if (null === i) return;
            (A.near = E.near = M.near = e.near),
              (A.far = E.far = M.far = e.far),
              (C === A.near && L === A.far) ||
                (i.updateRenderState({ depthNear: A.near, depthFar: A.far }),
                (C = A.near),
                (L = A.far));
            const t = e.parent,
              n = A.cameras;
            F(A, t);
            for (let e = 0; e < n.length; e++) F(n[e], t);
            A.matrixWorld.decompose(A.position, A.quaternion, A.scale),
              e.position.copy(A.position),
              e.quaternion.copy(A.quaternion),
              e.scale.copy(A.scale),
              e.matrix.copy(A.matrix),
              e.matrixWorld.copy(A.matrixWorld);
            const r = e.children;
            for (let e = 0, t = r.length; e < t; e++)
              r[e].updateMatrixWorld(!0);
            2 === n.length
              ? (function (e, t, n) {
                  R.setFromMatrixPosition(t.matrixWorld),
                    I.setFromMatrixPosition(n.matrixWorld);
                  const i = R.distanceTo(I),
                    r = t.projectionMatrix.elements,
                    s = n.projectionMatrix.elements,
                    a = r[14] / (r[10] - 1),
                    o = r[14] / (r[10] + 1),
                    l = (r[9] + 1) / r[5],
                    c = (r[9] - 1) / r[5],
                    u = (r[8] - 1) / r[0],
                    h = (s[8] + 1) / s[0],
                    d = a * u,
                    p = a * h,
                    f = i / (-u + h),
                    m = f * -u;
                  t.matrixWorld.decompose(e.position, e.quaternion, e.scale),
                    e.translateX(m),
                    e.translateZ(f),
                    e.matrixWorld.compose(e.position, e.quaternion, e.scale),
                    e.matrixWorldInverse.copy(e.matrixWorld).invert();
                  const g = a + f,
                    v = o + f,
                    _ = d - m,
                    x = p + (i - m),
                    y = ((l * o) / v) * g,
                    b = ((c * o) / v) * g;
                  e.projectionMatrix.makePerspective(_, x, y, b, g, v);
                })(A, M, E)
              : A.projectionMatrix.copy(M.projectionMatrix);
          }),
            (this.getCamera = function () {
              return A;
            }),
            (this.getFoveation = function () {
              return null !== u
                ? u.fixedFoveation
                : null !== h
                ? h.fixedFoveation
                : void 0;
            }),
            (this.setFoveation = function (e) {
              null !== u && (u.fixedFoveation = e),
                null !== h &&
                  void 0 !== h.fixedFoveation &&
                  (h.fixedFoveation = e);
            });
          let O = null;
          const N = new In();
          N.setAnimationLoop(function (t, n) {
            if (((l = n.getViewerPose(o || s)), (d = n), null !== l)) {
              const t = l.views;
              null !== h &&
                (e.setRenderTargetFramebuffer(m, h.framebuffer),
                e.setRenderTarget(m));
              let n = !1;
              t.length !== A.cameras.length &&
                ((A.cameras.length = 0), (n = !0));
              for (let i = 0; i < t.length; i++) {
                const r = t[i];
                let s = null;
                if (null !== h) s = h.getViewport(r);
                else {
                  const t = c.getViewSubImage(u, r);
                  (s = t.viewport),
                    0 === i &&
                      (e.setRenderTargetTextures(
                        m,
                        t.colorTexture,
                        u.ignoreDepthValues ? void 0 : t.depthStencilTexture
                      ),
                      e.setRenderTarget(m));
                }
                let a = T[i];
                void 0 === a &&
                  ((a = new wn()),
                  a.layers.enable(i),
                  (a.viewport = new fe()),
                  (T[i] = a)),
                  a.matrix.fromArray(r.transform.matrix),
                  a.projectionMatrix.fromArray(r.projectionMatrix),
                  a.viewport.set(s.x, s.y, s.width, s.height),
                  0 === i && A.matrix.copy(a.matrix),
                  !0 === n && A.cameras.push(a);
              }
            }
            for (let e = 0; e < _.length; e++) {
              const t = x[e],
                i = _[e];
              null !== t && void 0 !== i && i.update(t, n, o || s);
            }
            O && O(t, n), (d = null);
          }),
            (this.setAnimationLoop = function (e) {
              O = e;
            }),
            (this.dispose = function () {});
        }
      }
      function us(e, t) {
        function n(n, i) {
          (n.opacity.value = i.opacity),
            i.color && n.diffuse.value.copy(i.color),
            i.emissive &&
              n.emissive.value
                .copy(i.emissive)
                .multiplyScalar(i.emissiveIntensity),
            i.map && (n.map.value = i.map),
            i.alphaMap && (n.alphaMap.value = i.alphaMap),
            i.bumpMap &&
              ((n.bumpMap.value = i.bumpMap),
              (n.bumpScale.value = i.bumpScale),
              1 === i.side && (n.bumpScale.value *= -1)),
            i.displacementMap &&
              ((n.displacementMap.value = i.displacementMap),
              (n.displacementScale.value = i.displacementScale),
              (n.displacementBias.value = i.displacementBias)),
            i.emissiveMap && (n.emissiveMap.value = i.emissiveMap),
            i.normalMap &&
              ((n.normalMap.value = i.normalMap),
              n.normalScale.value.copy(i.normalScale),
              1 === i.side && n.normalScale.value.negate()),
            i.specularMap && (n.specularMap.value = i.specularMap),
            i.alphaTest > 0 && (n.alphaTest.value = i.alphaTest);
          const r = t.get(i).envMap;
          if (
            (r &&
              ((n.envMap.value = r),
              (n.flipEnvMap.value =
                r.isCubeTexture && !1 === r.isRenderTargetTexture ? -1 : 1),
              (n.reflectivity.value = i.reflectivity),
              (n.ior.value = i.ior),
              (n.refractionRatio.value = i.refractionRatio)),
            i.lightMap)
          ) {
            n.lightMap.value = i.lightMap;
            const t = !0 !== e.physicallyCorrectLights ? Math.PI : 1;
            n.lightMapIntensity.value = i.lightMapIntensity * t;
          }
          let s, a;
          i.aoMap &&
            ((n.aoMap.value = i.aoMap),
            (n.aoMapIntensity.value = i.aoMapIntensity)),
            i.map
              ? (s = i.map)
              : i.specularMap
              ? (s = i.specularMap)
              : i.displacementMap
              ? (s = i.displacementMap)
              : i.normalMap
              ? (s = i.normalMap)
              : i.bumpMap
              ? (s = i.bumpMap)
              : i.roughnessMap
              ? (s = i.roughnessMap)
              : i.metalnessMap
              ? (s = i.metalnessMap)
              : i.alphaMap
              ? (s = i.alphaMap)
              : i.emissiveMap
              ? (s = i.emissiveMap)
              : i.clearcoatMap
              ? (s = i.clearcoatMap)
              : i.clearcoatNormalMap
              ? (s = i.clearcoatNormalMap)
              : i.clearcoatRoughnessMap
              ? (s = i.clearcoatRoughnessMap)
              : i.iridescenceMap
              ? (s = i.iridescenceMap)
              : i.iridescenceThicknessMap
              ? (s = i.iridescenceThicknessMap)
              : i.specularIntensityMap
              ? (s = i.specularIntensityMap)
              : i.specularColorMap
              ? (s = i.specularColorMap)
              : i.transmissionMap
              ? (s = i.transmissionMap)
              : i.thicknessMap
              ? (s = i.thicknessMap)
              : i.sheenColorMap
              ? (s = i.sheenColorMap)
              : i.sheenRoughnessMap && (s = i.sheenRoughnessMap),
            void 0 !== s &&
              (s.isWebGLRenderTarget && (s = s.texture),
              !0 === s.matrixAutoUpdate && s.updateMatrix(),
              n.uvTransform.value.copy(s.matrix)),
            i.aoMap ? (a = i.aoMap) : i.lightMap && (a = i.lightMap),
            void 0 !== a &&
              (a.isWebGLRenderTarget && (a = a.texture),
              !0 === a.matrixAutoUpdate && a.updateMatrix(),
              n.uv2Transform.value.copy(a.matrix));
        }
        return {
          refreshFogUniforms: function (e, t) {
            e.fogColor.value.copy(t.color),
              t.isFog
                ? ((e.fogNear.value = t.near), (e.fogFar.value = t.far))
                : t.isFogExp2 && (e.fogDensity.value = t.density);
          },
          refreshMaterialUniforms: function (e, i, r, s, a) {
            i.isMeshBasicMaterial || i.isMeshLambertMaterial
              ? n(e, i)
              : i.isMeshToonMaterial
              ? (n(e, i),
                (function (e, t) {
                  t.gradientMap && (e.gradientMap.value = t.gradientMap);
                })(e, i))
              : i.isMeshPhongMaterial
              ? (n(e, i),
                (function (e, t) {
                  e.specular.value.copy(t.specular),
                    (e.shininess.value = Math.max(t.shininess, 1e-4));
                })(e, i))
              : i.isMeshStandardMaterial
              ? (n(e, i),
                (function (e, n) {
                  (e.roughness.value = n.roughness),
                    (e.metalness.value = n.metalness),
                    n.roughnessMap && (e.roughnessMap.value = n.roughnessMap),
                    n.metalnessMap && (e.metalnessMap.value = n.metalnessMap),
                    t.get(n).envMap &&
                      (e.envMapIntensity.value = n.envMapIntensity);
                })(e, i),
                i.isMeshPhysicalMaterial &&
                  (function (e, t, n) {
                    (e.ior.value = t.ior),
                      t.sheen > 0 &&
                        (e.sheenColor.value
                          .copy(t.sheenColor)
                          .multiplyScalar(t.sheen),
                        (e.sheenRoughness.value = t.sheenRoughness),
                        t.sheenColorMap &&
                          (e.sheenColorMap.value = t.sheenColorMap),
                        t.sheenRoughnessMap &&
                          (e.sheenRoughnessMap.value = t.sheenRoughnessMap)),
                      t.clearcoat > 0 &&
                        ((e.clearcoat.value = t.clearcoat),
                        (e.clearcoatRoughness.value = t.clearcoatRoughness),
                        t.clearcoatMap &&
                          (e.clearcoatMap.value = t.clearcoatMap),
                        t.clearcoatRoughnessMap &&
                          (e.clearcoatRoughnessMap.value =
                            t.clearcoatRoughnessMap),
                        t.clearcoatNormalMap &&
                          (e.clearcoatNormalScale.value.copy(
                            t.clearcoatNormalScale
                          ),
                          (e.clearcoatNormalMap.value = t.clearcoatNormalMap),
                          1 === t.side &&
                            e.clearcoatNormalScale.value.negate())),
                      t.iridescence > 0 &&
                        ((e.iridescence.value = t.iridescence),
                        (e.iridescenceIOR.value = t.iridescenceIOR),
                        (e.iridescenceThicknessMinimum.value =
                          t.iridescenceThicknessRange[0]),
                        (e.iridescenceThicknessMaximum.value =
                          t.iridescenceThicknessRange[1]),
                        t.iridescenceMap &&
                          (e.iridescenceMap.value = t.iridescenceMap),
                        t.iridescenceThicknessMap &&
                          (e.iridescenceThicknessMap.value =
                            t.iridescenceThicknessMap)),
                      t.transmission > 0 &&
                        ((e.transmission.value = t.transmission),
                        (e.transmissionSamplerMap.value = n.texture),
                        e.transmissionSamplerSize.value.set(n.width, n.height),
                        t.transmissionMap &&
                          (e.transmissionMap.value = t.transmissionMap),
                        (e.thickness.value = t.thickness),
                        t.thicknessMap &&
                          (e.thicknessMap.value = t.thicknessMap),
                        (e.attenuationDistance.value = t.attenuationDistance),
                        e.attenuationColor.value.copy(t.attenuationColor)),
                      (e.specularIntensity.value = t.specularIntensity),
                      e.specularColor.value.copy(t.specularColor),
                      t.specularIntensityMap &&
                        (e.specularIntensityMap.value = t.specularIntensityMap),
                      t.specularColorMap &&
                        (e.specularColorMap.value = t.specularColorMap);
                  })(e, i, a))
              : i.isMeshMatcapMaterial
              ? (n(e, i),
                (function (e, t) {
                  t.matcap && (e.matcap.value = t.matcap);
                })(e, i))
              : i.isMeshDepthMaterial
              ? n(e, i)
              : i.isMeshDistanceMaterial
              ? (n(e, i),
                (function (e, t) {
                  e.referencePosition.value.copy(t.referencePosition),
                    (e.nearDistance.value = t.nearDistance),
                    (e.farDistance.value = t.farDistance);
                })(e, i))
              : i.isMeshNormalMaterial
              ? n(e, i)
              : i.isLineBasicMaterial
              ? ((function (e, t) {
                  e.diffuse.value.copy(t.color), (e.opacity.value = t.opacity);
                })(e, i),
                i.isLineDashedMaterial &&
                  (function (e, t) {
                    (e.dashSize.value = t.dashSize),
                      (e.totalSize.value = t.dashSize + t.gapSize),
                      (e.scale.value = t.scale);
                  })(e, i))
              : i.isPointsMaterial
              ? (function (e, t, n, i) {
                  let r;
                  e.diffuse.value.copy(t.color),
                    (e.opacity.value = t.opacity),
                    (e.size.value = t.size * n),
                    (e.scale.value = 0.5 * i),
                    t.map && (e.map.value = t.map),
                    t.alphaMap && (e.alphaMap.value = t.alphaMap),
                    t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest),
                    t.map ? (r = t.map) : t.alphaMap && (r = t.alphaMap),
                    void 0 !== r &&
                      (!0 === r.matrixAutoUpdate && r.updateMatrix(),
                      e.uvTransform.value.copy(r.matrix));
                })(e, i, r, s)
              : i.isSpriteMaterial
              ? (function (e, t) {
                  let n;
                  e.diffuse.value.copy(t.color),
                    (e.opacity.value = t.opacity),
                    (e.rotation.value = t.rotation),
                    t.map && (e.map.value = t.map),
                    t.alphaMap && (e.alphaMap.value = t.alphaMap),
                    t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest),
                    t.map ? (n = t.map) : t.alphaMap && (n = t.alphaMap),
                    void 0 !== n &&
                      (!0 === n.matrixAutoUpdate && n.updateMatrix(),
                      e.uvTransform.value.copy(n.matrix));
                })(e, i)
              : i.isShadowMaterial
              ? (e.color.value.copy(i.color), (e.opacity.value = i.opacity))
              : i.isShaderMaterial && (i.uniformsNeedUpdate = !1);
          },
        };
      }
      function hs(e = {}) {
        this.isWebGLRenderer = !0;
        const t =
            void 0 !== e.canvas
              ? e.canvas
              : (function () {
                  const e = $("canvas");
                  return (e.style.display = "block"), e;
                })(),
          n = void 0 !== e.context ? e.context : null,
          i = void 0 === e.depth || e.depth,
          r = void 0 === e.stencil || e.stencil,
          s = void 0 !== e.antialias && e.antialias,
          a = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
          o = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
          l = void 0 !== e.powerPreference ? e.powerPreference : "default",
          c =
            void 0 !== e.failIfMajorPerformanceCaveat &&
            e.failIfMajorPerformanceCaveat;
        let u;
        u =
          null !== n
            ? n.getContextAttributes().alpha
            : void 0 !== e.alpha && e.alpha;
        let h = null,
          d = null;
        const p = [],
          f = [];
        (this.domElement = t),
          (this.debug = { checkShaderErrors: !0 }),
          (this.autoClear = !0),
          (this.autoClearColor = !0),
          (this.autoClearDepth = !0),
          (this.autoClearStencil = !0),
          (this.sortObjects = !0),
          (this.clippingPlanes = []),
          (this.localClippingEnabled = !1),
          (this.outputEncoding = D),
          (this.physicallyCorrectLights = !1),
          (this.toneMapping = 0),
          (this.toneMappingExposure = 1),
          Object.defineProperties(this, {
            gammaFactor: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderer: .gammaFactor has been removed."
                  ),
                  2
                );
              },
              set: function () {
                console.warn(
                  "THREE.WebGLRenderer: .gammaFactor has been removed."
                );
              },
            },
          });
        const v = this;
        let y = !1,
          w = 0,
          S = 0,
          M = null,
          E = -1,
          T = null;
        const A = new fe(),
          C = new fe();
        let L = null,
          P = t.width,
          k = t.height,
          R = 1,
          I = null,
          F = null;
        const O = new fe(0, 0, P, k),
          N = new fe(0, 0, P, k);
        let z = !1;
        const B = new Rn();
        let U = !1,
          V = !1,
          G = null;
        const H = new $e(),
          W = new X(),
          j = new xe(),
          Y = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0,
          };
        function Z() {
          return null === M ? R : 1;
        }
        let K,
          J,
          Q,
          ee,
          te,
          ne,
          ie,
          re,
          se,
          ae,
          oe,
          le,
          ce,
          ue,
          he,
          de,
          pe,
          ge,
          ve,
          _e,
          ye,
          be,
          we,
          Se = n;
        function Me(e, n) {
          for (let i = 0; i < e.length; i++) {
            const r = e[i],
              s = t.getContext(r, n);
            if (null !== s) return s;
          }
          return null;
        }
        try {
          const e = {
            alpha: !0,
            depth: i,
            stencil: r,
            antialias: s,
            premultipliedAlpha: a,
            preserveDrawingBuffer: o,
            powerPreference: l,
            failIfMajorPerformanceCaveat: c,
          };
          if (
            ("setAttribute" in t &&
              t.setAttribute("data-engine", "three.js r142"),
            t.addEventListener("webglcontextlost", Ae, !1),
            t.addEventListener("webglcontextrestored", Ce, !1),
            t.addEventListener("webglcontextcreationerror", Le, !1),
            null === Se)
          ) {
            const t = ["webgl2", "webgl", "experimental-webgl"];
            if (
              (!0 === v.isWebGL1Renderer && t.shift(),
              (Se = Me(t, e)),
              null === Se)
            )
              throw Me(t)
                ? new Error(
                    "Error creating WebGL context with your selected attributes."
                  )
                : new Error("Error creating WebGL context.");
          }
          void 0 === Se.getShaderPrecisionFormat &&
            (Se.getShaderPrecisionFormat = function () {
              return { rangeMin: 1, rangeMax: 1, precision: 1 };
            });
        } catch (e) {
          throw (console.error("THREE.WebGLRenderer: " + e.message), e);
        }
        function Ee() {
          (K = new ai(Se)),
            (J = new Hn(Se, K, e)),
            K.init(J),
            (be = new is(Se, K, J)),
            (Q = new ts(Se, K, J)),
            (ee = new ci()),
            (te = new Vr()),
            (ne = new ns(Se, K, Q, te, J, be, ee)),
            (ie = new jn(v)),
            (re = new si(v)),
            (se = new Fn(Se, J)),
            (we = new Vn(Se, K, se, J)),
            (ae = new oi(Se, se, ee, we)),
            (oe = new fi(Se, ae, se, ee)),
            (ve = new pi(Se, J, ne)),
            (de = new Wn(te)),
            (le = new Ur(v, ie, re, K, J, we, de)),
            (ce = new us(v, te)),
            (ue = new jr()),
            (he = new Kr(K, J)),
            (ge = new Un(v, ie, Q, oe, u, a)),
            (pe = new es(v, oe, J)),
            (_e = new Gn(Se, K, ee, J)),
            (ye = new li(Se, K, ee, J)),
            (ee.programs = le.programs),
            (v.capabilities = J),
            (v.extensions = K),
            (v.properties = te),
            (v.renderLists = ue),
            (v.shadowMap = pe),
            (v.state = Q),
            (v.info = ee);
        }
        Ee();
        const Te = new cs(v, Se);
        function Ae(e) {
          e.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            (y = !0);
        }
        function Ce() {
          console.log("THREE.WebGLRenderer: Context Restored."), (y = !1);
          const e = ee.autoReset,
            t = pe.enabled,
            n = pe.autoUpdate,
            i = pe.needsUpdate,
            r = pe.type;
          Ee(),
            (ee.autoReset = e),
            (pe.enabled = t),
            (pe.autoUpdate = n),
            (pe.needsUpdate = i),
            (pe.type = r);
        }
        function Le(e) {
          console.error(
            "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
            e.statusMessage
          );
        }
        function Pe(e) {
          const t = e.target;
          t.removeEventListener("dispose", Pe),
            (function (e) {
              (function (e) {
                const t = te.get(e).programs;
                void 0 !== t &&
                  (t.forEach(function (e) {
                    le.releaseProgram(e);
                  }),
                  e.isShaderMaterial && le.releaseShaderCache(e));
              })(e),
                te.remove(e);
            })(t);
        }
        (this.xr = Te),
          (this.getContext = function () {
            return Se;
          }),
          (this.getContextAttributes = function () {
            return Se.getContextAttributes();
          }),
          (this.forceContextLoss = function () {
            const e = K.get("WEBGL_lose_context");
            e && e.loseContext();
          }),
          (this.forceContextRestore = function () {
            const e = K.get("WEBGL_lose_context");
            e && e.restoreContext();
          }),
          (this.getPixelRatio = function () {
            return R;
          }),
          (this.setPixelRatio = function (e) {
            void 0 !== e && ((R = e), this.setSize(P, k, !1));
          }),
          (this.getSize = function (e) {
            return e.set(P, k);
          }),
          (this.setSize = function (e, n, i) {
            Te.isPresenting
              ? console.warn(
                  "THREE.WebGLRenderer: Can't change size while VR device is presenting."
                )
              : ((P = e),
                (k = n),
                (t.width = Math.floor(e * R)),
                (t.height = Math.floor(n * R)),
                !1 !== i &&
                  ((t.style.width = e + "px"), (t.style.height = n + "px")),
                this.setViewport(0, 0, e, n));
          }),
          (this.getDrawingBufferSize = function (e) {
            return e.set(P * R, k * R).floor();
          }),
          (this.setDrawingBufferSize = function (e, n, i) {
            (P = e),
              (k = n),
              (R = i),
              (t.width = Math.floor(e * i)),
              (t.height = Math.floor(n * i)),
              this.setViewport(0, 0, e, n);
          }),
          (this.getCurrentViewport = function (e) {
            return e.copy(A);
          }),
          (this.getViewport = function (e) {
            return e.copy(O);
          }),
          (this.setViewport = function (e, t, n, i) {
            e.isVector4 ? O.set(e.x, e.y, e.z, e.w) : O.set(e, t, n, i),
              Q.viewport(A.copy(O).multiplyScalar(R).floor());
          }),
          (this.getScissor = function (e) {
            return e.copy(N);
          }),
          (this.setScissor = function (e, t, n, i) {
            e.isVector4 ? N.set(e.x, e.y, e.z, e.w) : N.set(e, t, n, i),
              Q.scissor(C.copy(N).multiplyScalar(R).floor());
          }),
          (this.getScissorTest = function () {
            return z;
          }),
          (this.setScissorTest = function (e) {
            Q.setScissorTest((z = e));
          }),
          (this.setOpaqueSort = function (e) {
            I = e;
          }),
          (this.setTransparentSort = function (e) {
            F = e;
          }),
          (this.getClearColor = function (e) {
            return e.copy(ge.getClearColor());
          }),
          (this.setClearColor = function () {
            ge.setClearColor.apply(ge, arguments);
          }),
          (this.getClearAlpha = function () {
            return ge.getClearAlpha();
          }),
          (this.setClearAlpha = function () {
            ge.setClearAlpha.apply(ge, arguments);
          }),
          (this.clear = function (e = !0, t = !0, n = !0) {
            let i = 0;
            e && (i |= 16384), t && (i |= 256), n && (i |= 1024), Se.clear(i);
          }),
          (this.clearColor = function () {
            this.clear(!0, !1, !1);
          }),
          (this.clearDepth = function () {
            this.clear(!1, !0, !1);
          }),
          (this.clearStencil = function () {
            this.clear(!1, !1, !0);
          }),
          (this.dispose = function () {
            t.removeEventListener("webglcontextlost", Ae, !1),
              t.removeEventListener("webglcontextrestored", Ce, !1),
              t.removeEventListener("webglcontextcreationerror", Le, !1),
              ue.dispose(),
              he.dispose(),
              te.dispose(),
              ie.dispose(),
              re.dispose(),
              oe.dispose(),
              we.dispose(),
              le.dispose(),
              Te.dispose(),
              Te.removeEventListener("sessionstart", ke),
              Te.removeEventListener("sessionend", Re),
              G && (G.dispose(), (G = null)),
              Ie.stop();
          }),
          (this.renderBufferDirect = function (e, t, n, i, r, s) {
            null === t && (t = Y);
            const a = r.isMesh && r.matrixWorld.determinant() < 0,
              o = (function (e, t, n, i, r) {
                !0 !== t.isScene && (t = Y), ne.resetTextureUnits();
                const s = t.fog,
                  a = i.isMeshStandardMaterial ? t.environment : null,
                  o =
                    null === M
                      ? v.outputEncoding
                      : !0 === M.isXRRenderTarget
                      ? M.texture.encoding
                      : D,
                  l = (i.isMeshStandardMaterial ? re : ie).get(i.envMap || a),
                  c =
                    !0 === i.vertexColors &&
                    !!n.attributes.color &&
                    4 === n.attributes.color.itemSize,
                  u = !!i.normalMap && !!n.attributes.tangent,
                  h = !!n.morphAttributes.position,
                  p = !!n.morphAttributes.normal,
                  f = !!n.morphAttributes.color,
                  m = i.toneMapped ? v.toneMapping : 0,
                  g =
                    n.morphAttributes.position ||
                    n.morphAttributes.normal ||
                    n.morphAttributes.color,
                  _ = void 0 !== g ? g.length : 0,
                  x = te.get(i),
                  y = d.state.lights;
                if (!0 === U && (!0 === V || e !== T)) {
                  const t = e === T && i.id === E;
                  de.setState(i, e, t);
                }
                let b = !1;
                i.version === x.__version
                  ? (x.needsLights &&
                      x.lightsStateVersion !== y.state.version) ||
                    x.outputEncoding !== o ||
                    (r.isInstancedMesh && !1 === x.instancing)
                    ? (b = !0)
                    : r.isInstancedMesh || !0 !== x.instancing
                    ? r.isSkinnedMesh && !1 === x.skinning
                      ? (b = !0)
                      : r.isSkinnedMesh || !0 !== x.skinning
                      ? x.envMap !== l || (!0 === i.fog && x.fog !== s)
                        ? (b = !0)
                        : void 0 === x.numClippingPlanes ||
                          (x.numClippingPlanes === de.numPlanes &&
                            x.numIntersection === de.numIntersection)
                        ? (x.vertexAlphas !== c ||
                            x.vertexTangents !== u ||
                            x.morphTargets !== h ||
                            x.morphNormals !== p ||
                            x.morphColors !== f ||
                            x.toneMapping !== m ||
                            (!0 === J.isWebGL2 && x.morphTargetsCount !== _)) &&
                          (b = !0)
                        : (b = !0)
                      : (b = !0)
                    : (b = !0)
                  : ((b = !0), (x.__version = i.version));
                let w = x.currentProgram;
                !0 === b && (w = Be(i, t, r));
                let S = !1,
                  A = !1,
                  C = !1;
                const L = w.getUniforms(),
                  P = x.uniforms;
                if (
                  (Q.useProgram(w.program) && ((S = !0), (A = !0), (C = !0)),
                  i.id !== E && ((E = i.id), (A = !0)),
                  S || T !== e)
                ) {
                  if (
                    (L.setValue(Se, "projectionMatrix", e.projectionMatrix),
                    J.logarithmicDepthBuffer &&
                      L.setValue(
                        Se,
                        "logDepthBufFC",
                        2 / (Math.log(e.far + 1) / Math.LN2)
                      ),
                    T !== e && ((T = e), (A = !0), (C = !0)),
                    i.isShaderMaterial ||
                      i.isMeshPhongMaterial ||
                      i.isMeshToonMaterial ||
                      i.isMeshStandardMaterial ||
                      i.envMap)
                  ) {
                    const t = L.map.cameraPosition;
                    void 0 !== t &&
                      t.setValue(Se, j.setFromMatrixPosition(e.matrixWorld));
                  }
                  (i.isMeshPhongMaterial ||
                    i.isMeshToonMaterial ||
                    i.isMeshLambertMaterial ||
                    i.isMeshBasicMaterial ||
                    i.isMeshStandardMaterial ||
                    i.isShaderMaterial) &&
                    L.setValue(
                      Se,
                      "isOrthographic",
                      !0 === e.isOrthographicCamera
                    ),
                    (i.isMeshPhongMaterial ||
                      i.isMeshToonMaterial ||
                      i.isMeshLambertMaterial ||
                      i.isMeshBasicMaterial ||
                      i.isMeshStandardMaterial ||
                      i.isShaderMaterial ||
                      i.isShadowMaterial ||
                      r.isSkinnedMesh) &&
                      L.setValue(Se, "viewMatrix", e.matrixWorldInverse);
                }
                if (r.isSkinnedMesh) {
                  L.setOptional(Se, r, "bindMatrix"),
                    L.setOptional(Se, r, "bindMatrixInverse");
                  const e = r.skeleton;
                  e &&
                    (J.floatVertexTextures
                      ? (null === e.boneTexture && e.computeBoneTexture(),
                        L.setValue(Se, "boneTexture", e.boneTexture, ne),
                        L.setValue(Se, "boneTextureSize", e.boneTextureSize))
                      : console.warn(
                          "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."
                        ));
                }
                const I = n.morphAttributes;
                var F, O;
                return (
                  (void 0 !== I.position ||
                    void 0 !== I.normal ||
                    (void 0 !== I.color && !0 === J.isWebGL2)) &&
                    ve.update(r, n, i, w),
                  (A || x.receiveShadow !== r.receiveShadow) &&
                    ((x.receiveShadow = r.receiveShadow),
                    L.setValue(Se, "receiveShadow", r.receiveShadow)),
                  A &&
                    (L.setValue(
                      Se,
                      "toneMappingExposure",
                      v.toneMappingExposure
                    ),
                    x.needsLights &&
                      ((O = C),
                      ((F = P).ambientLightColor.needsUpdate = O),
                      (F.lightProbe.needsUpdate = O),
                      (F.directionalLights.needsUpdate = O),
                      (F.directionalLightShadows.needsUpdate = O),
                      (F.pointLights.needsUpdate = O),
                      (F.pointLightShadows.needsUpdate = O),
                      (F.spotLights.needsUpdate = O),
                      (F.spotLightShadows.needsUpdate = O),
                      (F.rectAreaLights.needsUpdate = O),
                      (F.hemisphereLights.needsUpdate = O)),
                    s && !0 === i.fog && ce.refreshFogUniforms(P, s),
                    ce.refreshMaterialUniforms(P, i, R, k, G),
                    _r.upload(Se, x.uniformsList, P, ne)),
                  i.isShaderMaterial &&
                    !0 === i.uniformsNeedUpdate &&
                    (_r.upload(Se, x.uniformsList, P, ne),
                    (i.uniformsNeedUpdate = !1)),
                  i.isSpriteMaterial && L.setValue(Se, "center", r.center),
                  L.setValue(Se, "modelViewMatrix", r.modelViewMatrix),
                  L.setValue(Se, "normalMatrix", r.normalMatrix),
                  L.setValue(Se, "modelMatrix", r.matrixWorld),
                  w
                );
              })(e, t, n, i, r);
            Q.setMaterial(i, a);
            let l = n.index;
            const c = n.attributes.position;
            if (null === l) {
              if (void 0 === c || 0 === c.count) return;
            } else if (0 === l.count) return;
            let u,
              h = 1;
            !0 === i.wireframe && ((l = ae.getWireframeAttribute(n)), (h = 2)),
              we.setup(r, i, o, n, l);
            let p = _e;
            null !== l && ((u = se.get(l)), (p = ye), p.setIndex(u));
            const f = null !== l ? l.count : c.count,
              m = n.drawRange.start * h,
              g = n.drawRange.count * h,
              _ = null !== s ? s.start * h : 0,
              x = null !== s ? s.count * h : 1 / 0,
              y = Math.max(m, _),
              b = Math.min(f, m + g, _ + x) - 1,
              w = Math.max(0, b - y + 1);
            if (0 !== w) {
              if (r.isMesh)
                !0 === i.wireframe
                  ? (Q.setLineWidth(i.wireframeLinewidth * Z()), p.setMode(1))
                  : p.setMode(4);
              else if (r.isLine) {
                let e = i.linewidth;
                void 0 === e && (e = 1),
                  Q.setLineWidth(e * Z()),
                  r.isLineSegments
                    ? p.setMode(1)
                    : r.isLineLoop
                    ? p.setMode(2)
                    : p.setMode(3);
              } else r.isPoints ? p.setMode(0) : r.isSprite && p.setMode(4);
              if (r.isInstancedMesh) p.renderInstances(y, w, r.count);
              else if (n.isInstancedBufferGeometry) {
                const e = Math.min(n.instanceCount, n._maxInstanceCount);
                p.renderInstances(y, w, e);
              } else p.render(y, w);
            }
          }),
          (this.compile = function (e, t) {
            (d = he.get(e)),
              d.init(),
              f.push(d),
              e.traverseVisible(function (e) {
                e.isLight &&
                  e.layers.test(t.layers) &&
                  (d.pushLight(e), e.castShadow && d.pushShadow(e));
              }),
              d.setupLights(v.physicallyCorrectLights),
              e.traverse(function (t) {
                const n = t.material;
                if (n)
                  if (Array.isArray(n))
                    for (let i = 0; i < n.length; i++) Be(n[i], e, t);
                  else Be(n, e, t);
              }),
              f.pop(),
              (d = null);
          });
        let De = null;
        function ke() {
          Ie.stop();
        }
        function Re() {
          Ie.start();
        }
        const Ie = new In();
        function Fe(e, t, n, i) {
          if (!1 === e.visible) return;
          if (e.layers.test(t.layers))
            if (e.isGroup) n = e.renderOrder;
            else if (e.isLOD) !0 === e.autoUpdate && e.update(t);
            else if (e.isLight) d.pushLight(e), e.castShadow && d.pushShadow(e);
            else if (e.isSprite) {
              if (!e.frustumCulled || B.intersectsSprite(e)) {
                i && j.setFromMatrixPosition(e.matrixWorld).applyMatrix4(H);
                const t = oe.update(e),
                  r = e.material;
                r.visible && h.push(e, t, r, n, j.z, null);
              }
            } else if (
              (e.isMesh || e.isLine || e.isPoints) &&
              (e.isSkinnedMesh &&
                e.skeleton.frame !== ee.render.frame &&
                (e.skeleton.update(), (e.skeleton.frame = ee.render.frame)),
              !e.frustumCulled || B.intersectsObject(e))
            ) {
              i && j.setFromMatrixPosition(e.matrixWorld).applyMatrix4(H);
              const t = oe.update(e),
                r = e.material;
              if (Array.isArray(r)) {
                const i = t.groups;
                for (let s = 0, a = i.length; s < a; s++) {
                  const a = i[s],
                    o = r[a.materialIndex];
                  o && o.visible && h.push(e, t, o, n, j.z, a);
                }
              } else r.visible && h.push(e, t, r, n, j.z, null);
            }
          const r = e.children;
          for (let e = 0, s = r.length; e < s; e++) Fe(r[e], t, n, i);
        }
        function Oe(e, t, n, i) {
          const r = e.opaque,
            a = e.transmissive,
            o = e.transparent;
          d.setupLightsView(n),
            a.length > 0 &&
              (function (e, t, n) {
                const i = J.isWebGL2;
                null === G &&
                  (G = new me(1, 1, {
                    generateMipmaps: !0,
                    type: K.has("EXT_color_buffer_half_float") ? x : g,
                    minFilter: m,
                    samples: i && !0 === s ? 4 : 0,
                  })),
                  v.getDrawingBufferSize(W),
                  i ? G.setSize(W.x, W.y) : G.setSize(q(W.x), q(W.y));
                const r = v.getRenderTarget();
                v.setRenderTarget(G), v.clear();
                const a = v.toneMapping;
                (v.toneMapping = 0),
                  Ne(e, t, n),
                  (v.toneMapping = a),
                  ne.updateMultisampleRenderTarget(G),
                  ne.updateRenderTargetMipmap(G),
                  v.setRenderTarget(r);
              })(r, t, n),
            i && Q.viewport(A.copy(i)),
            r.length > 0 && Ne(r, t, n),
            a.length > 0 && Ne(a, t, n),
            o.length > 0 && Ne(o, t, n),
            Q.buffers.depth.setTest(!0),
            Q.buffers.depth.setMask(!0),
            Q.buffers.color.setMask(!0),
            Q.setPolygonOffset(!1);
        }
        function Ne(e, t, n) {
          const i = !0 === t.isScene ? t.overrideMaterial : null;
          for (let r = 0, s = e.length; r < s; r++) {
            const s = e[r],
              a = s.object,
              o = s.geometry,
              l = null === i ? s.material : i,
              c = s.group;
            a.layers.test(n.layers) && ze(a, t, n, o, l, c);
          }
        }
        function ze(e, t, n, i, r, s) {
          e.onBeforeRender(v, t, n, i, r, s),
            e.modelViewMatrix.multiplyMatrices(
              n.matrixWorldInverse,
              e.matrixWorld
            ),
            e.normalMatrix.getNormalMatrix(e.modelViewMatrix),
            r.onBeforeRender(v, t, n, i, e, s),
            !0 === r.transparent && 2 === r.side
              ? ((r.side = 1),
                (r.needsUpdate = !0),
                v.renderBufferDirect(n, t, i, r, e, s),
                (r.side = 0),
                (r.needsUpdate = !0),
                v.renderBufferDirect(n, t, i, r, e, s),
                (r.side = 2))
              : v.renderBufferDirect(n, t, i, r, e, s),
            e.onAfterRender(v, t, n, i, r, s);
        }
        function Be(e, t, n) {
          !0 !== t.isScene && (t = Y);
          const i = te.get(e),
            r = d.state.lights,
            s = d.state.shadowsArray,
            a = r.state.version,
            o = le.getParameters(e, r.state, s, t, n),
            l = le.getProgramCacheKey(o);
          let c = i.programs;
          (i.environment = e.isMeshStandardMaterial ? t.environment : null),
            (i.fog = t.fog),
            (i.envMap = (e.isMeshStandardMaterial ? re : ie).get(
              e.envMap || i.environment
            )),
            void 0 === c &&
              (e.addEventListener("dispose", Pe),
              (c = new Map()),
              (i.programs = c));
          let u = c.get(l);
          if (void 0 !== u) {
            if (i.currentProgram === u && i.lightsStateVersion === a)
              return Ue(e, o), u;
          } else
            (o.uniforms = le.getUniforms(e)),
              e.onBuild(n, o, v),
              e.onBeforeCompile(o, v),
              (u = le.acquireProgram(o, l)),
              c.set(l, u),
              (i.uniforms = o.uniforms);
          const h = i.uniforms;
          ((e.isShaderMaterial || e.isRawShaderMaterial) &&
            !0 !== e.clipping) ||
            (h.clippingPlanes = de.uniform),
            Ue(e, o),
            (i.needsLights = (function (e) {
              return (
                e.isMeshLambertMaterial ||
                e.isMeshToonMaterial ||
                e.isMeshPhongMaterial ||
                e.isMeshStandardMaterial ||
                e.isShadowMaterial ||
                (e.isShaderMaterial && !0 === e.lights)
              );
            })(e)),
            (i.lightsStateVersion = a),
            i.needsLights &&
              ((h.ambientLightColor.value = r.state.ambient),
              (h.lightProbe.value = r.state.probe),
              (h.directionalLights.value = r.state.directional),
              (h.directionalLightShadows.value = r.state.directionalShadow),
              (h.spotLights.value = r.state.spot),
              (h.spotLightShadows.value = r.state.spotShadow),
              (h.rectAreaLights.value = r.state.rectArea),
              (h.ltc_1.value = r.state.rectAreaLTC1),
              (h.ltc_2.value = r.state.rectAreaLTC2),
              (h.pointLights.value = r.state.point),
              (h.pointLightShadows.value = r.state.pointShadow),
              (h.hemisphereLights.value = r.state.hemi),
              (h.directionalShadowMap.value = r.state.directionalShadowMap),
              (h.directionalShadowMatrix.value =
                r.state.directionalShadowMatrix),
              (h.spotShadowMap.value = r.state.spotShadowMap),
              (h.spotShadowMatrix.value = r.state.spotShadowMatrix),
              (h.pointShadowMap.value = r.state.pointShadowMap),
              (h.pointShadowMatrix.value = r.state.pointShadowMatrix));
          const p = u.getUniforms(),
            f = _r.seqWithValue(p.seq, h);
          return (i.currentProgram = u), (i.uniformsList = f), u;
        }
        function Ue(e, t) {
          const n = te.get(e);
          (n.outputEncoding = t.outputEncoding),
            (n.instancing = t.instancing),
            (n.skinning = t.skinning),
            (n.morphTargets = t.morphTargets),
            (n.morphNormals = t.morphNormals),
            (n.morphColors = t.morphColors),
            (n.morphTargetsCount = t.morphTargetsCount),
            (n.numClippingPlanes = t.numClippingPlanes),
            (n.numIntersection = t.numClipIntersection),
            (n.vertexAlphas = t.vertexAlphas),
            (n.vertexTangents = t.vertexTangents),
            (n.toneMapping = t.toneMapping);
        }
        Ie.setAnimationLoop(function (e) {
          De && De(e);
        }),
          "undefined" != typeof self && Ie.setContext(self),
          (this.setAnimationLoop = function (e) {
            (De = e),
              Te.setAnimationLoop(e),
              null === e ? Ie.stop() : Ie.start();
          }),
          Te.addEventListener("sessionstart", ke),
          Te.addEventListener("sessionend", Re),
          (this.render = function (e, t) {
            if (void 0 !== t && !0 !== t.isCamera)
              return void console.error(
                "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
              );
            if (!0 === y) return;
            !0 === e.autoUpdate && e.updateMatrixWorld(),
              null === t.parent && t.updateMatrixWorld(),
              !0 === Te.enabled &&
                !0 === Te.isPresenting &&
                (!0 === Te.cameraAutoUpdate && Te.updateCamera(t),
                (t = Te.getCamera())),
              !0 === e.isScene && e.onBeforeRender(v, e, t, M),
              (d = he.get(e, f.length)),
              d.init(),
              f.push(d),
              H.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
              B.setFromProjectionMatrix(H),
              (V = this.localClippingEnabled),
              (U = de.init(this.clippingPlanes, V, t)),
              (h = ue.get(e, p.length)),
              h.init(),
              p.push(h),
              Fe(e, t, 0, v.sortObjects),
              h.finish(),
              !0 === v.sortObjects && h.sort(I, F),
              !0 === U && de.beginShadows();
            const n = d.state.shadowsArray;
            if (
              (pe.render(n, e, t),
              !0 === U && de.endShadows(),
              !0 === this.info.autoReset && this.info.reset(),
              ge.render(h, e),
              d.setupLights(v.physicallyCorrectLights),
              t.isArrayCamera)
            ) {
              const n = t.cameras;
              for (let t = 0, i = n.length; t < i; t++) {
                const i = n[t];
                Oe(h, e, i, i.viewport);
              }
            } else Oe(h, e, t);
            null !== M &&
              (ne.updateMultisampleRenderTarget(M),
              ne.updateRenderTargetMipmap(M)),
              !0 === e.isScene && e.onAfterRender(v, e, t),
              we.resetDefaultState(),
              (E = -1),
              (T = null),
              f.pop(),
              (d = f.length > 0 ? f[f.length - 1] : null),
              p.pop(),
              (h = p.length > 0 ? p[p.length - 1] : null);
          }),
          (this.getActiveCubeFace = function () {
            return w;
          }),
          (this.getActiveMipmapLevel = function () {
            return S;
          }),
          (this.getRenderTarget = function () {
            return M;
          }),
          (this.setRenderTargetTextures = function (e, t, n) {
            (te.get(e.texture).__webglTexture = t),
              (te.get(e.depthTexture).__webglTexture = n);
            const i = te.get(e);
            (i.__hasExternalTextures = !0),
              i.__hasExternalTextures &&
                ((i.__autoAllocateDepthBuffer = void 0 === n),
                i.__autoAllocateDepthBuffer ||
                  (!0 === K.has("WEBGL_multisampled_render_to_texture") &&
                    (console.warn(
                      "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
                    ),
                    (i.__useRenderToTexture = !1))));
          }),
          (this.setRenderTargetFramebuffer = function (e, t) {
            const n = te.get(e);
            (n.__webglFramebuffer = t),
              (n.__useDefaultFramebuffer = void 0 === t);
          }),
          (this.setRenderTarget = function (e, t = 0, n = 0) {
            (M = e), (w = t), (S = n);
            let i = !0;
            if (e) {
              const t = te.get(e);
              void 0 !== t.__useDefaultFramebuffer
                ? (Q.bindFramebuffer(36160, null), (i = !1))
                : void 0 === t.__webglFramebuffer
                ? ne.setupRenderTarget(e)
                : t.__hasExternalTextures &&
                  ne.rebindTextures(
                    e,
                    te.get(e.texture).__webglTexture,
                    te.get(e.depthTexture).__webglTexture
                  );
            }
            let r = null,
              s = !1,
              a = !1;
            if (e) {
              const n = e.texture;
              (n.isData3DTexture || n.isDataArrayTexture) && (a = !0);
              const i = te.get(e).__webglFramebuffer;
              e.isWebGLCubeRenderTarget
                ? ((r = i[t]), (s = !0))
                : (r =
                    J.isWebGL2 &&
                    e.samples > 0 &&
                    !1 === ne.useMultisampledRTT(e)
                      ? te.get(e).__webglMultisampledFramebuffer
                      : i),
                A.copy(e.viewport),
                C.copy(e.scissor),
                (L = e.scissorTest);
            } else
              A.copy(O).multiplyScalar(R).floor(),
                C.copy(N).multiplyScalar(R).floor(),
                (L = z);
            if (
              (Q.bindFramebuffer(36160, r) &&
                J.drawBuffers &&
                i &&
                Q.drawBuffers(e, r),
              Q.viewport(A),
              Q.scissor(C),
              Q.setScissorTest(L),
              s)
            ) {
              const i = te.get(e.texture);
              Se.framebufferTexture2D(
                36160,
                36064,
                34069 + t,
                i.__webglTexture,
                n
              );
            } else if (a) {
              const i = te.get(e.texture),
                r = t || 0;
              Se.framebufferTextureLayer(
                36160,
                36064,
                i.__webglTexture,
                n || 0,
                r
              );
            }
            E = -1;
          }),
          (this.readRenderTargetPixels = function (e, t, n, i, r, s, a) {
            if (!e || !e.isWebGLRenderTarget)
              return void console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
              );
            let o = te.get(e).__webglFramebuffer;
            if ((e.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o)) {
              Q.bindFramebuffer(36160, o);
              try {
                const a = e.texture,
                  o = a.format,
                  l = a.type;
                if (o !== b && be.convert(o) !== Se.getParameter(35739))
                  return void console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                  );
                const c =
                  l === x &&
                  (K.has("EXT_color_buffer_half_float") ||
                    (J.isWebGL2 && K.has("EXT_color_buffer_float")));
                if (
                  !(
                    l === g ||
                    be.convert(l) === Se.getParameter(35738) ||
                    (l === _ &&
                      (J.isWebGL2 ||
                        K.has("OES_texture_float") ||
                        K.has("WEBGL_color_buffer_float"))) ||
                    c
                  )
                )
                  return void console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                  );
                t >= 0 &&
                  t <= e.width - i &&
                  n >= 0 &&
                  n <= e.height - r &&
                  Se.readPixels(t, n, i, r, be.convert(o), be.convert(l), s);
              } finally {
                const e = null !== M ? te.get(M).__webglFramebuffer : null;
                Q.bindFramebuffer(36160, e);
              }
            }
          }),
          (this.copyFramebufferToTexture = function (e, t, n = 0) {
            const i = Math.pow(2, -n),
              r = Math.floor(t.image.width * i),
              s = Math.floor(t.image.height * i);
            ne.setTexture2D(t, 0),
              Se.copyTexSubImage2D(3553, n, 0, 0, e.x, e.y, r, s),
              Q.unbindTexture();
          }),
          (this.copyTextureToTexture = function (e, t, n, i = 0) {
            const r = t.image.width,
              s = t.image.height,
              a = be.convert(n.format),
              o = be.convert(n.type);
            ne.setTexture2D(n, 0),
              Se.pixelStorei(37440, n.flipY),
              Se.pixelStorei(37441, n.premultiplyAlpha),
              Se.pixelStorei(3317, n.unpackAlignment),
              t.isDataTexture
                ? Se.texSubImage2D(3553, i, e.x, e.y, r, s, a, o, t.image.data)
                : t.isCompressedTexture
                ? Se.compressedTexSubImage2D(
                    3553,
                    i,
                    e.x,
                    e.y,
                    t.mipmaps[0].width,
                    t.mipmaps[0].height,
                    a,
                    t.mipmaps[0].data
                  )
                : Se.texSubImage2D(3553, i, e.x, e.y, a, o, t.image),
              0 === i && n.generateMipmaps && Se.generateMipmap(3553),
              Q.unbindTexture();
          }),
          (this.copyTextureToTexture3D = function (e, t, n, i, r = 0) {
            if (v.isWebGL1Renderer)
              return void console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
              );
            const s = e.max.x - e.min.x + 1,
              a = e.max.y - e.min.y + 1,
              o = e.max.z - e.min.z + 1,
              l = be.convert(i.format),
              c = be.convert(i.type);
            let u;
            if (i.isData3DTexture) ne.setTexture3D(i, 0), (u = 32879);
            else {
              if (!i.isDataArrayTexture)
                return void console.warn(
                  "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
                );
              ne.setTexture2DArray(i, 0), (u = 35866);
            }
            Se.pixelStorei(37440, i.flipY),
              Se.pixelStorei(37441, i.premultiplyAlpha),
              Se.pixelStorei(3317, i.unpackAlignment);
            const h = Se.getParameter(3314),
              d = Se.getParameter(32878),
              p = Se.getParameter(3316),
              f = Se.getParameter(3315),
              m = Se.getParameter(32877),
              g = n.isCompressedTexture ? n.mipmaps[0] : n.image;
            Se.pixelStorei(3314, g.width),
              Se.pixelStorei(32878, g.height),
              Se.pixelStorei(3316, e.min.x),
              Se.pixelStorei(3315, e.min.y),
              Se.pixelStorei(32877, e.min.z),
              n.isDataTexture || n.isData3DTexture
                ? Se.texSubImage3D(u, r, t.x, t.y, t.z, s, a, o, l, c, g.data)
                : n.isCompressedTexture
                ? (console.warn(
                    "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
                  ),
                  Se.compressedTexSubImage3D(
                    u,
                    r,
                    t.x,
                    t.y,
                    t.z,
                    s,
                    a,
                    o,
                    l,
                    g.data
                  ))
                : Se.texSubImage3D(u, r, t.x, t.y, t.z, s, a, o, l, c, g),
              Se.pixelStorei(3314, h),
              Se.pixelStorei(32878, d),
              Se.pixelStorei(3316, p),
              Se.pixelStorei(3315, f),
              Se.pixelStorei(32877, m),
              0 === r && i.generateMipmaps && Se.generateMipmap(u),
              Q.unbindTexture();
          }),
          (this.initTexture = function (e) {
            e.isCubeTexture
              ? ne.setTextureCube(e, 0)
              : e.isData3DTexture
              ? ne.setTexture3D(e, 0)
              : e.isDataArrayTexture
              ? ne.setTexture2DArray(e, 0)
              : ne.setTexture2D(e, 0),
              Q.unbindTexture();
          }),
          (this.resetState = function () {
            (w = 0), (S = 0), (M = null), Q.reset(), we.reset();
          }),
          "undefined" != typeof __THREE_DEVTOOLS__ &&
            __THREE_DEVTOOLS__.dispatchEvent(
              new CustomEvent("observe", { detail: this })
            );
      }
      (class extends hs {}).prototype.isWebGL1Renderer = !0;
      class ds extends bt {
        constructor() {
          super(),
            (this.isScene = !0),
            (this.type = "Scene"),
            (this.background = null),
            (this.environment = null),
            (this.fog = null),
            (this.overrideMaterial = null),
            (this.autoUpdate = !0),
            "undefined" != typeof __THREE_DEVTOOLS__ &&
              __THREE_DEVTOOLS__.dispatchEvent(
                new CustomEvent("observe", { detail: this })
              );
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            null !== e.background && (this.background = e.background.clone()),
            null !== e.environment &&
              (this.environment = e.environment.clone()),
            null !== e.fog && (this.fog = e.fog.clone()),
            null !== e.overrideMaterial &&
              (this.overrideMaterial = e.overrideMaterial.clone()),
            (this.autoUpdate = e.autoUpdate),
            (this.matrixAutoUpdate = e.matrixAutoUpdate),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return null !== this.fog && (t.object.fog = this.fog.toJSON()), t;
        }
      }
      class ps extends Zt {
        constructor(
          e = 1,
          t = 32,
          n = 16,
          i = 0,
          r = 2 * Math.PI,
          s = 0,
          a = Math.PI
        ) {
          super(),
            (this.type = "SphereGeometry"),
            (this.parameters = {
              radius: e,
              widthSegments: t,
              heightSegments: n,
              phiStart: i,
              phiLength: r,
              thetaStart: s,
              thetaLength: a,
            }),
            (t = Math.max(3, Math.floor(t))),
            (n = Math.max(2, Math.floor(n)));
          const o = Math.min(s + a, Math.PI);
          let l = 0;
          const c = [],
            u = new xe(),
            h = new xe(),
            d = [],
            p = [],
            f = [],
            m = [];
          for (let d = 0; d <= n; d++) {
            const g = [],
              v = d / n;
            let _ = 0;
            0 == d && 0 == s
              ? (_ = 0.5 / t)
              : d == n && o == Math.PI && (_ = -0.5 / t);
            for (let n = 0; n <= t; n++) {
              const o = n / t;
              (u.x = -e * Math.cos(i + o * r) * Math.sin(s + v * a)),
                (u.y = e * Math.cos(s + v * a)),
                (u.z = e * Math.sin(i + o * r) * Math.sin(s + v * a)),
                p.push(u.x, u.y, u.z),
                h.copy(u).normalize(),
                f.push(h.x, h.y, h.z),
                m.push(o + _, 1 - v),
                g.push(l++);
            }
            c.push(g);
          }
          for (let e = 0; e < n; e++)
            for (let i = 0; i < t; i++) {
              const t = c[e][i + 1],
                r = c[e][i],
                a = c[e + 1][i],
                l = c[e + 1][i + 1];
              (0 !== e || s > 0) && d.push(t, r, l),
                (e !== n - 1 || o < Math.PI) && d.push(r, a, l);
            }
          this.setIndex(d),
            this.setAttribute("position", new Vt(p, 3)),
            this.setAttribute("normal", new Vt(f, 3)),
            this.setAttribute("uv", new Vt(m, 2));
        }
        static fromJSON(e) {
          return new ps(
            e.radius,
            e.widthSegments,
            e.heightSegments,
            e.phiStart,
            e.phiLength,
            e.thetaStart,
            e.thetaLength
          );
        }
      }
      class fs extends Zt {
        constructor(e = 1, t = 0.4, n = 8, i = 6, r = 2 * Math.PI) {
          super(),
            (this.type = "TorusGeometry"),
            (this.parameters = {
              radius: e,
              tube: t,
              radialSegments: n,
              tubularSegments: i,
              arc: r,
            }),
            (n = Math.floor(n)),
            (i = Math.floor(i));
          const s = [],
            a = [],
            o = [],
            l = [],
            c = new xe(),
            u = new xe(),
            h = new xe();
          for (let s = 0; s <= n; s++)
            for (let d = 0; d <= i; d++) {
              const p = (d / i) * r,
                f = (s / n) * Math.PI * 2;
              (u.x = (e + t * Math.cos(f)) * Math.cos(p)),
                (u.y = (e + t * Math.cos(f)) * Math.sin(p)),
                (u.z = t * Math.sin(f)),
                a.push(u.x, u.y, u.z),
                (c.x = e * Math.cos(p)),
                (c.y = e * Math.sin(p)),
                h.subVectors(u, c).normalize(),
                o.push(h.x, h.y, h.z),
                l.push(d / i),
                l.push(s / n);
            }
          for (let e = 1; e <= n; e++)
            for (let t = 1; t <= i; t++) {
              const n = (i + 1) * e + t - 1,
                r = (i + 1) * (e - 1) + t - 1,
                a = (i + 1) * (e - 1) + t,
                o = (i + 1) * e + t;
              s.push(n, r, o), s.push(r, a, o);
            }
          this.setIndex(s),
            this.setAttribute("position", new Vt(a, 3)),
            this.setAttribute("normal", new Vt(o, 3)),
            this.setAttribute("uv", new Vt(l, 2));
        }
        static fromJSON(e) {
          return new fs(
            e.radius,
            e.tube,
            e.radialSegments,
            e.tubularSegments,
            e.arc
          );
        }
      }
      const ms = {
        arraySlice: function (e, t, n) {
          return ms.isTypedArray(e)
            ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length))
            : e.slice(t, n);
        },
        convertArray: function (e, t, n) {
          return !e || (!n && e.constructor === t)
            ? e
            : "number" == typeof t.BYTES_PER_ELEMENT
            ? new t(e)
            : Array.prototype.slice.call(e);
        },
        isTypedArray: function (e) {
          return ArrayBuffer.isView(e) && !(e instanceof DataView);
        },
        getKeyframeOrder: function (e) {
          const t = e.length,
            n = new Array(t);
          for (let e = 0; e !== t; ++e) n[e] = e;
          return (
            n.sort(function (t, n) {
              return e[t] - e[n];
            }),
            n
          );
        },
        sortedArray: function (e, t, n) {
          const i = e.length,
            r = new e.constructor(i);
          for (let s = 0, a = 0; a !== i; ++s) {
            const i = n[s] * t;
            for (let n = 0; n !== t; ++n) r[a++] = e[i + n];
          }
          return r;
        },
        flattenJSON: function (e, t, n, i) {
          let r = 1,
            s = e[0];
          for (; void 0 !== s && void 0 === s[i]; ) s = e[r++];
          if (void 0 === s) return;
          let a = s[i];
          if (void 0 !== a)
            if (Array.isArray(a))
              do {
                (a = s[i]),
                  void 0 !== a && (t.push(s.time), n.push.apply(n, a)),
                  (s = e[r++]);
              } while (void 0 !== s);
            else if (void 0 !== a.toArray)
              do {
                (a = s[i]),
                  void 0 !== a && (t.push(s.time), a.toArray(n, n.length)),
                  (s = e[r++]);
              } while (void 0 !== s);
            else
              do {
                (a = s[i]),
                  void 0 !== a && (t.push(s.time), n.push(a)),
                  (s = e[r++]);
              } while (void 0 !== s);
        },
        subclip: function (e, t, n, i, r = 30) {
          const s = e.clone();
          s.name = t;
          const a = [];
          for (let e = 0; e < s.tracks.length; ++e) {
            const t = s.tracks[e],
              o = t.getValueSize(),
              l = [],
              c = [];
            for (let e = 0; e < t.times.length; ++e) {
              const s = t.times[e] * r;
              if (!(s < n || s >= i)) {
                l.push(t.times[e]);
                for (let n = 0; n < o; ++n) c.push(t.values[e * o + n]);
              }
            }
            0 !== l.length &&
              ((t.times = ms.convertArray(l, t.times.constructor)),
              (t.values = ms.convertArray(c, t.values.constructor)),
              a.push(t));
          }
          s.tracks = a;
          let o = 1 / 0;
          for (let e = 0; e < s.tracks.length; ++e)
            o > s.tracks[e].times[0] && (o = s.tracks[e].times[0]);
          for (let e = 0; e < s.tracks.length; ++e) s.tracks[e].shift(-1 * o);
          return s.resetDuration(), s;
        },
        makeClipAdditive: function (e, t = 0, n = e, i = 30) {
          i <= 0 && (i = 30);
          const r = n.tracks.length,
            s = t / i;
          for (let t = 0; t < r; ++t) {
            const i = n.tracks[t],
              r = i.ValueTypeName;
            if ("bool" === r || "string" === r) continue;
            const a = e.tracks.find(function (e) {
              return e.name === i.name && e.ValueTypeName === r;
            });
            if (void 0 === a) continue;
            let o = 0;
            const l = i.getValueSize();
            i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
              (o = l / 3);
            let c = 0;
            const u = a.getValueSize();
            a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
              (c = u / 3);
            const h = i.times.length - 1;
            let d;
            if (s <= i.times[0]) {
              const e = o,
                t = l - o;
              d = ms.arraySlice(i.values, e, t);
            } else if (s >= i.times[h]) {
              const e = h * l + o,
                t = e + l - o;
              d = ms.arraySlice(i.values, e, t);
            } else {
              const e = i.createInterpolant(),
                t = o,
                n = l - o;
              e.evaluate(s), (d = ms.arraySlice(e.resultBuffer, t, n));
            }
            "quaternion" === r &&
              new _e().fromArray(d).normalize().conjugate().toArray(d);
            const p = a.times.length;
            for (let e = 0; e < p; ++e) {
              const t = e * u + c;
              if ("quaternion" === r)
                _e.multiplyQuaternionsFlat(a.values, t, d, 0, a.values, t);
              else {
                const e = u - 2 * c;
                for (let n = 0; n < e; ++n) a.values[t + n] -= d[n];
              }
            }
          }
          return (e.blendMode = 2501), e;
        },
      };
      class gs {
        constructor(e, t, n, i) {
          (this.parameterPositions = e),
            (this._cachedIndex = 0),
            (this.resultBuffer = void 0 !== i ? i : new t.constructor(n)),
            (this.sampleValues = t),
            (this.valueSize = n),
            (this.settings = null),
            (this.DefaultSettings_ = {});
        }
        evaluate(e) {
          const t = this.parameterPositions;
          let n = this._cachedIndex,
            i = t[n],
            r = t[n - 1];
          e: {
            t: {
              let s;
              n: {
                i: if (!(e < i)) {
                  for (let s = n + 2; ; ) {
                    if (void 0 === i) {
                      if (e < r) break i;
                      return (
                        (n = t.length),
                        (this._cachedIndex = n),
                        this.copySampleValue_(n - 1)
                      );
                    }
                    if (n === s) break;
                    if (((r = i), (i = t[++n]), e < i)) break t;
                  }
                  s = t.length;
                  break n;
                }
                if (e >= r) break e;
                {
                  const a = t[1];
                  e < a && ((n = 2), (r = a));
                  for (let s = n - 2; ; ) {
                    if (void 0 === r)
                      return (this._cachedIndex = 0), this.copySampleValue_(0);
                    if (n === s) break;
                    if (((i = r), (r = t[--n - 1]), e >= r)) break t;
                  }
                  (s = n), (n = 0);
                }
              }
              for (; n < s; ) {
                const i = (n + s) >>> 1;
                e < t[i] ? (s = i) : (n = i + 1);
              }
              if (((i = t[n]), (r = t[n - 1]), void 0 === r))
                return (this._cachedIndex = 0), this.copySampleValue_(0);
              if (void 0 === i)
                return (
                  (n = t.length),
                  (this._cachedIndex = n),
                  this.copySampleValue_(n - 1)
                );
            }
            (this._cachedIndex = n), this.intervalChanged_(n, r, i);
          }
          return this.interpolate_(n, r, e, i);
        }
        getSettings_() {
          return this.settings || this.DefaultSettings_;
        }
        copySampleValue_(e) {
          const t = this.resultBuffer,
            n = this.sampleValues,
            i = this.valueSize,
            r = e * i;
          for (let e = 0; e !== i; ++e) t[e] = n[r + e];
          return t;
        }
        interpolate_() {
          throw new Error("call to abstract method");
        }
        intervalChanged_() {}
      }
      class vs extends gs {
        constructor(e, t, n, i) {
          super(e, t, n, i),
            (this._weightPrev = -0),
            (this._offsetPrev = -0),
            (this._weightNext = -0),
            (this._offsetNext = -0),
            (this.DefaultSettings_ = { endingStart: 2400, endingEnd: 2400 });
        }
        intervalChanged_(e, t, n) {
          const i = this.parameterPositions;
          let r = e - 2,
            s = e + 1,
            a = i[r],
            o = i[s];
          if (void 0 === a)
            switch (this.getSettings_().endingStart) {
              case 2401:
                (r = e), (a = 2 * t - n);
                break;
              case 2402:
                (r = i.length - 2), (a = t + i[r] - i[r + 1]);
                break;
              default:
                (r = e), (a = n);
            }
          if (void 0 === o)
            switch (this.getSettings_().endingEnd) {
              case 2401:
                (s = e), (o = 2 * n - t);
                break;
              case 2402:
                (s = 1), (o = n + i[1] - i[0]);
                break;
              default:
                (s = e - 1), (o = t);
            }
          const l = 0.5 * (n - t),
            c = this.valueSize;
          (this._weightPrev = l / (t - a)),
            (this._weightNext = l / (o - n)),
            (this._offsetPrev = r * c),
            (this._offsetNext = s * c);
        }
        interpolate_(e, t, n, i) {
          const r = this.resultBuffer,
            s = this.sampleValues,
            a = this.valueSize,
            o = e * a,
            l = o - a,
            c = this._offsetPrev,
            u = this._offsetNext,
            h = this._weightPrev,
            d = this._weightNext,
            p = (n - t) / (i - t),
            f = p * p,
            m = f * p,
            g = -h * m + 2 * h * f - h * p,
            v = (1 + h) * m + (-1.5 - 2 * h) * f + (-0.5 + h) * p + 1,
            _ = (-1 - d) * m + (1.5 + d) * f + 0.5 * p,
            x = d * m - d * f;
          for (let e = 0; e !== a; ++e)
            r[e] = g * s[c + e] + v * s[l + e] + _ * s[o + e] + x * s[u + e];
          return r;
        }
      }
      class _s extends gs {
        constructor(e, t, n, i) {
          super(e, t, n, i);
        }
        interpolate_(e, t, n, i) {
          const r = this.resultBuffer,
            s = this.sampleValues,
            a = this.valueSize,
            o = e * a,
            l = o - a,
            c = (n - t) / (i - t),
            u = 1 - c;
          for (let e = 0; e !== a; ++e) r[e] = s[l + e] * u + s[o + e] * c;
          return r;
        }
      }
      class xs extends gs {
        constructor(e, t, n, i) {
          super(e, t, n, i);
        }
        interpolate_(e) {
          return this.copySampleValue_(e - 1);
        }
      }
      class ys {
        constructor(e, t, n, i) {
          if (void 0 === e)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
          if (void 0 === t || 0 === t.length)
            throw new Error(
              "THREE.KeyframeTrack: no keyframes in track named " + e
            );
          (this.name = e),
            (this.times = ms.convertArray(t, this.TimeBufferType)),
            (this.values = ms.convertArray(n, this.ValueBufferType)),
            this.setInterpolation(i || this.DefaultInterpolation);
        }
        static toJSON(e) {
          const t = e.constructor;
          let n;
          if (t.toJSON !== this.toJSON) n = t.toJSON(e);
          else {
            n = {
              name: e.name,
              times: ms.convertArray(e.times, Array),
              values: ms.convertArray(e.values, Array),
            };
            const t = e.getInterpolation();
            t !== e.DefaultInterpolation && (n.interpolation = t);
          }
          return (n.type = e.ValueTypeName), n;
        }
        InterpolantFactoryMethodDiscrete(e) {
          return new xs(this.times, this.values, this.getValueSize(), e);
        }
        InterpolantFactoryMethodLinear(e) {
          return new _s(this.times, this.values, this.getValueSize(), e);
        }
        InterpolantFactoryMethodSmooth(e) {
          return new vs(this.times, this.values, this.getValueSize(), e);
        }
        setInterpolation(e) {
          let t;
          switch (e) {
            case C:
              t = this.InterpolantFactoryMethodDiscrete;
              break;
            case L:
              t = this.InterpolantFactoryMethodLinear;
              break;
            case P:
              t = this.InterpolantFactoryMethodSmooth;
          }
          if (void 0 === t) {
            const t =
              "unsupported interpolation for " +
              this.ValueTypeName +
              " keyframe track named " +
              this.name;
            if (void 0 === this.createInterpolant) {
              if (e === this.DefaultInterpolation) throw new Error(t);
              this.setInterpolation(this.DefaultInterpolation);
            }
            return console.warn("THREE.KeyframeTrack:", t), this;
          }
          return (this.createInterpolant = t), this;
        }
        getInterpolation() {
          switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
              return C;
            case this.InterpolantFactoryMethodLinear:
              return L;
            case this.InterpolantFactoryMethodSmooth:
              return P;
          }
        }
        getValueSize() {
          return this.values.length / this.times.length;
        }
        shift(e) {
          if (0 !== e) {
            const t = this.times;
            for (let n = 0, i = t.length; n !== i; ++n) t[n] += e;
          }
          return this;
        }
        scale(e) {
          if (1 !== e) {
            const t = this.times;
            for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e;
          }
          return this;
        }
        trim(e, t) {
          const n = this.times,
            i = n.length;
          let r = 0,
            s = i - 1;
          for (; r !== i && n[r] < e; ) ++r;
          for (; -1 !== s && n[s] > t; ) --s;
          if ((++s, 0 !== r || s !== i)) {
            r >= s && ((s = Math.max(s, 1)), (r = s - 1));
            const e = this.getValueSize();
            (this.times = ms.arraySlice(n, r, s)),
              (this.values = ms.arraySlice(this.values, r * e, s * e));
          }
          return this;
        }
        validate() {
          let e = !0;
          const t = this.getValueSize();
          t - Math.floor(t) != 0 &&
            (console.error(
              "THREE.KeyframeTrack: Invalid value size in track.",
              this
            ),
            (e = !1));
          const n = this.times,
            i = this.values,
            r = n.length;
          0 === r &&
            (console.error("THREE.KeyframeTrack: Track is empty.", this),
            (e = !1));
          let s = null;
          for (let t = 0; t !== r; t++) {
            const i = n[t];
            if ("number" == typeof i && isNaN(i)) {
              console.error(
                "THREE.KeyframeTrack: Time is not a valid number.",
                this,
                t,
                i
              ),
                (e = !1);
              break;
            }
            if (null !== s && s > i) {
              console.error(
                "THREE.KeyframeTrack: Out of order keys.",
                this,
                t,
                i,
                s
              ),
                (e = !1);
              break;
            }
            s = i;
          }
          if (void 0 !== i && ms.isTypedArray(i))
            for (let t = 0, n = i.length; t !== n; ++t) {
              const n = i[t];
              if (isNaN(n)) {
                console.error(
                  "THREE.KeyframeTrack: Value is not a valid number.",
                  this,
                  t,
                  n
                ),
                  (e = !1);
                break;
              }
            }
          return e;
        }
        optimize() {
          const e = ms.arraySlice(this.times),
            t = ms.arraySlice(this.values),
            n = this.getValueSize(),
            i = this.getInterpolation() === P,
            r = e.length - 1;
          let s = 1;
          for (let a = 1; a < r; ++a) {
            let r = !1;
            const o = e[a];
            if (o !== e[a + 1] && (1 !== a || o !== e[0]))
              if (i) r = !0;
              else {
                const e = a * n,
                  i = e - n,
                  s = e + n;
                for (let a = 0; a !== n; ++a) {
                  const n = t[e + a];
                  if (n !== t[i + a] || n !== t[s + a]) {
                    r = !0;
                    break;
                  }
                }
              }
            if (r) {
              if (a !== s) {
                e[s] = e[a];
                const i = a * n,
                  r = s * n;
                for (let e = 0; e !== n; ++e) t[r + e] = t[i + e];
              }
              ++s;
            }
          }
          if (r > 0) {
            e[s] = e[r];
            for (let e = r * n, i = s * n, a = 0; a !== n; ++a)
              t[i + a] = t[e + a];
            ++s;
          }
          return (
            s !== e.length
              ? ((this.times = ms.arraySlice(e, 0, s)),
                (this.values = ms.arraySlice(t, 0, s * n)))
              : ((this.times = e), (this.values = t)),
            this
          );
        }
        clone() {
          const e = ms.arraySlice(this.times, 0),
            t = ms.arraySlice(this.values, 0),
            n = new (0, this.constructor)(this.name, e, t);
          return (n.createInterpolant = this.createInterpolant), n;
        }
      }
      (ys.prototype.TimeBufferType = Float32Array),
        (ys.prototype.ValueBufferType = Float32Array),
        (ys.prototype.DefaultInterpolation = L);
      class bs extends ys {}
      (bs.prototype.ValueTypeName = "bool"),
        (bs.prototype.ValueBufferType = Array),
        (bs.prototype.DefaultInterpolation = C),
        (bs.prototype.InterpolantFactoryMethodLinear = void 0),
        (bs.prototype.InterpolantFactoryMethodSmooth = void 0);
      (class extends ys {}).prototype.ValueTypeName = "color";
      (class extends ys {}).prototype.ValueTypeName = "number";
      class ws extends gs {
        constructor(e, t, n, i) {
          super(e, t, n, i);
        }
        interpolate_(e, t, n, i) {
          const r = this.resultBuffer,
            s = this.sampleValues,
            a = this.valueSize,
            o = (n - t) / (i - t);
          let l = e * a;
          for (let e = l + a; l !== e; l += 4)
            _e.slerpFlat(r, 0, s, l - a, s, l, o);
          return r;
        }
      }
      class Ss extends ys {
        InterpolantFactoryMethodLinear(e) {
          return new ws(this.times, this.values, this.getValueSize(), e);
        }
      }
      (Ss.prototype.ValueTypeName = "quaternion"),
        (Ss.prototype.DefaultInterpolation = L),
        (Ss.prototype.InterpolantFactoryMethodSmooth = void 0);
      class Ms extends ys {}
      (Ms.prototype.ValueTypeName = "string"),
        (Ms.prototype.ValueBufferType = Array),
        (Ms.prototype.DefaultInterpolation = C),
        (Ms.prototype.InterpolantFactoryMethodLinear = void 0),
        (Ms.prototype.InterpolantFactoryMethodSmooth = void 0);
      (class extends ys {}).prototype.ValueTypeName = "vector";
      new (class {
        constructor(e, t, n) {
          const i = this;
          let r,
            s = !1,
            a = 0,
            o = 0;
          const l = [];
          (this.onStart = void 0),
            (this.onLoad = e),
            (this.onProgress = t),
            (this.onError = n),
            (this.itemStart = function (e) {
              o++,
                !1 === s && void 0 !== i.onStart && i.onStart(e, a, o),
                (s = !0);
            }),
            (this.itemEnd = function (e) {
              a++,
                void 0 !== i.onProgress && i.onProgress(e, a, o),
                a === o && ((s = !1), void 0 !== i.onLoad && i.onLoad());
            }),
            (this.itemError = function (e) {
              void 0 !== i.onError && i.onError(e);
            }),
            (this.resolveURL = function (e) {
              return r ? r(e) : e;
            }),
            (this.setURLModifier = function (e) {
              return (r = e), this;
            }),
            (this.addHandler = function (e, t) {
              return l.push(e, t), this;
            }),
            (this.removeHandler = function (e) {
              const t = l.indexOf(e);
              return -1 !== t && l.splice(t, 2), this;
            }),
            (this.getHandler = function (e) {
              for (let t = 0, n = l.length; t < n; t += 2) {
                const n = l[t],
                  i = l[t + 1];
                if ((n.global && (n.lastIndex = 0), n.test(e))) return i;
              }
              return null;
            });
        }
      })();
      class Es extends bt {
        constructor(e, t = 1) {
          super(),
            (this.isLight = !0),
            (this.type = "Light"),
            (this.color = new oe(e)),
            (this.intensity = t);
        }
        dispose() {}
        copy(e, t) {
          return (
            super.copy(e, t),
            this.color.copy(e.color),
            (this.intensity = e.intensity),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.color = this.color.getHex()),
            (t.object.intensity = this.intensity),
            void 0 !== this.groundColor &&
              (t.object.groundColor = this.groundColor.getHex()),
            void 0 !== this.distance && (t.object.distance = this.distance),
            void 0 !== this.angle && (t.object.angle = this.angle),
            void 0 !== this.decay && (t.object.decay = this.decay),
            void 0 !== this.penumbra && (t.object.penumbra = this.penumbra),
            void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()),
            t
          );
        }
      }
      const Ts = new $e(),
        As = new xe(),
        Cs = new xe();
      const Ls = new $e(),
        Ps = new xe(),
        Ds = new xe();
      class ks extends class {
        constructor(e) {
          (this.camera = e),
            (this.bias = 0),
            (this.normalBias = 0),
            (this.radius = 1),
            (this.blurSamples = 8),
            (this.mapSize = new X(512, 512)),
            (this.map = null),
            (this.mapPass = null),
            (this.matrix = new $e()),
            (this.autoUpdate = !0),
            (this.needsUpdate = !1),
            (this._frustum = new Rn()),
            (this._frameExtents = new X(1, 1)),
            (this._viewportCount = 1),
            (this._viewports = [new fe(0, 0, 1, 1)]);
        }
        getViewportCount() {
          return this._viewportCount;
        }
        getFrustum() {
          return this._frustum;
        }
        updateMatrices(e) {
          const t = this.camera,
            n = this.matrix;
          As.setFromMatrixPosition(e.matrixWorld),
            t.position.copy(As),
            Cs.setFromMatrixPosition(e.target.matrixWorld),
            t.lookAt(Cs),
            t.updateMatrixWorld(),
            Ts.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(Ts),
            n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
            n.multiply(t.projectionMatrix),
            n.multiply(t.matrixWorldInverse);
        }
        getViewport(e) {
          return this._viewports[e];
        }
        getFrameExtents() {
          return this._frameExtents;
        }
        dispose() {
          this.map && this.map.dispose(),
            this.mapPass && this.mapPass.dispose();
        }
        copy(e) {
          return (
            (this.camera = e.camera.clone()),
            (this.bias = e.bias),
            (this.radius = e.radius),
            this.mapSize.copy(e.mapSize),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const e = {};
          return (
            0 !== this.bias && (e.bias = this.bias),
            0 !== this.normalBias && (e.normalBias = this.normalBias),
            1 !== this.radius && (e.radius = this.radius),
            (512 === this.mapSize.x && 512 === this.mapSize.y) ||
              (e.mapSize = this.mapSize.toArray()),
            (e.camera = this.camera.toJSON(!1).object),
            delete e.camera.matrix,
            e
          );
        }
      } {
        constructor() {
          super(new wn(90, 1, 0.5, 500)),
            (this.isPointLightShadow = !0),
            (this._frameExtents = new X(4, 2)),
            (this._viewportCount = 6),
            (this._viewports = [
              new fe(2, 1, 1, 1),
              new fe(0, 1, 1, 1),
              new fe(3, 1, 1, 1),
              new fe(1, 1, 1, 1),
              new fe(3, 0, 1, 1),
              new fe(1, 0, 1, 1),
            ]),
            (this._cubeDirections = [
              new xe(1, 0, 0),
              new xe(-1, 0, 0),
              new xe(0, 0, 1),
              new xe(0, 0, -1),
              new xe(0, 1, 0),
              new xe(0, -1, 0),
            ]),
            (this._cubeUps = [
              new xe(0, 1, 0),
              new xe(0, 1, 0),
              new xe(0, 1, 0),
              new xe(0, 1, 0),
              new xe(0, 0, 1),
              new xe(0, 0, -1),
            ]);
        }
        updateMatrices(e, t = 0) {
          const n = this.camera,
            i = this.matrix,
            r = e.distance || n.far;
          r !== n.far && ((n.far = r), n.updateProjectionMatrix()),
            Ps.setFromMatrixPosition(e.matrixWorld),
            n.position.copy(Ps),
            Ds.copy(n.position),
            Ds.add(this._cubeDirections[t]),
            n.up.copy(this._cubeUps[t]),
            n.lookAt(Ds),
            n.updateMatrixWorld(),
            i.makeTranslation(-Ps.x, -Ps.y, -Ps.z),
            Ls.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(Ls);
        }
      }
      class Rs extends Es {
        constructor(e, t, n = 0, i = 1) {
          super(e, t),
            (this.isPointLight = !0),
            (this.type = "PointLight"),
            (this.distance = n),
            (this.decay = i),
            (this.shadow = new ks());
        }
        get power() {
          return 4 * this.intensity * Math.PI;
        }
        set power(e) {
          this.intensity = e / (4 * Math.PI);
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.distance = e.distance),
            (this.decay = e.decay),
            (this.shadow = e.shadow.clone()),
            this
          );
        }
      }
      const Is = new RegExp("[\\[\\]\\.:\\/]", "g"),
        Fs = "[^\\[\\]\\.:\\/]",
        Os = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
        Ns = new RegExp(
          "^" +
            /((?:WC+[\/:])*)/.source.replace("WC", Fs) +
            /(WCOD+)?/.source.replace("WCOD", Os) +
            /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Fs) +
            /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Fs) +
            "$"
        ),
        zs = ["material", "materials", "bones"];
      class Bs {
        constructor(e, t, n) {
          (this.path = t),
            (this.parsedPath = n || Bs.parseTrackName(t)),
            (this.node = Bs.findNode(e, this.parsedPath.nodeName) || e),
            (this.rootNode = e),
            (this.getValue = this._getValue_unbound),
            (this.setValue = this._setValue_unbound);
        }
        static create(e, t, n) {
          return e && e.isAnimationObjectGroup
            ? new Bs.Composite(e, t, n)
            : new Bs(e, t, n);
        }
        static sanitizeNodeName(e) {
          return e.replace(/\s/g, "_").replace(Is, "");
        }
        static parseTrackName(e) {
          const t = Ns.exec(e);
          if (null === t)
            throw new Error("PropertyBinding: Cannot parse trackName: " + e);
          const n = {
              nodeName: t[2],
              objectName: t[3],
              objectIndex: t[4],
              propertyName: t[5],
              propertyIndex: t[6],
            },
            i = n.nodeName && n.nodeName.lastIndexOf(".");
          if (void 0 !== i && -1 !== i) {
            const e = n.nodeName.substring(i + 1);
            -1 !== zs.indexOf(e) &&
              ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = e));
          }
          if (null === n.propertyName || 0 === n.propertyName.length)
            throw new Error(
              "PropertyBinding: can not parse propertyName from trackName: " + e
            );
          return n;
        }
        static findNode(e, t) {
          if (
            void 0 === t ||
            "" === t ||
            "." === t ||
            -1 === t ||
            t === e.name ||
            t === e.uuid
          )
            return e;
          if (e.skeleton) {
            const n = e.skeleton.getBoneByName(t);
            if (void 0 !== n) return n;
          }
          if (e.children) {
            const n = function (e) {
                for (let i = 0; i < e.length; i++) {
                  const r = e[i];
                  if (r.name === t || r.uuid === t) return r;
                  const s = n(r.children);
                  if (s) return s;
                }
                return null;
              },
              i = n(e.children);
            if (i) return i;
          }
          return null;
        }
        _getValue_unavailable() {}
        _setValue_unavailable() {}
        _getValue_direct(e, t) {
          e[t] = this.targetObject[this.propertyName];
        }
        _getValue_array(e, t) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) e[t++] = n[i];
        }
        _getValue_arrayElement(e, t) {
          e[t] = this.resolvedProperty[this.propertyIndex];
        }
        _getValue_toArray(e, t) {
          this.resolvedProperty.toArray(e, t);
        }
        _setValue_direct(e, t) {
          this.targetObject[this.propertyName] = e[t];
        }
        _setValue_direct_setNeedsUpdate(e, t) {
          (this.targetObject[this.propertyName] = e[t]),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
          (this.targetObject[this.propertyName] = e[t]),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _setValue_array(e, t) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
        }
        _setValue_array_setNeedsUpdate(e, t) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
          this.targetObject.needsUpdate = !0;
        }
        _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
          this.targetObject.matrixWorldNeedsUpdate = !0;
        }
        _setValue_arrayElement(e, t) {
          this.resolvedProperty[this.propertyIndex] = e[t];
        }
        _setValue_arrayElement_setNeedsUpdate(e, t) {
          (this.resolvedProperty[this.propertyIndex] = e[t]),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
          (this.resolvedProperty[this.propertyIndex] = e[t]),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _setValue_fromArray(e, t) {
          this.resolvedProperty.fromArray(e, t);
        }
        _setValue_fromArray_setNeedsUpdate(e, t) {
          this.resolvedProperty.fromArray(e, t),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
          this.resolvedProperty.fromArray(e, t),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _getValue_unbound(e, t) {
          this.bind(), this.getValue(e, t);
        }
        _setValue_unbound(e, t) {
          this.bind(), this.setValue(e, t);
        }
        bind() {
          let e = this.node;
          const t = this.parsedPath,
            n = t.objectName,
            i = t.propertyName;
          let r = t.propertyIndex;
          if (
            (e ||
              ((e = Bs.findNode(this.rootNode, t.nodeName) || this.rootNode),
              (this.node = e)),
            (this.getValue = this._getValue_unavailable),
            (this.setValue = this._setValue_unavailable),
            !e)
          )
            return void console.error(
              "THREE.PropertyBinding: Trying to update node for track: " +
                this.path +
                " but it wasn't found."
            );
          if (n) {
            let i = t.objectIndex;
            switch (n) {
              case "materials":
                if (!e.material)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                    this
                  );
                if (!e.material.materials)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                    this
                  );
                e = e.material.materials;
                break;
              case "bones":
                if (!e.skeleton)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                    this
                  );
                e = e.skeleton.bones;
                for (let t = 0; t < e.length; t++)
                  if (e[t].name === i) {
                    i = t;
                    break;
                  }
                break;
              default:
                if (void 0 === e[n])
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                    this
                  );
                e = e[n];
            }
            if (void 0 !== i) {
              if (void 0 === e[i])
                return void console.error(
                  "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                  this,
                  e
                );
              e = e[i];
            }
          }
          const s = e[i];
          if (void 0 === s) {
            const n = t.nodeName;
            return void console.error(
              "THREE.PropertyBinding: Trying to update property for track: " +
                n +
                "." +
                i +
                " but it wasn't found.",
              e
            );
          }
          let a = this.Versioning.None;
          (this.targetObject = e),
            void 0 !== e.needsUpdate
              ? (a = this.Versioning.NeedsUpdate)
              : void 0 !== e.matrixWorldNeedsUpdate &&
                (a = this.Versioning.MatrixWorldNeedsUpdate);
          let o = this.BindingType.Direct;
          if (void 0 !== r) {
            if ("morphTargetInfluences" === i) {
              if (!e.geometry)
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                  this
                );
              if (!e.geometry.morphAttributes)
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                  this
                );
              void 0 !== e.morphTargetDictionary[r] &&
                (r = e.morphTargetDictionary[r]);
            }
            (o = this.BindingType.ArrayElement),
              (this.resolvedProperty = s),
              (this.propertyIndex = r);
          } else
            void 0 !== s.fromArray && void 0 !== s.toArray
              ? ((o = this.BindingType.HasFromToArray),
                (this.resolvedProperty = s))
              : Array.isArray(s)
              ? ((o = this.BindingType.EntireArray),
                (this.resolvedProperty = s))
              : (this.propertyName = i);
          (this.getValue = this.GetterByBindingType[o]),
            (this.setValue = this.SetterByBindingTypeAndVersioning[o][a]);
        }
        unbind() {
          (this.node = null),
            (this.getValue = this._getValue_unbound),
            (this.setValue = this._setValue_unbound);
        }
      }
      (Bs.Composite = class {
        constructor(e, t, n) {
          const i = n || Bs.parseTrackName(t);
          (this._targetGroup = e), (this._bindings = e.subscribe_(t, i));
        }
        getValue(e, t) {
          this.bind();
          const n = this._targetGroup.nCachedObjects_,
            i = this._bindings[n];
          void 0 !== i && i.getValue(e, t);
        }
        setValue(e, t) {
          const n = this._bindings;
          for (
            let i = this._targetGroup.nCachedObjects_, r = n.length;
            i !== r;
            ++i
          )
            n[i].setValue(e, t);
        }
        bind() {
          const e = this._bindings;
          for (
            let t = this._targetGroup.nCachedObjects_, n = e.length;
            t !== n;
            ++t
          )
            e[t].bind();
        }
        unbind() {
          const e = this._bindings;
          for (
            let t = this._targetGroup.nCachedObjects_, n = e.length;
            t !== n;
            ++t
          )
            e[t].unbind();
        }
      }),
        (Bs.prototype.BindingType = {
          Direct: 0,
          EntireArray: 1,
          ArrayElement: 2,
          HasFromToArray: 3,
        }),
        (Bs.prototype.Versioning = {
          None: 0,
          NeedsUpdate: 1,
          MatrixWorldNeedsUpdate: 2,
        }),
        (Bs.prototype.GetterByBindingType = [
          Bs.prototype._getValue_direct,
          Bs.prototype._getValue_array,
          Bs.prototype._getValue_arrayElement,
          Bs.prototype._getValue_toArray,
        ]),
        (Bs.prototype.SetterByBindingTypeAndVersioning = [
          [
            Bs.prototype._setValue_direct,
            Bs.prototype._setValue_direct_setNeedsUpdate,
            Bs.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
          ],
          [
            Bs.prototype._setValue_array,
            Bs.prototype._setValue_array_setNeedsUpdate,
            Bs.prototype._setValue_array_setMatrixWorldNeedsUpdate,
          ],
          [
            Bs.prototype._setValue_arrayElement,
            Bs.prototype._setValue_arrayElement_setNeedsUpdate,
            Bs.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
          ],
          [
            Bs.prototype._setValue_fromArray,
            Bs.prototype._setValue_fromArray_setNeedsUpdate,
            Bs.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
          ],
        ]);
      class Us {
        constructor(e) {
          "string" == typeof e &&
            (console.warn("THREE.Uniform: Type parameter is no longer needed."),
            (e = arguments[1])),
            (this.value = e);
        }
        clone() {
          return new Us(
            void 0 === this.value.clone ? this.value : this.value.clone()
          );
        }
      }
      const {
        floatView: Vs,
        uint32View: Gs,
        baseTable: Hs,
        shiftTable: Ws,
        mantissaTable: js,
        exponentTable: qs,
        offsetTable: Xs,
      } = Ys();
      function Ys() {
        const e = new ArrayBuffer(4),
          t = new Float32Array(e),
          n = new Uint32Array(e),
          i = new Uint32Array(512),
          r = new Uint32Array(512);
        for (let e = 0; e < 256; ++e) {
          const t = e - 127;
          t < -27
            ? ((i[e] = 0), (i[256 | e] = 32768), (r[e] = 24), (r[256 | e] = 24))
            : t < -14
            ? ((i[e] = 1024 >> (-t - 14)),
              (i[256 | e] = (1024 >> (-t - 14)) | 32768),
              (r[e] = -t - 1),
              (r[256 | e] = -t - 1))
            : t <= 15
            ? ((i[e] = (t + 15) << 10),
              (i[256 | e] = ((t + 15) << 10) | 32768),
              (r[e] = 13),
              (r[256 | e] = 13))
            : t < 128
            ? ((i[e] = 31744),
              (i[256 | e] = 64512),
              (r[e] = 24),
              (r[256 | e] = 24))
            : ((i[e] = 31744),
              (i[256 | e] = 64512),
              (r[e] = 13),
              (r[256 | e] = 13));
        }
        const s = new Uint32Array(2048),
          a = new Uint32Array(64),
          o = new Uint32Array(64);
        for (let e = 1; e < 1024; ++e) {
          let t = e << 13,
            n = 0;
          for (; 0 == (8388608 & t); ) (t <<= 1), (n -= 8388608);
          (t &= -8388609), (n += 947912704), (s[e] = t | n);
        }
        for (let e = 1024; e < 2048; ++e) s[e] = 939524096 + ((e - 1024) << 13);
        for (let e = 1; e < 31; ++e) a[e] = e << 23;
        (a[31] = 1199570944), (a[32] = 2147483648);
        for (let e = 33; e < 63; ++e) a[e] = 2147483648 + ((e - 32) << 23);
        a[63] = 3347054592;
        for (let e = 1; e < 64; ++e) 32 !== e && (o[e] = 1024);
        return {
          floatView: t,
          uint32View: n,
          baseTable: i,
          shiftTable: r,
          mantissaTable: s,
          exponentTable: a,
          offsetTable: o,
        };
      }
      "undefined" != typeof __THREE_DEVTOOLS__ &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("register", { detail: { revision: "142" } })
        ),
        "undefined" != typeof window &&
          (window.__THREE__
            ? console.warn(
                "WARNING: Multiple instances of Three.js being imported."
              )
            : (window.__THREE__ = "142"));
      var Zs = (function () {
        var e = [],
          t = function (n) {
            e.forEach(function (e) {
              e(n);
            }),
              requestAnimationFrame(t);
          };
        return {
          start: function () {
            return requestAnimationFrame(t);
          },
          addRenderCallback: function (t) {
            return e.push(t);
          },
        };
      })();
      Zs.start();
      const $s = Zs;
      
      
      var Ks,Js = ((Ks = function (e, t) {
            return (
              (Ks =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (e, t) {
                    e.__proto__ = t;
                  }) ||
                function (e, t) {
                  for (var n in t)
                    Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
                }),
              Ks(e, t)
            );
          }),

          function (e, t) {
            if ("function" != typeof t && null !== t)
              throw new TypeError(
                "Class extends value " +
                  String(t) +
                  " is not a constructor or null"
              );
            function n() {
              this.constructor = e;
            }
            Ks(e, t),
              (e.prototype =
                null === t
                  ? Object.create(t)
                  : ((n.prototype = t.prototype), new n()));
          }),
        aims_list = ["", " ", ""];
      
        const ea = (function (e) {
        function t(t) {
          var n = e.call(this, t) || this;
          (n.canvasContainer = null), (n.currentLine = 0);

          var welcome_sec = document.querySelector(".".concat("welcome"));

          if (!welcome_sec) throw new Error("Cant initialize Welcome Screen");
          
          (n.root = welcome_sec),
            (n.canvasContainer = n.root.querySelector(
              ".".concat("welcome__canvas-container")
            )),
            n.processCanvas();
          var r = n.root.querySelector(".".concat("js-typing"));
          return (
            r &&
              ((n.typingController = new s(r)),
              n.typingController.forceClear()),
            n.startSwapLines(),
            n
          );
        }


        return (
          Js(t, e),
          (t.prototype.hide = function () {
            e.prototype.hide.call(this);
          }),
          (t.prototype.show = function () {
            e.prototype.show.call(this);
          }),
          (t.prototype.isCanBeChanged = function (e) {
            return (
              this.currentLine === aims_list.length - 1 &&
              !this.typingController.getIsPrinting()
            );
          }),
          (t.prototype.processCanvas = function () {
            var e = this;
            if (this.canvasContainer) {
              var t = new hs({
                premultipliedAlpha: !1,
                alpha: !0,
                antialias: !0,
              });
              this.canvasContainer.appendChild(t.domElement);
              var n = new ds(),
                i = new wn();
              n.add(i);
              var r = 0,
                s = new fn(
                  new ps(1, 50, 50),
                  new yn({
                    vertexShader:
                      "\n    #include <common>\n    #include <fog_pars_vertex>\n    #include <shadowmap_pars_vertex>\n    \n    varying vec3 vNormal;\n    varying vec3 vPosition;\n    varying vec2 vUv;\n\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                             vec2(12.9898,78.233)))\n                     * 43758.5453123);\n    }\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n    \n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n    \n        vec2 u = f*f*(3.0-2.0*f);\n    \n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    uniform float time;\n\n    void main() {\n        vNormal = normal;\n        vPosition = position;\n        vUv = uv;\n        \n        vec3 pos = position + vNormal * noise(vec2(vPosition.x*2.+time/500., vPosition.y+time/100.));\n               \n        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\n    }\n\n",
                    fragmentShader:
                      "\n    varying vec3 vNormal;\n    varying vec3 vPosition;\n    varying vec2 vUv;\n\n    uniform float time;\n\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                             vec2(12.9898,78.233)))\n                     * 43758.5453123);\n    }\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n    \n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n    \n        vec2 u = f*f*(3.0-2.0*f);\n    \n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    vec3 rgb2hsv(vec3 c)\n    {\n        vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n        vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n        vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n    \n        float d = q.x - min(q.w, q.y);\n        float e = 1.0e-10;\n        return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n    }\n\n    void main() {\n    \n      float light = dot(\n        vec3(0., 1., 1.),\n        vNormal\n      );\n\n      vec2 tUv = fract(vUv*100.);\n      \n      float point = 1. - distance(vec2(.5), tUv);\n      float part = smoothstep(.8, .85 + .5*vPosition.z/5., point);\n      \n      \n      vec3 baseColor = vPosition - abs(sin(time/200.))/2.;\n      \n      vec3 color = mix(\n        baseColor,\n        baseColor - vec3(-.3, .3, .3),\n        light\n      );\n      \n      gl_FragColor = vec4(color, part);\n    }\n",
                    uniforms: { time: { value: r } },
                  })
                );
              s.position.set(0, 0, -5), n.add(s);
              var a = function () {
                var n, r;
                (t.domElement.style.display = "none"),
                  (t.domElement.width = n = e.canvasContainer.clientWidth),
                  (t.domElement.height = r = e.canvasContainer.clientHeight),
                  t.setViewport(0, 0, n, r),
                  i.updateProjectionMatrix(),
                  (t.domElement.style.display = "block");
              };
              a();
              var o = !0;
              new IntersectionObserver(function (e, t) {
                var n;
                o =
                  null === (n = e[0]) || void 0 === n
                    ? void 0
                    : n.isIntersecting;
              }).observe(t.domElement),
                window.addEventListener("resize", function () {
                  a();
                }),
                $s.addRenderCallback(function (e) {
                  o &&
                    (t.clear(),
                    r++,
                    (s.material.uniforms.time.value = r),
                    t.render(n, i));
                });
            }
          }),
          (t.prototype.startSwapLines = function () {
            var e, t, n, i, r;
            return (
              (t = this),
              (n = void 0),
              (r = function () {
                var t,
                  n = this;
                return (function (e, t) {
                  var n,
                    i,
                    r,
                    s,
                    a = {
                      label: 0,
                      sent: function () {
                        if (1 & r[0]) throw r[1];
                        return r[1];
                      },
                      trys: [],
                      ops: [],
                    };
                  return (
                    (s = { next: o(0), throw: o(1), return: o(2) }),
                    "function" == typeof Symbol &&
                      (s[Symbol.iterator] = function () {
                        return this;
                      }),
                    s
                  );
                  function o(s) {
                    return function (o) {
                      return (function (s) {
                        if (n)
                          throw new TypeError(
                            "Generator is already executing."
                          );
                        for (; a; )
                          try {
                            if (
                              ((n = 1),
                              i &&
                                (r =
                                  2 & s[0]
                                    ? i.return
                                    : s[0]
                                    ? i.throw ||
                                      ((r = i.return) && r.call(i), 0)
                                    : i.next) &&
                                !(r = r.call(i, s[1])).done)
                            )
                              return r;
                            switch (
                              ((i = 0), r && (s = [2 & s[0], r.value]), s[0])
                            ) {
                              case 0:
                              case 1:
                                r = s;
                                break;
                              case 4:
                                return a.label++, { value: s[1], done: !1 };
                              case 5:
                                a.label++, (i = s[1]), (s = [0]);
                                continue;
                              case 7:
                                (s = a.ops.pop()), a.trys.pop();
                                continue;
                              default:
                                if (
                                  !(
                                    (r =
                                      (r = a.trys).length > 0 &&
                                      r[r.length - 1]) ||
                                    (6 !== s[0] && 2 !== s[0])
                                  )
                                ) {
                                  a = 0;
                                  continue;
                                }
                                if (
                                  3 === s[0] &&
                                  (!r || (s[1] > r[0] && s[1] < r[3]))
                                ) {
                                  a.label = s[1];
                                  break;
                                }
                                if (6 === s[0] && a.label < r[1]) {
                                  (a.label = r[1]), (r = s);
                                  break;
                                }
                                if (r && a.label < r[2]) {
                                  (a.label = r[2]), a.ops.push(s);
                                  break;
                                }
                                r[2] && a.ops.pop(), a.trys.pop();
                                continue;
                            }
                            s = t.call(e, a);
                          } catch (e) {
                            (s = [6, e]), (i = 0);
                          } finally {
                            n = r = 0;
                          }
                        if (5 & s[0]) throw s[1];
                        return { value: s[0] ? s[1] : void 0, done: !0 };
                      })([s, o]);
                    };
                  }
                })(this, function (i) {
                  switch (i.label) {
                    case 0:
                      return (
                        (t =
                          this.currentLine + 1 === aims_list.length - 1
                            ? 0
                            : this.currentLine + 1),
                        (this.currentLine = t),
                        [
                          4,
                          null === (e = this.typingController) || void 0 === e
                            ? void 0
                            : e.changeTo(aims_list[t]),
                        ]
                      );
                    case 1:
                      return (
                        i.sent(),
                        setTimeout(function () {
                          n.startSwapLines();
                        }, 1500),
                        [2]
                      );
                  }
                });
              }),
              new ((i = void 0) || (i = Promise))(function (e, s) {
                function a(e) {
                  try {
                    l(r.next(e));
                  } catch (e) {
                    s(e);
                  }
                }
                function o(e) {
                  try {
                    l(r.throw(e));
                  } catch (e) {
                    s(e);
                  }
                }
                function l(t) {
                  var n;
                  t.done
                    ? e(t.value)
                    : ((n = t.value),
                      n instanceof i
                        ? n
                        : new i(function (e) {
                            e(n);
                          })).then(a, o);
                }
                l((r = r.apply(t, n || [])).next());
              })
            );
          }),
          t
        );
      })(t);



      var ta = (function () {
          var e = function (t, n) {
            return (
              (e =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (e, t) {
                    e.__proto__ = t;
                  }) ||
                function (e, t) {
                  for (var n in t)
                    Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
                }),
              e(t, n)
            );
          };
          return function (t, n) {
            if ("function" != typeof n && null !== n)
              throw new TypeError(
                "Class extends value " +
                  String(n) +
                  " is not a constructor or null"
              );
            function i() {
              this.constructor = t;
            }
            e(t, n),
              (t.prototype =
                null === n
                  ? Object.create(n)
                  : ((i.prototype = n.prototype), new i()));
          };
        })(),
        na = "current";
      const ia = (function (e) {
        function t(t) {
          var n = e.call(this, t) || this;
          (n.canvasRoot = null), (n.body = null);
          var i = document.querySelector(".".concat("steps"));
          if (!i) throw new Error("Cant initialize Steps Screen");
          (n.root = i),
            (n.stepsList = n.root.querySelectorAll(".".concat("steps__item"))),
            (n.currentStep = Array.from(n.stepsList).findIndex(function (e) {
              return e.classList.contains(na);
            })),
            (n.canvasRoot = n.root.querySelector(
              ".".concat("steps__canvas-container")
            )),
            n.canvasRoot && n.processCanvas(),
            n.changeCurrentStep(n.calculateCurrentStep());
          var r = n.root.querySelector(".".concat("screen__body"));
          if (!r) throw new Error("Cant initialize Body Steps Screen");
          return (
            (n.body = r),
            n.changeCurrentStep(n.calculateCurrentStep()),
            n.addListeners(),
            n
          );
        }
        return (
          ta(t, e),
          (t.prototype.changeCurrentStep = function (e) {
            var t = this;
            setTimeout(function () {
              t.stepsList[t.currentStep].classList.remove(na),
                (t.currentStep = e),
                t.stepsList[t.currentStep].classList.add(na);
            }, 0);
          }),
          (t.prototype.isCanBeChanged = function (e) {
            return !0;
          }),
          (t.prototype.calculateCurrentStep = function () {
            var e =
              ((window.scrollY - window.innerHeight / 2) /
                (this.root.offsetTop + this.root.clientHeight)) *
              2;
            (e = Math.min(1, e)), (e = Math.max(0, e));
            var t = Math.floor(e * this.stepsList.length - 1);
            return (t = Math.min(this.stepsList.length - 1, t)), Math.max(0, t);
          }),
          (t.prototype.addListeners = function () {
            var e = this;
            window.addEventListener("scroll", function () {
              e.changeCurrentStep(e.calculateCurrentStep());
            });
          }),
          (t.prototype.processCanvas = function () {
            var e, t, n, i, r;
            return (
              (t = this),
              (n = void 0),
              (r = function () {
                var t,
                  n,
                  i,
                  r,
                  s,
                  a,
                  o,
                  l,
                  c,
                  u,
                  h,
                  d = this;
                return (function (e, t) {
                  var n,
                    i,
                    r,
                    s,
                    a = {
                      label: 0,
                      sent: function () {
                        if (1 & r[0]) throw r[1];
                        return r[1];
                      },
                      trys: [],
                      ops: [],
                    };
                  return (
                    (s = { next: o(0), throw: o(1), return: o(2) }),
                    "function" == typeof Symbol &&
                      (s[Symbol.iterator] = function () {
                        return this;
                      }),
                    s
                  );
                  function o(s) {
                    return function (o) {
                      return (function (s) {
                        if (n)
                          throw new TypeError(
                            "Generator is already executing."
                          );
                        for (; a; )
                          try {
                            if (
                              ((n = 1),
                              i &&
                                (r =
                                  2 & s[0]
                                    ? i.return
                                    : s[0]
                                    ? i.throw ||
                                      ((r = i.return) && r.call(i), 0)
                                    : i.next) &&
                                !(r = r.call(i, s[1])).done)
                            )
                              return r;
                            switch (
                              ((i = 0), r && (s = [2 & s[0], r.value]), s[0])
                            ) {
                              case 0:
                              case 1:
                                r = s;
                                break;
                              case 4:
                                return a.label++, { value: s[1], done: !1 };
                              case 5:
                                a.label++, (i = s[1]), (s = [0]);
                                continue;
                              case 7:
                                (s = a.ops.pop()), a.trys.pop();
                                continue;
                              default:
                                if (
                                  !(
                                    (r =
                                      (r = a.trys).length > 0 &&
                                      r[r.length - 1]) ||
                                    (6 !== s[0] && 2 !== s[0])
                                  )
                                ) {
                                  a = 0;
                                  continue;
                                }
                                if (
                                  3 === s[0] &&
                                  (!r || (s[1] > r[0] && s[1] < r[3]))
                                ) {
                                  a.label = s[1];
                                  break;
                                }
                                if (6 === s[0] && a.label < r[1]) {
                                  (a.label = r[1]), (r = s);
                                  break;
                                }
                                if (r && a.label < r[2]) {
                                  (a.label = r[2]), a.ops.push(s);
                                  break;
                                }
                                r[2] && a.ops.pop(), a.trys.pop();
                                continue;
                            }
                            s = t.call(e, a);
                          } catch (e) {
                            (s = [6, e]), (i = 0);
                          } finally {
                            n = r = 0;
                          }
                        if (5 & s[0]) throw s[1];
                        return { value: s[0] ? s[1] : void 0, done: !0 };
                      })([s, o]);
                    };
                  }
                })(this, function (p) {
                  return (
                    (n = new ds()),
                    (t = new hs({
                      antialias: !0,
                      alpha: !0,
                      premultipliedAlpha: !1,
                    })),
                    (i = new wn()),
                    (r = new fn(
                      new fs(1, 0.4, 250, 250),
                      new yn({
                        vertexShader:
                          "\n    varying vec3 vNormal;\n    varying vec3 vPosition;\n    varying vec2 vUv;\n    varying vec3 vDistortion;\n\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                             vec2(12.9898,78.233)))\n                     * 43758.5453123);\n    }\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n    \n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n    \n        vec2 u = f*f*(3.0-2.0*f);\n    \n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    uniform float time;\n    uniform vec2 mouse;\n\n    void main() {\n        vNormal = normal;\n        vUv = uv;\n        \n        vec3 nMouse = vec3(mouse, 0.);\n        vec3 mouseDiff = nMouse - vNormal;\n        float mouseDiffVal = length(mouseDiff);\n        float mouseDistVal = 1. - distance(nMouse, vPosition);\n         \n        vDistortion = vNormal * noise(position.zx * 2. + time/2000.)  * .4;\n        \n        vPosition = position + vDistortion;\n               \n        gl_Position = projectionMatrix * modelViewMatrix * vec4(vPosition, 1.);\n    }\n\n",
                        fragmentShader:
                          "\n    varying vec3 vNormal;\n    varying vec3 vPosition;\n    varying vec2 vUv;\n    varying vec3 vDistortion;\n\n    uniform float time;\n    uniform vec2 mouse;\n\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                             vec2(12.9898,78.233)))\n                     * 43758.5453123);\n    }\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n    \n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n    \n        vec2 u = f*f*(3.0-2.0*f);\n    \n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main() {\n        vec3 color = vec3(1., 0., 0.);\n        \n        vec3 dx = dFdx(vPosition);\n        vec3 dy = dFdy(vPosition);\n        vec3 rNormal = normalize(cross(dx, dy));\n        \n        float[12] lights = float[12](\n            0. + mouse.x, 2., 1.,               1.,\n            20., 10., 20.,                      .3, \n            -20., -10. + mouse.y * 10., 20.,    1.3\n        );\n        \n        float light = 0.;\n        float specular = 0.;\n        \n        for(int i = 0; i < 12; i = i + 4) {\n            vec3 lightPos = vec3(lights[i], lights[i+1], lights[i+2]);\n            vec3 lightSurfDir = lightPos - vPosition;\n            \n            light += dot(normalize(lightSurfDir), rNormal) * lights[i+3];\n            \n            vec3 halfEye = normalize(vPosition + lightSurfDir); \n            specular += pow(max(dot(halfEye, rNormal), 0.), 10.) * lights[i+3];\n        }\n       \n        gl_FragColor = vec4(rNormal * light + specular + 1. - distance(vec3(mouse, vPosition.z), vPosition), 1.);\n    }\n",
                        uniforms: {
                          time: new Us("f", 0),
                          mouse: new Us("f", [0, 0]),
                        },
                      })
                    )),
                    (s = [0, 0]),
                    (a = 0.05),
                    t.domElement.addEventListener("mousemove", function (e) {
                      (s[0] = 2 * (e.offsetX / t.domElement.clientWidth - 0.5)),
                        (s[1] =
                          2 * -(e.offsetY / t.domElement.clientHeight - 0.5)),
                        (a = 0.3);
                    }),
                    t.domElement.addEventListener("mouseleave", function (e) {
                      (s = [0, 0]), (a = 0.01);
                    }),
                    (o = [0, 0]),
                    r.position.set(0, 0, -5),
                    n.add(r),
                    (l = new Rs(16777215, 2)).position.set(0, 0, 1),
                    n.add(l),
                    (c = function () {
                      var e = t.domElement;
                      e.style.display = "none";
                      var n = d.canvasRoot.clientWidth,
                        r = d.canvasRoot.clientHeight;
                      (e.width = n),
                        (e.height = r),
                        t.setViewport(0, 0, n, r),
                        i.updateProjectionMatrix(),
                        (e.style.display = "block");
                    }),
                    null === (e = this.canvasRoot) ||
                      void 0 === e ||
                      e.appendChild(t.domElement),
                    c(),
                    window.addEventListener("resize", function () {
                      c();
                    }),
                    (u = !0),
                    (h = new IntersectionObserver(function (e, t) {
                      var n;
                      u =
                        null === (n = e[0]) || void 0 === n
                          ? void 0
                          : n.isIntersecting;
                    })),
                    h.observe(t.domElement),
                    $s.addRenderCallback(function (e) {
                      u &&
                        ((o[0] += (s[0] - o[0]) * a),
                        (o[1] += (s[1] - o[1]) * a),
                        (r.material.uniforms.time.value = e),
                        (r.material.uniforms.mouse.value = o),
                        t.render(n, i));
                    }),
                    [2]
                  );
                });
              }),
              new ((i = void 0) || (i = Promise))(function (e, s) {
                function a(e) {
                  try {
                    l(r.next(e));
                  } catch (e) {
                    s(e);
                  }
                }
                function o(e) {
                  try {
                    l(r.throw(e));
                  } catch (e) {
                    s(e);
                  }
                }
                function l(t) {
                  var n;
                  t.done
                    ? e(t.value)
                    : ((n = t.value),
                      n instanceof i
                        ? n
                        : new i(function (e) {
                            e(n);
                          })).then(a, o);
                }
                l((r = r.apply(t, n || [])).next());
              })
            );
          }),
          t
        );
      })(t);
      function ra(e) {
        return (
          null !== e &&
          "object" == typeof e &&
          "constructor" in e &&
          e.constructor === Object
        );
      }
      function sa(e = {}, t = {}) {
        Object.keys(t).forEach((n) => {
          void 0 === e[n]
            ? (e[n] = t[n])
            : ra(t[n]) &&
              ra(e[n]) &&
              Object.keys(t[n]).length > 0 &&
              sa(e[n], t[n]);
        });
      }
      const aa = {
        body: {},
        addEventListener() {},
        removeEventListener() {},
        activeElement: { blur() {}, nodeName: "" },
        querySelector: () => null,
        querySelectorAll: () => [],
        getElementById: () => null,
        createEvent: () => ({ initEvent() {} }),
        createElement: () => ({
          children: [],
          childNodes: [],
          style: {},
          setAttribute() {},
          getElementsByTagName: () => [],
        }),
        createElementNS: () => ({}),
        importNode: () => null,
        location: {
          hash: "",
          host: "",
          hostname: "",
          href: "",
          origin: "",
          pathname: "",
          protocol: "",
          search: "",
        },
      };
      function oa() {
        const e = "undefined" != typeof document ? document : {};
        return sa(e, aa), e;
      }
      const la = {
        document: aa,
        navigator: { userAgent: "" },
        location: {
          hash: "",
          host: "",
          hostname: "",
          href: "",
          origin: "",
          pathname: "",
          protocol: "",
          search: "",
        },
        history: { replaceState() {}, pushState() {}, go() {}, back() {} },
        CustomEvent: function () {
          return this;
        },
        addEventListener() {},
        removeEventListener() {},
        getComputedStyle: () => ({ getPropertyValue: () => "" }),
        Image() {},
        Date() {},
        screen: {},
        setTimeout() {},
        clearTimeout() {},
        matchMedia: () => ({}),
        requestAnimationFrame: (e) =>
          "undefined" == typeof setTimeout ? (e(), null) : setTimeout(e, 0),
        cancelAnimationFrame(e) {
          "undefined" != typeof setTimeout && clearTimeout(e);
        },
      };
      function ca() {
        const e = "undefined" != typeof window ? window : {};
        return sa(e, la), e;
      }
      class ua extends Array {
        constructor(e) {
          "number" == typeof e
            ? super(e)
            : (super(...(e || [])),
              (function (e) {
                const t = e.__proto__;
                Object.defineProperty(e, "__proto__", {
                  get: () => t,
                  set(e) {
                    t.__proto__ = e;
                  },
                });
              })(this));
        }
      }
      function ha(e = []) {
        const t = [];
        return (
          e.forEach((e) => {
            Array.isArray(e) ? t.push(...ha(e)) : t.push(e);
          }),
          t
        );
      }
      function da(e, t) {
        return Array.prototype.filter.call(e, t);
      }
      function pa(e, t) {
        const n = ca(),
          i = oa();
        let r = [];
        if (!t && e instanceof ua) return e;
        if (!e) return new ua(r);
        if ("string" == typeof e) {
          const n = e.trim();
          if (n.indexOf("<") >= 0 && n.indexOf(">") >= 0) {
            let e = "div";
            0 === n.indexOf("<li") && (e = "ul"),
              0 === n.indexOf("<tr") && (e = "tbody"),
              (0 !== n.indexOf("<td") && 0 !== n.indexOf("<th")) || (e = "tr"),
              0 === n.indexOf("<tbody") && (e = "table"),
              0 === n.indexOf("<option") && (e = "select");
            const t = i.createElement(e);
            t.innerHTML = n;
            for (let e = 0; e < t.childNodes.length; e += 1)
              r.push(t.childNodes[e]);
          } else
            r = (function (e, t) {
              if ("string" != typeof e) return [e];
              const n = [],
                i = t.querySelectorAll(e);
              for (let e = 0; e < i.length; e += 1) n.push(i[e]);
              return n;
            })(e.trim(), t || i);
        } else if (e.nodeType || e === n || e === i) r.push(e);
        else if (Array.isArray(e)) {
          if (e instanceof ua) return e;
          r = e;
        }
        return new ua(
          (function (e) {
            const t = [];
            for (let n = 0; n < e.length; n += 1)
              -1 === t.indexOf(e[n]) && t.push(e[n]);
            return t;
          })(r)
        );
      }
      pa.fn = ua.prototype;
      const fa = "resize scroll".split(" ");
      function ma(e) {
        return function (...t) {
          if (void 0 === t[0]) {
            for (let t = 0; t < this.length; t += 1)
              fa.indexOf(e) < 0 &&
                (e in this[t] ? this[t][e]() : pa(this[t]).trigger(e));
            return this;
          }
          return this.on(e, ...t);
        };
      }
      ma("click"),
        ma("blur"),
        ma("focus"),
        ma("focusin"),
        ma("focusout"),
        ma("keyup"),
        ma("keydown"),
        ma("keypress"),
        ma("submit"),
        ma("change"),
        ma("mousedown"),
        ma("mousemove"),
        ma("mouseup"),
        ma("mouseenter"),
        ma("mouseleave"),
        ma("mouseout"),
        ma("mouseover"),
        ma("touchstart"),
        ma("touchend"),
        ma("touchmove"),
        ma("resize"),
        ma("scroll");
      const ga = {
        addClass: function (...e) {
          const t = ha(e.map((e) => e.split(" ")));
          return (
            this.forEach((e) => {
              e.classList.add(...t);
            }),
            this
          );
        },
        removeClass: function (...e) {
          const t = ha(e.map((e) => e.split(" ")));
          return (
            this.forEach((e) => {
              e.classList.remove(...t);
            }),
            this
          );
        },
        hasClass: function (...e) {
          const t = ha(e.map((e) => e.split(" ")));
          return (
            da(this, (e) => t.filter((t) => e.classList.contains(t)).length > 0)
              .length > 0
          );
        },
        toggleClass: function (...e) {
          const t = ha(e.map((e) => e.split(" ")));
          this.forEach((e) => {
            t.forEach((t) => {
              e.classList.toggle(t);
            });
          });
        },
        attr: function (e, t) {
          if (1 === arguments.length && "string" == typeof e)
            return this[0] ? this[0].getAttribute(e) : void 0;
          for (let n = 0; n < this.length; n += 1)
            if (2 === arguments.length) this[n].setAttribute(e, t);
            else
              for (const t in e)
                (this[n][t] = e[t]), this[n].setAttribute(t, e[t]);
          return this;
        },
        removeAttr: function (e) {
          for (let t = 0; t < this.length; t += 1) this[t].removeAttribute(e);
          return this;
        },
        transform: function (e) {
          for (let t = 0; t < this.length; t += 1) this[t].style.transform = e;
          return this;
        },
        transition: function (e) {
          for (let t = 0; t < this.length; t += 1)
            this[t].style.transitionDuration =
              "string" != typeof e ? `${e}ms` : e;
          return this;
        },
        on: function (...e) {
          let [t, n, i, r] = e;
          function s(e) {
            const t = e.target;
            if (!t) return;
            const r = e.target.dom7EventData || [];
            if ((r.indexOf(e) < 0 && r.unshift(e), pa(t).is(n))) i.apply(t, r);
            else {
              const e = pa(t).parents();
              for (let t = 0; t < e.length; t += 1)
                pa(e[t]).is(n) && i.apply(e[t], r);
            }
          }
          function a(e) {
            const t = (e && e.target && e.target.dom7EventData) || [];
            t.indexOf(e) < 0 && t.unshift(e), i.apply(this, t);
          }
          "function" == typeof e[1] && (([t, i, r] = e), (n = void 0)),
            r || (r = !1);
          const o = t.split(" ");
          let l;
          for (let e = 0; e < this.length; e += 1) {
            const t = this[e];
            if (n)
              for (l = 0; l < o.length; l += 1) {
                const e = o[l];
                t.dom7LiveListeners || (t.dom7LiveListeners = {}),
                  t.dom7LiveListeners[e] || (t.dom7LiveListeners[e] = []),
                  t.dom7LiveListeners[e].push({
                    listener: i,
                    proxyListener: s,
                  }),
                  t.addEventListener(e, s, r);
              }
            else
              for (l = 0; l < o.length; l += 1) {
                const e = o[l];
                t.dom7Listeners || (t.dom7Listeners = {}),
                  t.dom7Listeners[e] || (t.dom7Listeners[e] = []),
                  t.dom7Listeners[e].push({ listener: i, proxyListener: a }),
                  t.addEventListener(e, a, r);
              }
          }
          return this;
        },
        off: function (...e) {
          let [t, n, i, r] = e;
          "function" == typeof e[1] && (([t, i, r] = e), (n = void 0)),
            r || (r = !1);
          const s = t.split(" ");
          for (let e = 0; e < s.length; e += 1) {
            const t = s[e];
            for (let e = 0; e < this.length; e += 1) {
              const s = this[e];
              let a;
              if (
                (!n && s.dom7Listeners
                  ? (a = s.dom7Listeners[t])
                  : n && s.dom7LiveListeners && (a = s.dom7LiveListeners[t]),
                a && a.length)
              )
                for (let e = a.length - 1; e >= 0; e -= 1) {
                  const n = a[e];
                  (i && n.listener === i) ||
                  (i &&
                    n.listener &&
                    n.listener.dom7proxy &&
                    n.listener.dom7proxy === i)
                    ? (s.removeEventListener(t, n.proxyListener, r),
                      a.splice(e, 1))
                    : i ||
                      (s.removeEventListener(t, n.proxyListener, r),
                      a.splice(e, 1));
                }
            }
          }
          return this;
        },
        trigger: function (...e) {
          const t = ca(),
            n = e[0].split(" "),
            i = e[1];
          for (let r = 0; r < n.length; r += 1) {
            const s = n[r];
            for (let n = 0; n < this.length; n += 1) {
              const r = this[n];
              if (t.CustomEvent) {
                const n = new t.CustomEvent(s, {
                  detail: i,
                  bubbles: !0,
                  cancelable: !0,
                });
                (r.dom7EventData = e.filter((e, t) => t > 0)),
                  r.dispatchEvent(n),
                  (r.dom7EventData = []),
                  delete r.dom7EventData;
              }
            }
          }
          return this;
        },
        transitionEnd: function (e) {
          const t = this;
          return (
            e &&
              t.on("transitionend", function n(i) {
                i.target === this &&
                  (e.call(this, i), t.off("transitionend", n));
              }),
            this
          );
        },
        outerWidth: function (e) {
          if (this.length > 0) {
            if (e) {
              const e = this.styles();
              return (
                this[0].offsetWidth +
                parseFloat(e.getPropertyValue("margin-right")) +
                parseFloat(e.getPropertyValue("margin-left"))
              );
            }
            return this[0].offsetWidth;
          }
          return null;
        },
        outerHeight: function (e) {
          if (this.length > 0) {
            if (e) {
              const e = this.styles();
              return (
                this[0].offsetHeight +
                parseFloat(e.getPropertyValue("margin-top")) +
                parseFloat(e.getPropertyValue("margin-bottom"))
              );
            }
            return this[0].offsetHeight;
          }
          return null;
        },
        styles: function () {
          const e = ca();
          return this[0] ? e.getComputedStyle(this[0], null) : {};
        },
        offset: function () {
          if (this.length > 0) {
            const e = ca(),
              t = oa(),
              n = this[0],
              i = n.getBoundingClientRect(),
              r = t.body,
              s = n.clientTop || r.clientTop || 0,
              a = n.clientLeft || r.clientLeft || 0,
              o = n === e ? e.scrollY : n.scrollTop,
              l = n === e ? e.scrollX : n.scrollLeft;
            return { top: i.top + o - s, left: i.left + l - a };
          }
          return null;
        },
        css: function (e, t) {
          const n = ca();
          let i;
          if (1 === arguments.length) {
            if ("string" != typeof e) {
              for (i = 0; i < this.length; i += 1)
                for (const t in e) this[i].style[t] = e[t];
              return this;
            }
            if (this[0])
              return n.getComputedStyle(this[0], null).getPropertyValue(e);
          }
          if (2 === arguments.length && "string" == typeof e) {
            for (i = 0; i < this.length; i += 1) this[i].style[e] = t;
            return this;
          }
          return this;
        },
        each: function (e) {
          return e
            ? (this.forEach((t, n) => {
                e.apply(t, [t, n]);
              }),
              this)
            : this;
        },
        html: function (e) {
          if (void 0 === e) return this[0] ? this[0].innerHTML : null;
          for (let t = 0; t < this.length; t += 1) this[t].innerHTML = e;
          return this;
        },
        text: function (e) {
          if (void 0 === e) return this[0] ? this[0].textContent.trim() : null;
          for (let t = 0; t < this.length; t += 1) this[t].textContent = e;
          return this;
        },
        is: function (e) {
          const t = ca(),
            n = oa(),
            i = this[0];
          let r, s;
          if (!i || void 0 === e) return !1;
          if ("string" == typeof e) {
            if (i.matches) return i.matches(e);
            if (i.webkitMatchesSelector) return i.webkitMatchesSelector(e);
            if (i.msMatchesSelector) return i.msMatchesSelector(e);
            for (r = pa(e), s = 0; s < r.length; s += 1)
              if (r[s] === i) return !0;
            return !1;
          }
          if (e === n) return i === n;
          if (e === t) return i === t;
          if (e.nodeType || e instanceof ua) {
            for (r = e.nodeType ? [e] : e, s = 0; s < r.length; s += 1)
              if (r[s] === i) return !0;
            return !1;
          }
          return !1;
        },
        index: function () {
          let e,
            t = this[0];
          if (t) {
            for (e = 0; null !== (t = t.previousSibling); )
              1 === t.nodeType && (e += 1);
            return e;
          }
        },
        eq: function (e) {
          if (void 0 === e) return this;
          const t = this.length;
          if (e > t - 1) return pa([]);
          if (e < 0) {
            const n = t + e;
            return pa(n < 0 ? [] : [this[n]]);
          }
          return pa([this[e]]);
        },
        append: function (...e) {
          let t;
          const n = oa();
          for (let i = 0; i < e.length; i += 1) {
            t = e[i];
            for (let e = 0; e < this.length; e += 1)
              if ("string" == typeof t) {
                const i = n.createElement("div");
                for (i.innerHTML = t; i.firstChild; )
                  this[e].appendChild(i.firstChild);
              } else if (t instanceof ua)
                for (let n = 0; n < t.length; n += 1) this[e].appendChild(t[n]);
              else this[e].appendChild(t);
          }
          return this;
        },
        prepend: function (e) {
          const t = oa();
          let n, i;
          for (n = 0; n < this.length; n += 1)
            if ("string" == typeof e) {
              const r = t.createElement("div");
              for (r.innerHTML = e, i = r.childNodes.length - 1; i >= 0; i -= 1)
                this[n].insertBefore(r.childNodes[i], this[n].childNodes[0]);
            } else if (e instanceof ua)
              for (i = 0; i < e.length; i += 1)
                this[n].insertBefore(e[i], this[n].childNodes[0]);
            else this[n].insertBefore(e, this[n].childNodes[0]);
          return this;
        },
        next: function (e) {
          return this.length > 0
            ? e
              ? this[0].nextElementSibling &&
                pa(this[0].nextElementSibling).is(e)
                ? pa([this[0].nextElementSibling])
                : pa([])
              : this[0].nextElementSibling
              ? pa([this[0].nextElementSibling])
              : pa([])
            : pa([]);
        },
        nextAll: function (e) {
          const t = [];
          let n = this[0];
          if (!n) return pa([]);
          for (; n.nextElementSibling; ) {
            const i = n.nextElementSibling;
            e ? pa(i).is(e) && t.push(i) : t.push(i), (n = i);
          }
          return pa(t);
        },
        prev: function (e) {
          if (this.length > 0) {
            const t = this[0];
            return e
              ? t.previousElementSibling && pa(t.previousElementSibling).is(e)
                ? pa([t.previousElementSibling])
                : pa([])
              : t.previousElementSibling
              ? pa([t.previousElementSibling])
              : pa([]);
          }
          return pa([]);
        },
        prevAll: function (e) {
          const t = [];
          let n = this[0];
          if (!n) return pa([]);
          for (; n.previousElementSibling; ) {
            const i = n.previousElementSibling;
            e ? pa(i).is(e) && t.push(i) : t.push(i), (n = i);
          }
          return pa(t);
        },
        parent: function (e) {
          const t = [];
          for (let n = 0; n < this.length; n += 1)
            null !== this[n].parentNode &&
              (e
                ? pa(this[n].parentNode).is(e) && t.push(this[n].parentNode)
                : t.push(this[n].parentNode));
          return pa(t);
        },
        parents: function (e) {
          const t = [];
          for (let n = 0; n < this.length; n += 1) {
            let i = this[n].parentNode;
            for (; i; )
              e ? pa(i).is(e) && t.push(i) : t.push(i), (i = i.parentNode);
          }
          return pa(t);
        },
        closest: function (e) {
          let t = this;
          return void 0 === e
            ? pa([])
            : (t.is(e) || (t = t.parents(e).eq(0)), t);
        },
        find: function (e) {
          const t = [];
          for (let n = 0; n < this.length; n += 1) {
            const i = this[n].querySelectorAll(e);
            for (let e = 0; e < i.length; e += 1) t.push(i[e]);
          }
          return pa(t);
        },
        children: function (e) {
          const t = [];
          for (let n = 0; n < this.length; n += 1) {
            const i = this[n].children;
            for (let n = 0; n < i.length; n += 1)
              (e && !pa(i[n]).is(e)) || t.push(i[n]);
          }
          return pa(t);
        },
        filter: function (e) {
          return pa(da(this, e));
        },
        remove: function () {
          for (let e = 0; e < this.length; e += 1)
            this[e].parentNode && this[e].parentNode.removeChild(this[e]);
          return this;
        },
      };
      Object.keys(ga).forEach((e) => {
        Object.defineProperty(pa.fn, e, { value: ga[e], writable: !0 });
      });
      const va = pa;
      function _a(e, t) {
        return void 0 === t && (t = 0), setTimeout(e, t);
      }
      function xa() {
        return Date.now();
      }
      function ya(e) {
        return (
          "object" == typeof e &&
          null !== e &&
          e.constructor &&
          "Object" === Object.prototype.toString.call(e).slice(8, -1)
        );
      }
      function ba(e) {
        return "undefined" != typeof window && void 0 !== window.HTMLElement
          ? e instanceof HTMLElement
          : e && (1 === e.nodeType || 11 === e.nodeType);
      }
      function wa() {
        const e = Object(arguments.length <= 0 ? void 0 : arguments[0]),
          t = ["__proto__", "constructor", "prototype"];
        for (let n = 1; n < arguments.length; n += 1) {
          const i = n < 0 || arguments.length <= n ? void 0 : arguments[n];
          if (null != i && !ba(i)) {
            const n = Object.keys(Object(i)).filter((e) => t.indexOf(e) < 0);
            for (let t = 0, r = n.length; t < r; t += 1) {
              const r = n[t],
                s = Object.getOwnPropertyDescriptor(i, r);
              void 0 !== s &&
                s.enumerable &&
                (ya(e[r]) && ya(i[r])
                  ? i[r].__swiper__
                    ? (e[r] = i[r])
                    : wa(e[r], i[r])
                  : !ya(e[r]) && ya(i[r])
                  ? ((e[r] = {}),
                    i[r].__swiper__ ? (e[r] = i[r]) : wa(e[r], i[r]))
                  : (e[r] = i[r]));
            }
          }
        }
        return e;
      }
      function Sa(e, t, n) {
        e.style.setProperty(t, n);
      }
      function Ma(e) {
        let { swiper: t, targetPosition: n, side: i } = e;
        const r = ca(),
          s = -t.translate;
        let a,
          o = null;
        const l = t.params.speed;
        (t.wrapperEl.style.scrollSnapType = "none"),
          r.cancelAnimationFrame(t.cssModeFrameID);
        const c = n > s ? "next" : "prev",
          u = (e, t) => ("next" === c && e >= t) || ("prev" === c && e <= t),
          h = () => {
            (a = new Date().getTime()), null === o && (o = a);
            const e = Math.max(Math.min((a - o) / l, 1), 0),
              c = 0.5 - Math.cos(e * Math.PI) / 2;
            let d = s + c * (n - s);
            if ((u(d, n) && (d = n), t.wrapperEl.scrollTo({ [i]: d }), u(d, n)))
              return (
                (t.wrapperEl.style.overflow = "hidden"),
                (t.wrapperEl.style.scrollSnapType = ""),
                setTimeout(() => {
                  (t.wrapperEl.style.overflow = ""),
                    t.wrapperEl.scrollTo({ [i]: d });
                }),
                void r.cancelAnimationFrame(t.cssModeFrameID)
              );
            t.cssModeFrameID = r.requestAnimationFrame(h);
          };
        h();
      }
      let Ea, Ta, Aa;
      function Ca() {
        return (
          Ea ||
            (Ea = (function () {
              const e = ca(),
                t = oa();
              return {
                smoothScroll:
                  t.documentElement &&
                  "scrollBehavior" in t.documentElement.style,
                touch: !!(
                  "ontouchstart" in e ||
                  (e.DocumentTouch && t instanceof e.DocumentTouch)
                ),
                passiveListener: (function () {
                  let t = !1;
                  try {
                    const n = Object.defineProperty({}, "passive", {
                      get() {
                        t = !0;
                      },
                    });
                    e.addEventListener("testPassiveListener", null, n);
                  } catch (e) {}
                  return t;
                })(),
                gestures: "ongesturestart" in e,
              };
            })()),
          Ea
        );
      }
      const La = {
          on(e, t, n) {
            const i = this;
            if (!i.eventsListeners || i.destroyed) return i;
            if ("function" != typeof t) return i;
            const r = n ? "unshift" : "push";
            return (
              e.split(" ").forEach((e) => {
                i.eventsListeners[e] || (i.eventsListeners[e] = []),
                  i.eventsListeners[e][r](t);
              }),
              i
            );
          },
          once(e, t, n) {
            const i = this;
            if (!i.eventsListeners || i.destroyed) return i;
            if ("function" != typeof t) return i;
            function r() {
              i.off(e, r), r.__emitterProxy && delete r.__emitterProxy;
              for (
                var n = arguments.length, s = new Array(n), a = 0;
                a < n;
                a++
              )
                s[a] = arguments[a];
              t.apply(i, s);
            }
            return (r.__emitterProxy = t), i.on(e, r, n);
          },
          onAny(e, t) {
            const n = this;
            if (!n.eventsListeners || n.destroyed) return n;
            if ("function" != typeof e) return n;
            const i = t ? "unshift" : "push";
            return (
              n.eventsAnyListeners.indexOf(e) < 0 && n.eventsAnyListeners[i](e),
              n
            );
          },
          offAny(e) {
            const t = this;
            if (!t.eventsListeners || t.destroyed) return t;
            if (!t.eventsAnyListeners) return t;
            const n = t.eventsAnyListeners.indexOf(e);
            return n >= 0 && t.eventsAnyListeners.splice(n, 1), t;
          },
          off(e, t) {
            const n = this;
            return !n.eventsListeners || n.destroyed
              ? n
              : n.eventsListeners
              ? (e.split(" ").forEach((e) => {
                  void 0 === t
                    ? (n.eventsListeners[e] = [])
                    : n.eventsListeners[e] &&
                      n.eventsListeners[e].forEach((i, r) => {
                        (i === t ||
                          (i.__emitterProxy && i.__emitterProxy === t)) &&
                          n.eventsListeners[e].splice(r, 1);
                      });
                }),
                n)
              : n;
          },
          emit() {
            const e = this;
            if (!e.eventsListeners || e.destroyed) return e;
            if (!e.eventsListeners) return e;
            let t, n, i;
            for (var r = arguments.length, s = new Array(r), a = 0; a < r; a++)
              s[a] = arguments[a];
            return (
              "string" == typeof s[0] || Array.isArray(s[0])
                ? ((t = s[0]), (n = s.slice(1, s.length)), (i = e))
                : ((t = s[0].events), (n = s[0].data), (i = s[0].context || e)),
              n.unshift(i),
              (Array.isArray(t) ? t : t.split(" ")).forEach((t) => {
                e.eventsAnyListeners &&
                  e.eventsAnyListeners.length &&
                  e.eventsAnyListeners.forEach((e) => {
                    e.apply(i, [t, ...n]);
                  }),
                  e.eventsListeners &&
                    e.eventsListeners[t] &&
                    e.eventsListeners[t].forEach((e) => {
                      e.apply(i, n);
                    });
              }),
              e
            );
          },
        },
        Pa = {
          updateSize: function () {
            const e = this;
            let t, n;
            const i = e.$el;
            (t =
              void 0 !== e.params.width && null !== e.params.width
                ? e.params.width
                : i[0].clientWidth),
              (n =
                void 0 !== e.params.height && null !== e.params.height
                  ? e.params.height
                  : i[0].clientHeight),
              (0 === t && e.isHorizontal()) ||
                (0 === n && e.isVertical()) ||
                ((t =
                  t -
                  parseInt(i.css("padding-left") || 0, 10) -
                  parseInt(i.css("padding-right") || 0, 10)),
                (n =
                  n -
                  parseInt(i.css("padding-top") || 0, 10) -
                  parseInt(i.css("padding-bottom") || 0, 10)),
                Number.isNaN(t) && (t = 0),
                Number.isNaN(n) && (n = 0),
                Object.assign(e, {
                  width: t,
                  height: n,
                  size: e.isHorizontal() ? t : n,
                }));
          },
          updateSlides: function () {
            const e = this;
            function t(t) {
              return e.isHorizontal()
                ? t
                : {
                    width: "height",
                    "margin-top": "margin-left",
                    "margin-bottom ": "margin-right",
                    "margin-left": "margin-top",
                    "margin-right": "margin-bottom",
                    "padding-left": "padding-top",
                    "padding-right": "padding-bottom",
                    marginRight: "marginBottom",
                  }[t];
            }
            function n(e, n) {
              return parseFloat(e.getPropertyValue(t(n)) || 0);
            }
            const i = e.params,
              { $wrapperEl: r, size: s, rtlTranslate: a, wrongRTL: o } = e,
              l = e.virtual && i.virtual.enabled,
              c = l ? e.virtual.slides.length : e.slides.length,
              u = r.children(`.${e.params.slideClass}`),
              h = l ? e.virtual.slides.length : u.length;
            let d = [];
            const p = [],
              f = [];
            let m = i.slidesOffsetBefore;
            "function" == typeof m && (m = i.slidesOffsetBefore.call(e));
            let g = i.slidesOffsetAfter;
            "function" == typeof g && (g = i.slidesOffsetAfter.call(e));
            const v = e.snapGrid.length,
              _ = e.slidesGrid.length;
            let x = i.spaceBetween,
              y = -m,
              b = 0,
              w = 0;
            if (void 0 === s) return;
            "string" == typeof x &&
              x.indexOf("%") >= 0 &&
              (x = (parseFloat(x.replace("%", "")) / 100) * s),
              (e.virtualSize = -x),
              a
                ? u.css({ marginLeft: "", marginBottom: "", marginTop: "" })
                : u.css({ marginRight: "", marginBottom: "", marginTop: "" }),
              i.centeredSlides &&
                i.cssMode &&
                (Sa(e.wrapperEl, "--swiper-centered-offset-before", ""),
                Sa(e.wrapperEl, "--swiper-centered-offset-after", ""));
            const S = i.grid && i.grid.rows > 1 && e.grid;
            let M;
            S && e.grid.initSlides(h);
            const E =
              "auto" === i.slidesPerView &&
              i.breakpoints &&
              Object.keys(i.breakpoints).filter(
                (e) => void 0 !== i.breakpoints[e].slidesPerView
              ).length > 0;
            for (let r = 0; r < h; r += 1) {
              M = 0;
              const a = u.eq(r);
              if (
                (S && e.grid.updateSlide(r, a, h, t),
                "none" !== a.css("display"))
              ) {
                if ("auto" === i.slidesPerView) {
                  E && (u[r].style[t("width")] = "");
                  const s = getComputedStyle(a[0]),
                    o = a[0].style.transform,
                    l = a[0].style.webkitTransform;
                  if (
                    (o && (a[0].style.transform = "none"),
                    l && (a[0].style.webkitTransform = "none"),
                    i.roundLengths)
                  )
                    M = e.isHorizontal() ? a.outerWidth(!0) : a.outerHeight(!0);
                  else {
                    const e = n(s, "width"),
                      t = n(s, "padding-left"),
                      i = n(s, "padding-right"),
                      r = n(s, "margin-left"),
                      o = n(s, "margin-right"),
                      l = s.getPropertyValue("box-sizing");
                    if (l && "border-box" === l) M = e + r + o;
                    else {
                      const { clientWidth: n, offsetWidth: s } = a[0];
                      M = e + t + i + r + o + (s - n);
                    }
                  }
                  o && (a[0].style.transform = o),
                    l && (a[0].style.webkitTransform = l),
                    i.roundLengths && (M = Math.floor(M));
                } else
                  (M = (s - (i.slidesPerView - 1) * x) / i.slidesPerView),
                    i.roundLengths && (M = Math.floor(M)),
                    u[r] && (u[r].style[t("width")] = `${M}px`);
                u[r] && (u[r].swiperSlideSize = M),
                  f.push(M),
                  i.centeredSlides
                    ? ((y = y + M / 2 + b / 2 + x),
                      0 === b && 0 !== r && (y = y - s / 2 - x),
                      0 === r && (y = y - s / 2 - x),
                      Math.abs(y) < 0.001 && (y = 0),
                      i.roundLengths && (y = Math.floor(y)),
                      w % i.slidesPerGroup == 0 && d.push(y),
                      p.push(y))
                    : (i.roundLengths && (y = Math.floor(y)),
                      (w - Math.min(e.params.slidesPerGroupSkip, w)) %
                        e.params.slidesPerGroup ==
                        0 && d.push(y),
                      p.push(y),
                      (y = y + M + x)),
                  (e.virtualSize += M + x),
                  (b = M),
                  (w += 1);
              }
            }
            if (
              ((e.virtualSize = Math.max(e.virtualSize, s) + g),
              a &&
                o &&
                ("slide" === i.effect || "coverflow" === i.effect) &&
                r.css({ width: `${e.virtualSize + i.spaceBetween}px` }),
              i.setWrapperSize &&
                r.css({ [t("width")]: `${e.virtualSize + i.spaceBetween}px` }),
              S && e.grid.updateWrapperSize(M, d, t),
              !i.centeredSlides)
            ) {
              const t = [];
              for (let n = 0; n < d.length; n += 1) {
                let r = d[n];
                i.roundLengths && (r = Math.floor(r)),
                  d[n] <= e.virtualSize - s && t.push(r);
              }
              (d = t),
                Math.floor(e.virtualSize - s) - Math.floor(d[d.length - 1]) >
                  1 && d.push(e.virtualSize - s);
            }
            if ((0 === d.length && (d = [0]), 0 !== i.spaceBetween)) {
              const n = e.isHorizontal() && a ? "marginLeft" : t("marginRight");
              u.filter((e, t) => !i.cssMode || t !== u.length - 1).css({
                [n]: `${x}px`,
              });
            }
            if (i.centeredSlides && i.centeredSlidesBounds) {
              let e = 0;
              f.forEach((t) => {
                e += t + (i.spaceBetween ? i.spaceBetween : 0);
              }),
                (e -= i.spaceBetween);
              const t = e - s;
              d = d.map((e) => (e < 0 ? -m : e > t ? t + g : e));
            }
            if (i.centerInsufficientSlides) {
              let e = 0;
              if (
                (f.forEach((t) => {
                  e += t + (i.spaceBetween ? i.spaceBetween : 0);
                }),
                (e -= i.spaceBetween),
                e < s)
              ) {
                const t = (s - e) / 2;
                d.forEach((e, n) => {
                  d[n] = e - t;
                }),
                  p.forEach((e, n) => {
                    p[n] = e + t;
                  });
              }
            }
            if (
              (Object.assign(e, {
                slides: u,
                snapGrid: d,
                slidesGrid: p,
                slidesSizesGrid: f,
              }),
              i.centeredSlides && i.cssMode && !i.centeredSlidesBounds)
            ) {
              Sa(e.wrapperEl, "--swiper-centered-offset-before", -d[0] + "px"),
                Sa(
                  e.wrapperEl,
                  "--swiper-centered-offset-after",
                  e.size / 2 - f[f.length - 1] / 2 + "px"
                );
              const t = -e.snapGrid[0],
                n = -e.slidesGrid[0];
              (e.snapGrid = e.snapGrid.map((e) => e + t)),
                (e.slidesGrid = e.slidesGrid.map((e) => e + n));
            }
            if (
              (h !== c && e.emit("slidesLengthChange"),
              d.length !== v &&
                (e.params.watchOverflow && e.checkOverflow(),
                e.emit("snapGridLengthChange")),
              p.length !== _ && e.emit("slidesGridLengthChange"),
              i.watchSlidesProgress && e.updateSlidesOffset(),
              !(
                l ||
                i.cssMode ||
                ("slide" !== i.effect && "fade" !== i.effect)
              ))
            ) {
              const t = `${i.containerModifierClass}backface-hidden`,
                n = e.$el.hasClass(t);
              h <= i.maxBackfaceHiddenSlides
                ? n || e.$el.addClass(t)
                : n && e.$el.removeClass(t);
            }
          },
          updateAutoHeight: function (e) {
            const t = this,
              n = [],
              i = t.virtual && t.params.virtual.enabled;
            let r,
              s = 0;
            "number" == typeof e
              ? t.setTransition(e)
              : !0 === e && t.setTransition(t.params.speed);
            const a = (e) =>
              i
                ? t.slides.filter(
                    (t) =>
                      parseInt(
                        t.getAttribute("data-swiper-slide-index"),
                        10
                      ) === e
                  )[0]
                : t.slides.eq(e)[0];
            if ("auto" !== t.params.slidesPerView && t.params.slidesPerView > 1)
              if (t.params.centeredSlides)
                (t.visibleSlides || va([])).each((e) => {
                  n.push(e);
                });
              else
                for (r = 0; r < Math.ceil(t.params.slidesPerView); r += 1) {
                  const e = t.activeIndex + r;
                  if (e > t.slides.length && !i) break;
                  n.push(a(e));
                }
            else n.push(a(t.activeIndex));
            for (r = 0; r < n.length; r += 1)
              if (void 0 !== n[r]) {
                const e = n[r].offsetHeight;
                s = e > s ? e : s;
              }
            (s || 0 === s) && t.$wrapperEl.css("height", `${s}px`);
          },
          updateSlidesOffset: function () {
            const e = this,
              t = e.slides;
            for (let n = 0; n < t.length; n += 1)
              t[n].swiperSlideOffset = e.isHorizontal()
                ? t[n].offsetLeft
                : t[n].offsetTop;
          },
          updateSlidesProgress: function (e) {
            void 0 === e && (e = (this && this.translate) || 0);
            const t = this,
              n = t.params,
              { slides: i, rtlTranslate: r, snapGrid: s } = t;
            if (0 === i.length) return;
            void 0 === i[0].swiperSlideOffset && t.updateSlidesOffset();
            let a = -e;
            r && (a = e),
              i.removeClass(n.slideVisibleClass),
              (t.visibleSlidesIndexes = []),
              (t.visibleSlides = []);
            for (let e = 0; e < i.length; e += 1) {
              const o = i[e];
              let l = o.swiperSlideOffset;
              n.cssMode && n.centeredSlides && (l -= i[0].swiperSlideOffset);
              const c =
                  (a + (n.centeredSlides ? t.minTranslate() : 0) - l) /
                  (o.swiperSlideSize + n.spaceBetween),
                u =
                  (a - s[0] + (n.centeredSlides ? t.minTranslate() : 0) - l) /
                  (o.swiperSlideSize + n.spaceBetween),
                h = -(a - l),
                d = h + t.slidesSizesGrid[e];
              ((h >= 0 && h < t.size - 1) ||
                (d > 1 && d <= t.size) ||
                (h <= 0 && d >= t.size)) &&
                (t.visibleSlides.push(o),
                t.visibleSlidesIndexes.push(e),
                i.eq(e).addClass(n.slideVisibleClass)),
                (o.progress = r ? -c : c),
                (o.originalProgress = r ? -u : u);
            }
            t.visibleSlides = va(t.visibleSlides);
          },
          updateProgress: function (e) {
            const t = this;
            if (void 0 === e) {
              const n = t.rtlTranslate ? -1 : 1;
              e = (t && t.translate && t.translate * n) || 0;
            }
            const n = t.params,
              i = t.maxTranslate() - t.minTranslate();
            let { progress: r, isBeginning: s, isEnd: a } = t;
            const o = s,
              l = a;
            0 === i
              ? ((r = 0), (s = !0), (a = !0))
              : ((r = (e - t.minTranslate()) / i), (s = r <= 0), (a = r >= 1)),
              Object.assign(t, { progress: r, isBeginning: s, isEnd: a }),
              (n.watchSlidesProgress || (n.centeredSlides && n.autoHeight)) &&
                t.updateSlidesProgress(e),
              s && !o && t.emit("reachBeginning toEdge"),
              a && !l && t.emit("reachEnd toEdge"),
              ((o && !s) || (l && !a)) && t.emit("fromEdge"),
              t.emit("progress", r);
          },
          updateSlidesClasses: function () {
            const e = this,
              {
                slides: t,
                params: n,
                $wrapperEl: i,
                activeIndex: r,
                realIndex: s,
              } = e,
              a = e.virtual && n.virtual.enabled;
            let o;
            t.removeClass(
              `${n.slideActiveClass} ${n.slideNextClass} ${n.slidePrevClass} ${n.slideDuplicateActiveClass} ${n.slideDuplicateNextClass} ${n.slideDuplicatePrevClass}`
            ),
              (o = a
                ? e.$wrapperEl.find(
                    `.${n.slideClass}[data-swiper-slide-index="${r}"]`
                  )
                : t.eq(r)),
              o.addClass(n.slideActiveClass),
              n.loop &&
                (o.hasClass(n.slideDuplicateClass)
                  ? i
                      .children(
                        `.${n.slideClass}:not(.${n.slideDuplicateClass})[data-swiper-slide-index="${s}"]`
                      )
                      .addClass(n.slideDuplicateActiveClass)
                  : i
                      .children(
                        `.${n.slideClass}.${n.slideDuplicateClass}[data-swiper-slide-index="${s}"]`
                      )
                      .addClass(n.slideDuplicateActiveClass));
            let l = o
              .nextAll(`.${n.slideClass}`)
              .eq(0)
              .addClass(n.slideNextClass);
            n.loop &&
              0 === l.length &&
              ((l = t.eq(0)), l.addClass(n.slideNextClass));
            let c = o
              .prevAll(`.${n.slideClass}`)
              .eq(0)
              .addClass(n.slidePrevClass);
            n.loop &&
              0 === c.length &&
              ((c = t.eq(-1)), c.addClass(n.slidePrevClass)),
              n.loop &&
                (l.hasClass(n.slideDuplicateClass)
                  ? i
                      .children(
                        `.${n.slideClass}:not(.${
                          n.slideDuplicateClass
                        })[data-swiper-slide-index="${l.attr(
                          "data-swiper-slide-index"
                        )}"]`
                      )
                      .addClass(n.slideDuplicateNextClass)
                  : i
                      .children(
                        `.${n.slideClass}.${
                          n.slideDuplicateClass
                        }[data-swiper-slide-index="${l.attr(
                          "data-swiper-slide-index"
                        )}"]`
                      )
                      .addClass(n.slideDuplicateNextClass),
                c.hasClass(n.slideDuplicateClass)
                  ? i
                      .children(
                        `.${n.slideClass}:not(.${
                          n.slideDuplicateClass
                        })[data-swiper-slide-index="${c.attr(
                          "data-swiper-slide-index"
                        )}"]`
                      )
                      .addClass(n.slideDuplicatePrevClass)
                  : i
                      .children(
                        `.${n.slideClass}.${
                          n.slideDuplicateClass
                        }[data-swiper-slide-index="${c.attr(
                          "data-swiper-slide-index"
                        )}"]`
                      )
                      .addClass(n.slideDuplicatePrevClass)),
              e.emitSlidesClasses();
          },
          updateActiveIndex: function (e) {
            const t = this,
              n = t.rtlTranslate ? t.translate : -t.translate,
              {
                slidesGrid: i,
                snapGrid: r,
                params: s,
                activeIndex: a,
                realIndex: o,
                snapIndex: l,
              } = t;
            let c,
              u = e;
            if (void 0 === u) {
              for (let e = 0; e < i.length; e += 1)
                void 0 !== i[e + 1]
                  ? n >= i[e] && n < i[e + 1] - (i[e + 1] - i[e]) / 2
                    ? (u = e)
                    : n >= i[e] && n < i[e + 1] && (u = e + 1)
                  : n >= i[e] && (u = e);
              s.normalizeSlideIndex && (u < 0 || void 0 === u) && (u = 0);
            }
            if (r.indexOf(n) >= 0) c = r.indexOf(n);
            else {
              const e = Math.min(s.slidesPerGroupSkip, u);
              c = e + Math.floor((u - e) / s.slidesPerGroup);
            }
            if ((c >= r.length && (c = r.length - 1), u === a))
              return void (
                c !== l && ((t.snapIndex = c), t.emit("snapIndexChange"))
              );
            const h = parseInt(
              t.slides.eq(u).attr("data-swiper-slide-index") || u,
              10
            );
            Object.assign(t, {
              snapIndex: c,
              realIndex: h,
              previousIndex: a,
              activeIndex: u,
            }),
              t.emit("activeIndexChange"),
              t.emit("snapIndexChange"),
              o !== h && t.emit("realIndexChange"),
              (t.initialized || t.params.runCallbacksOnInit) &&
                t.emit("slideChange");
          },
          updateClickedSlide: function (e) {
            const t = this,
              n = t.params,
              i = va(e).closest(`.${n.slideClass}`)[0];
            let r,
              s = !1;
            if (i)
              for (let e = 0; e < t.slides.length; e += 1)
                if (t.slides[e] === i) {
                  (s = !0), (r = e);
                  break;
                }
            if (!i || !s)
              return (t.clickedSlide = void 0), void (t.clickedIndex = void 0);
            (t.clickedSlide = i),
              t.virtual && t.params.virtual.enabled
                ? (t.clickedIndex = parseInt(
                    va(i).attr("data-swiper-slide-index"),
                    10
                  ))
                : (t.clickedIndex = r),
              n.slideToClickedSlide &&
                void 0 !== t.clickedIndex &&
                t.clickedIndex !== t.activeIndex &&
                t.slideToClickedSlide();
          },
        };
      function Da(e) {
        let { swiper: t, runCallbacks: n, direction: i, step: r } = e;
        const { activeIndex: s, previousIndex: a } = t;
        let o = i;
        if (
          (o || (o = s > a ? "next" : s < a ? "prev" : "reset"),
          t.emit(`transition${r}`),
          n && s !== a)
        ) {
          if ("reset" === o) return void t.emit(`slideResetTransition${r}`);
          t.emit(`slideChangeTransition${r}`),
            "next" === o
              ? t.emit(`slideNextTransition${r}`)
              : t.emit(`slidePrevTransition${r}`);
        }
      }
      const ka = {
          slideTo: function (e, t, n, i, r) {
            if (
              (void 0 === e && (e = 0),
              void 0 === t && (t = this.params.speed),
              void 0 === n && (n = !0),
              "number" != typeof e && "string" != typeof e)
            )
              throw new Error(
                `The 'index' argument cannot have type other than 'number' or 'string'. [${typeof e}] given.`
              );
            if ("string" == typeof e) {
              const t = parseInt(e, 10);
              if (!isFinite(t))
                throw new Error(
                  `The passed-in 'index' (string) couldn't be converted to 'number'. [${e}] given.`
                );
              e = t;
            }
            const s = this;
            let a = e;
            a < 0 && (a = 0);
            const {
              params: o,
              snapGrid: l,
              slidesGrid: c,
              previousIndex: u,
              activeIndex: h,
              rtlTranslate: d,
              wrapperEl: p,
              enabled: f,
            } = s;
            if (
              (s.animating && o.preventInteractionOnTransition) ||
              (!f && !i && !r)
            )
              return !1;
            const m = Math.min(s.params.slidesPerGroupSkip, a);
            let g = m + Math.floor((a - m) / s.params.slidesPerGroup);
            g >= l.length && (g = l.length - 1),
              (h || o.initialSlide || 0) === (u || 0) &&
                n &&
                s.emit("beforeSlideChangeStart");
            const v = -l[g];
            if ((s.updateProgress(v), o.normalizeSlideIndex))
              for (let e = 0; e < c.length; e += 1) {
                const t = -Math.floor(100 * v),
                  n = Math.floor(100 * c[e]),
                  i = Math.floor(100 * c[e + 1]);
                void 0 !== c[e + 1]
                  ? t >= n && t < i - (i - n) / 2
                    ? (a = e)
                    : t >= n && t < i && (a = e + 1)
                  : t >= n && (a = e);
              }
            if (s.initialized && a !== h) {
              if (!s.allowSlideNext && v < s.translate && v < s.minTranslate())
                return !1;
              if (
                !s.allowSlidePrev &&
                v > s.translate &&
                v > s.maxTranslate() &&
                (h || 0) !== a
              )
                return !1;
            }
            let _;
            if (
              ((_ = a > h ? "next" : a < h ? "prev" : "reset"),
              (d && -v === s.translate) || (!d && v === s.translate))
            )
              return (
                s.updateActiveIndex(a),
                o.autoHeight && s.updateAutoHeight(),
                s.updateSlidesClasses(),
                "slide" !== o.effect && s.setTranslate(v),
                "reset" !== _ &&
                  (s.transitionStart(n, _), s.transitionEnd(n, _)),
                !1
              );
            if (o.cssMode) {
              const e = s.isHorizontal(),
                n = d ? v : -v;
              if (0 === t) {
                const t = s.virtual && s.params.virtual.enabled;
                t &&
                  ((s.wrapperEl.style.scrollSnapType = "none"),
                  (s._immediateVirtual = !0)),
                  (p[e ? "scrollLeft" : "scrollTop"] = n),
                  t &&
                    requestAnimationFrame(() => {
                      (s.wrapperEl.style.scrollSnapType = ""),
                        (s._swiperImmediateVirtual = !1);
                    });
              } else {
                if (!s.support.smoothScroll)
                  return (
                    Ma({
                      swiper: s,
                      targetPosition: n,
                      side: e ? "left" : "top",
                    }),
                    !0
                  );
                p.scrollTo({ [e ? "left" : "top"]: n, behavior: "smooth" });
              }
              return !0;
            }
            return (
              s.setTransition(t),
              s.setTranslate(v),
              s.updateActiveIndex(a),
              s.updateSlidesClasses(),
              s.emit("beforeTransitionStart", t, i),
              s.transitionStart(n, _),
              0 === t
                ? s.transitionEnd(n, _)
                : s.animating ||
                  ((s.animating = !0),
                  s.onSlideToWrapperTransitionEnd ||
                    (s.onSlideToWrapperTransitionEnd = function (e) {
                      s &&
                        !s.destroyed &&
                        e.target === this &&
                        (s.$wrapperEl[0].removeEventListener(
                          "transitionend",
                          s.onSlideToWrapperTransitionEnd
                        ),
                        s.$wrapperEl[0].removeEventListener(
                          "webkitTransitionEnd",
                          s.onSlideToWrapperTransitionEnd
                        ),
                        (s.onSlideToWrapperTransitionEnd = null),
                        delete s.onSlideToWrapperTransitionEnd,
                        s.transitionEnd(n, _));
                    }),
                  s.$wrapperEl[0].addEventListener(
                    "transitionend",
                    s.onSlideToWrapperTransitionEnd
                  ),
                  s.$wrapperEl[0].addEventListener(
                    "webkitTransitionEnd",
                    s.onSlideToWrapperTransitionEnd
                  )),
              !0
            );
          },
          slideToLoop: function (e, t, n, i) {
            if (
              (void 0 === e && (e = 0),
              void 0 === t && (t = this.params.speed),
              void 0 === n && (n = !0),
              "string" == typeof e)
            ) {
              const t = parseInt(e, 10);
              if (!isFinite(t))
                throw new Error(
                  `The passed-in 'index' (string) couldn't be converted to 'number'. [${e}] given.`
                );
              e = t;
            }
            const r = this;
            let s = e;
            return (
              r.params.loop && (s += r.loopedSlides), r.slideTo(s, t, n, i)
            );
          },
          slideNext: function (e, t, n) {
            void 0 === e && (e = this.params.speed), void 0 === t && (t = !0);
            const i = this,
              { animating: r, enabled: s, params: a } = i;
            if (!s) return i;
            let o = a.slidesPerGroup;
            "auto" === a.slidesPerView &&
              1 === a.slidesPerGroup &&
              a.slidesPerGroupAuto &&
              (o = Math.max(i.slidesPerViewDynamic("current", !0), 1));
            const l = i.activeIndex < a.slidesPerGroupSkip ? 1 : o;
            if (a.loop) {
              if (r && a.loopPreventsSlide) return !1;
              i.loopFix(), (i._clientLeft = i.$wrapperEl[0].clientLeft);
            }
            return a.rewind && i.isEnd
              ? i.slideTo(0, e, t, n)
              : i.slideTo(i.activeIndex + l, e, t, n);
          },
          slidePrev: function (e, t, n) {
            void 0 === e && (e = this.params.speed), void 0 === t && (t = !0);
            const i = this,
              {
                params: r,
                animating: s,
                snapGrid: a,
                slidesGrid: o,
                rtlTranslate: l,
                enabled: c,
              } = i;
            if (!c) return i;
            if (r.loop) {
              if (s && r.loopPreventsSlide) return !1;
              i.loopFix(), (i._clientLeft = i.$wrapperEl[0].clientLeft);
            }
            function u(e) {
              return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e);
            }
            const h = u(l ? i.translate : -i.translate),
              d = a.map((e) => u(e));
            let p = a[d.indexOf(h) - 1];
            if (void 0 === p && r.cssMode) {
              let e;
              a.forEach((t, n) => {
                h >= t && (e = n);
              }),
                void 0 !== e && (p = a[e > 0 ? e - 1 : e]);
            }
            let f = 0;
            if (
              (void 0 !== p &&
                ((f = o.indexOf(p)),
                f < 0 && (f = i.activeIndex - 1),
                "auto" === r.slidesPerView &&
                  1 === r.slidesPerGroup &&
                  r.slidesPerGroupAuto &&
                  ((f = f - i.slidesPerViewDynamic("previous", !0) + 1),
                  (f = Math.max(f, 0)))),
              r.rewind && i.isBeginning)
            ) {
              const r =
                i.params.virtual && i.params.virtual.enabled && i.virtual
                  ? i.virtual.slides.length - 1
                  : i.slides.length - 1;
              return i.slideTo(r, e, t, n);
            }
            return i.slideTo(f, e, t, n);
          },
          slideReset: function (e, t, n) {
            return (
              void 0 === e && (e = this.params.speed),
              void 0 === t && (t = !0),
              this.slideTo(this.activeIndex, e, t, n)
            );
          },
          slideToClosest: function (e, t, n, i) {
            void 0 === e && (e = this.params.speed),
              void 0 === t && (t = !0),
              void 0 === i && (i = 0.5);
            const r = this;
            let s = r.activeIndex;
            const a = Math.min(r.params.slidesPerGroupSkip, s),
              o = a + Math.floor((s - a) / r.params.slidesPerGroup),
              l = r.rtlTranslate ? r.translate : -r.translate;
            if (l >= r.snapGrid[o]) {
              const e = r.snapGrid[o];
              l - e > (r.snapGrid[o + 1] - e) * i &&
                (s += r.params.slidesPerGroup);
            } else {
              const e = r.snapGrid[o - 1];
              l - e <= (r.snapGrid[o] - e) * i &&
                (s -= r.params.slidesPerGroup);
            }
            return (
              (s = Math.max(s, 0)),
              (s = Math.min(s, r.slidesGrid.length - 1)),
              r.slideTo(s, e, t, n)
            );
          },
          slideToClickedSlide: function () {
            const e = this,
              { params: t, $wrapperEl: n } = e,
              i =
                "auto" === t.slidesPerView
                  ? e.slidesPerViewDynamic()
                  : t.slidesPerView;
            let r,
              s = e.clickedIndex;
            if (t.loop) {
              if (e.animating) return;
              (r = parseInt(
                va(e.clickedSlide).attr("data-swiper-slide-index"),
                10
              )),
                t.centeredSlides
                  ? s < e.loopedSlides - i / 2 ||
                    s > e.slides.length - e.loopedSlides + i / 2
                    ? (e.loopFix(),
                      (s = n
                        .children(
                          `.${t.slideClass}[data-swiper-slide-index="${r}"]:not(.${t.slideDuplicateClass})`
                        )
                        .eq(0)
                        .index()),
                      _a(() => {
                        e.slideTo(s);
                      }))
                    : e.slideTo(s)
                  : s > e.slides.length - i
                  ? (e.loopFix(),
                    (s = n
                      .children(
                        `.${t.slideClass}[data-swiper-slide-index="${r}"]:not(.${t.slideDuplicateClass})`
                      )
                      .eq(0)
                      .index()),
                    _a(() => {
                      e.slideTo(s);
                    }))
                  : e.slideTo(s);
            } else e.slideTo(s);
          },
        },
        Ra = {
          loopCreate: function () {
            const e = this,
              t = oa(),
              { params: n, $wrapperEl: i } = e,
              r = i.children().length > 0 ? va(i.children()[0].parentNode) : i;
            r.children(`.${n.slideClass}.${n.slideDuplicateClass}`).remove();
            let s = r.children(`.${n.slideClass}`);
            if (n.loopFillGroupWithBlank) {
              const e = n.slidesPerGroup - (s.length % n.slidesPerGroup);
              if (e !== n.slidesPerGroup) {
                for (let i = 0; i < e; i += 1) {
                  const e = va(t.createElement("div")).addClass(
                    `${n.slideClass} ${n.slideBlankClass}`
                  );
                  r.append(e);
                }
                s = r.children(`.${n.slideClass}`);
              }
            }
            "auto" !== n.slidesPerView ||
              n.loopedSlides ||
              (n.loopedSlides = s.length),
              (e.loopedSlides = Math.ceil(
                parseFloat(n.loopedSlides || n.slidesPerView, 10)
              )),
              (e.loopedSlides += n.loopAdditionalSlides),
              e.loopedSlides > s.length && (e.loopedSlides = s.length);
            const a = [],
              o = [];
            s.each((t, n) => {
              const i = va(t);
              n < e.loopedSlides && o.push(t),
                n < s.length && n >= s.length - e.loopedSlides && a.push(t),
                i.attr("data-swiper-slide-index", n);
            });
            for (let e = 0; e < o.length; e += 1)
              r.append(va(o[e].cloneNode(!0)).addClass(n.slideDuplicateClass));
            for (let e = a.length - 1; e >= 0; e -= 1)
              r.prepend(va(a[e].cloneNode(!0)).addClass(n.slideDuplicateClass));
          },
          loopFix: function () {
            const e = this;
            e.emit("beforeLoopFix");
            const {
              activeIndex: t,
              slides: n,
              loopedSlides: i,
              allowSlidePrev: r,
              allowSlideNext: s,
              snapGrid: a,
              rtlTranslate: o,
            } = e;
            let l;
            (e.allowSlidePrev = !0), (e.allowSlideNext = !0);
            const c = -a[t] - e.getTranslate();
            t < i
              ? ((l = n.length - 3 * i + t),
                (l += i),
                e.slideTo(l, 0, !1, !0) &&
                  0 !== c &&
                  e.setTranslate((o ? -e.translate : e.translate) - c))
              : t >= n.length - i &&
                ((l = -n.length + t + i),
                (l += i),
                e.slideTo(l, 0, !1, !0) &&
                  0 !== c &&
                  e.setTranslate((o ? -e.translate : e.translate) - c)),
              (e.allowSlidePrev = r),
              (e.allowSlideNext = s),
              e.emit("loopFix");
          },
          loopDestroy: function () {
            const { $wrapperEl: e, params: t, slides: n } = this;
            e
              .children(
                `.${t.slideClass}.${t.slideDuplicateClass},.${t.slideClass}.${t.slideBlankClass}`
              )
              .remove(),
              n.removeAttr("data-swiper-slide-index");
          },
        };
      function Ia(e) {
        const t = this,
          n = oa(),
          i = ca(),
          r = t.touchEventsData,
          { params: s, touches: a, enabled: o } = t;
        if (!o) return;
        if (t.animating && s.preventInteractionOnTransition) return;
        !t.animating && s.cssMode && s.loop && t.loopFix();
        let l = e;
        l.originalEvent && (l = l.originalEvent);
        let c = va(l.target);
        if ("wrapper" === s.touchEventsTarget && !c.closest(t.wrapperEl).length)
          return;
        if (
          ((r.isTouchEvent = "touchstart" === l.type),
          !r.isTouchEvent && "which" in l && 3 === l.which)
        )
          return;
        if (!r.isTouchEvent && "button" in l && l.button > 0) return;
        if (r.isTouched && r.isMoved) return;
        s.noSwipingClass &&
          "" !== s.noSwipingClass &&
          l.target &&
          l.target.shadowRoot &&
          e.path &&
          e.path[0] &&
          (c = va(e.path[0]));
        const u = s.noSwipingSelector
            ? s.noSwipingSelector
            : `.${s.noSwipingClass}`,
          h = !(!l.target || !l.target.shadowRoot);
        if (
          s.noSwiping &&
          (h
            ? (function (e, t) {
                return (
                  void 0 === t && (t = this),
                  (function t(n) {
                    if (!n || n === oa() || n === ca()) return null;
                    n.assignedSlot && (n = n.assignedSlot);
                    const i = n.closest(e);
                    return i || n.getRootNode
                      ? i || t(n.getRootNode().host)
                      : null;
                  })(t)
                );
              })(u, c[0])
            : c.closest(u)[0])
        )
          return void (t.allowClick = !0);
        if (s.swipeHandler && !c.closest(s.swipeHandler)[0]) return;
        (a.currentX =
          "touchstart" === l.type ? l.targetTouches[0].pageX : l.pageX),
          (a.currentY =
            "touchstart" === l.type ? l.targetTouches[0].pageY : l.pageY);
        const d = a.currentX,
          p = a.currentY,
          f = s.edgeSwipeDetection || s.iOSEdgeSwipeDetection,
          m = s.edgeSwipeThreshold || s.iOSEdgeSwipeThreshold;
        if (f && (d <= m || d >= i.innerWidth - m)) {
          if ("prevent" !== f) return;
          e.preventDefault();
        }
        if (
          (Object.assign(r, {
            isTouched: !0,
            isMoved: !1,
            allowTouchCallbacks: !0,
            isScrolling: void 0,
            startMoving: void 0,
          }),
          (a.startX = d),
          (a.startY = p),
          (r.touchStartTime = xa()),
          (t.allowClick = !0),
          t.updateSize(),
          (t.swipeDirection = void 0),
          s.threshold > 0 && (r.allowThresholdMove = !1),
          "touchstart" !== l.type)
        ) {
          let e = !0;
          c.is(r.focusableElements) &&
            ((e = !1), "SELECT" === c[0].nodeName && (r.isTouched = !1)),
            n.activeElement &&
              va(n.activeElement).is(r.focusableElements) &&
              n.activeElement !== c[0] &&
              n.activeElement.blur();
          const i = e && t.allowTouchMove && s.touchStartPreventDefault;
          (!s.touchStartForcePreventDefault && !i) ||
            c[0].isContentEditable ||
            l.preventDefault();
        }
        t.params.freeMode &&
          t.params.freeMode.enabled &&
          t.freeMode &&
          t.animating &&
          !s.cssMode &&
          t.freeMode.onTouchStart(),
          t.emit("touchStart", l);
      }
      function Fa(e) {
        const t = oa(),
          n = this,
          i = n.touchEventsData,
          { params: r, touches: s, rtlTranslate: a, enabled: o } = n;
        if (!o) return;
        let l = e;
        if ((l.originalEvent && (l = l.originalEvent), !i.isTouched))
          return void (
            i.startMoving &&
            i.isScrolling &&
            n.emit("touchMoveOpposite", l)
          );
        if (i.isTouchEvent && "touchmove" !== l.type) return;
        const c =
            "touchmove" === l.type &&
            l.targetTouches &&
            (l.targetTouches[0] || l.changedTouches[0]),
          u = "touchmove" === l.type ? c.pageX : l.pageX,
          h = "touchmove" === l.type ? c.pageY : l.pageY;
        if (l.preventedByNestedSwiper)
          return (s.startX = u), void (s.startY = h);
        if (!n.allowTouchMove)
          return (
            va(l.target).is(i.focusableElements) || (n.allowClick = !1),
            void (
              i.isTouched &&
              (Object.assign(s, {
                startX: u,
                startY: h,
                currentX: u,
                currentY: h,
              }),
              (i.touchStartTime = xa()))
            )
          );
        if (i.isTouchEvent && r.touchReleaseOnEdges && !r.loop)
          if (n.isVertical()) {
            if (
              (h < s.startY && n.translate <= n.maxTranslate()) ||
              (h > s.startY && n.translate >= n.minTranslate())
            )
              return (i.isTouched = !1), void (i.isMoved = !1);
          } else if (
            (u < s.startX && n.translate <= n.maxTranslate()) ||
            (u > s.startX && n.translate >= n.minTranslate())
          )
            return;
        if (
          i.isTouchEvent &&
          t.activeElement &&
          l.target === t.activeElement &&
          va(l.target).is(i.focusableElements)
        )
          return (i.isMoved = !0), void (n.allowClick = !1);
        if (
          (i.allowTouchCallbacks && n.emit("touchMove", l),
          l.targetTouches && l.targetTouches.length > 1)
        )
          return;
        (s.currentX = u), (s.currentY = h);
        const d = s.currentX - s.startX,
          p = s.currentY - s.startY;
        if (
          n.params.threshold &&
          Math.sqrt(d ** 2 + p ** 2) < n.params.threshold
        )
          return;
        if (void 0 === i.isScrolling) {
          let e;
          (n.isHorizontal() && s.currentY === s.startY) ||
          (n.isVertical() && s.currentX === s.startX)
            ? (i.isScrolling = !1)
            : d * d + p * p >= 25 &&
              ((e = (180 * Math.atan2(Math.abs(p), Math.abs(d))) / Math.PI),
              (i.isScrolling = n.isHorizontal()
                ? e > r.touchAngle
                : 90 - e > r.touchAngle));
        }
        if (
          (i.isScrolling && n.emit("touchMoveOpposite", l),
          void 0 === i.startMoving &&
            ((s.currentX === s.startX && s.currentY === s.startY) ||
              (i.startMoving = !0)),
          i.isScrolling)
        )
          return void (i.isTouched = !1);
        if (!i.startMoving) return;
        (n.allowClick = !1),
          !r.cssMode && l.cancelable && l.preventDefault(),
          r.touchMoveStopPropagation && !r.nested && l.stopPropagation(),
          i.isMoved ||
            (r.loop && !r.cssMode && n.loopFix(),
            (i.startTranslate = n.getTranslate()),
            n.setTransition(0),
            n.animating &&
              n.$wrapperEl.trigger("webkitTransitionEnd transitionend"),
            (i.allowMomentumBounce = !1),
            !r.grabCursor ||
              (!0 !== n.allowSlideNext && !0 !== n.allowSlidePrev) ||
              n.setGrabCursor(!0),
            n.emit("sliderFirstMove", l)),
          n.emit("sliderMove", l),
          (i.isMoved = !0);
        let f = n.isHorizontal() ? d : p;
        (s.diff = f),
          (f *= r.touchRatio),
          a && (f = -f),
          (n.swipeDirection = f > 0 ? "prev" : "next"),
          (i.currentTranslate = f + i.startTranslate);
        let m = !0,
          g = r.resistanceRatio;
        if (
          (r.touchReleaseOnEdges && (g = 0),
          f > 0 && i.currentTranslate > n.minTranslate()
            ? ((m = !1),
              r.resistance &&
                (i.currentTranslate =
                  n.minTranslate() -
                  1 +
                  (-n.minTranslate() + i.startTranslate + f) ** g))
            : f < 0 &&
              i.currentTranslate < n.maxTranslate() &&
              ((m = !1),
              r.resistance &&
                (i.currentTranslate =
                  n.maxTranslate() +
                  1 -
                  (n.maxTranslate() - i.startTranslate - f) ** g)),
          m && (l.preventedByNestedSwiper = !0),
          !n.allowSlideNext &&
            "next" === n.swipeDirection &&
            i.currentTranslate < i.startTranslate &&
            (i.currentTranslate = i.startTranslate),
          !n.allowSlidePrev &&
            "prev" === n.swipeDirection &&
            i.currentTranslate > i.startTranslate &&
            (i.currentTranslate = i.startTranslate),
          n.allowSlidePrev ||
            n.allowSlideNext ||
            (i.currentTranslate = i.startTranslate),
          r.threshold > 0)
        ) {
          if (!(Math.abs(f) > r.threshold || i.allowThresholdMove))
            return void (i.currentTranslate = i.startTranslate);
          if (!i.allowThresholdMove)
            return (
              (i.allowThresholdMove = !0),
              (s.startX = s.currentX),
              (s.startY = s.currentY),
              (i.currentTranslate = i.startTranslate),
              void (s.diff = n.isHorizontal()
                ? s.currentX - s.startX
                : s.currentY - s.startY)
            );
        }
        r.followFinger &&
          !r.cssMode &&
          (((r.freeMode && r.freeMode.enabled && n.freeMode) ||
            r.watchSlidesProgress) &&
            (n.updateActiveIndex(), n.updateSlidesClasses()),
          n.params.freeMode &&
            r.freeMode.enabled &&
            n.freeMode &&
            n.freeMode.onTouchMove(),
          n.updateProgress(i.currentTranslate),
          n.setTranslate(i.currentTranslate));
      }
      function Oa(e) {
        const t = this,
          n = t.touchEventsData,
          {
            params: i,
            touches: r,
            rtlTranslate: s,
            slidesGrid: a,
            enabled: o,
          } = t;
        if (!o) return;
        let l = e;
        if (
          (l.originalEvent && (l = l.originalEvent),
          n.allowTouchCallbacks && t.emit("touchEnd", l),
          (n.allowTouchCallbacks = !1),
          !n.isTouched)
        )
          return (
            n.isMoved && i.grabCursor && t.setGrabCursor(!1),
            (n.isMoved = !1),
            void (n.startMoving = !1)
          );
        i.grabCursor &&
          n.isMoved &&
          n.isTouched &&
          (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) &&
          t.setGrabCursor(!1);
        const c = xa(),
          u = c - n.touchStartTime;
        if (t.allowClick) {
          const e = l.path || (l.composedPath && l.composedPath());
          t.updateClickedSlide((e && e[0]) || l.target),
            t.emit("tap click", l),
            u < 300 &&
              c - n.lastClickTime < 300 &&
              t.emit("doubleTap doubleClick", l);
        }
        if (
          ((n.lastClickTime = xa()),
          _a(() => {
            t.destroyed || (t.allowClick = !0);
          }),
          !n.isTouched ||
            !n.isMoved ||
            !t.swipeDirection ||
            0 === r.diff ||
            n.currentTranslate === n.startTranslate)
        )
          return (
            (n.isTouched = !1), (n.isMoved = !1), void (n.startMoving = !1)
          );
        let h;
        if (
          ((n.isTouched = !1),
          (n.isMoved = !1),
          (n.startMoving = !1),
          (h = i.followFinger
            ? s
              ? t.translate
              : -t.translate
            : -n.currentTranslate),
          i.cssMode)
        )
          return;
        if (t.params.freeMode && i.freeMode.enabled)
          return void t.freeMode.onTouchEnd({ currentPos: h });
        let d = 0,
          p = t.slidesSizesGrid[0];
        for (
          let e = 0;
          e < a.length;
          e += e < i.slidesPerGroupSkip ? 1 : i.slidesPerGroup
        ) {
          const t = e < i.slidesPerGroupSkip - 1 ? 1 : i.slidesPerGroup;
          void 0 !== a[e + t]
            ? h >= a[e] && h < a[e + t] && ((d = e), (p = a[e + t] - a[e]))
            : h >= a[e] && ((d = e), (p = a[a.length - 1] - a[a.length - 2]));
        }
        let f = null,
          m = null;
        i.rewind &&
          (t.isBeginning
            ? (m =
                t.params.virtual && t.params.virtual.enabled && t.virtual
                  ? t.virtual.slides.length - 1
                  : t.slides.length - 1)
            : t.isEnd && (f = 0));
        const g = (h - a[d]) / p,
          v = d < i.slidesPerGroupSkip - 1 ? 1 : i.slidesPerGroup;
        if (u > i.longSwipesMs) {
          if (!i.longSwipes) return void t.slideTo(t.activeIndex);
          "next" === t.swipeDirection &&
            (g >= i.longSwipesRatio
              ? t.slideTo(i.rewind && t.isEnd ? f : d + v)
              : t.slideTo(d)),
            "prev" === t.swipeDirection &&
              (g > 1 - i.longSwipesRatio
                ? t.slideTo(d + v)
                : null !== m && g < 0 && Math.abs(g) > i.longSwipesRatio
                ? t.slideTo(m)
                : t.slideTo(d));
        } else {
          if (!i.shortSwipes) return void t.slideTo(t.activeIndex);
          !t.navigation ||
          (l.target !== t.navigation.nextEl && l.target !== t.navigation.prevEl)
            ? ("next" === t.swipeDirection && t.slideTo(null !== f ? f : d + v),
              "prev" === t.swipeDirection && t.slideTo(null !== m ? m : d))
            : l.target === t.navigation.nextEl
            ? t.slideTo(d + v)
            : t.slideTo(d);
        }
      }
      function Na() {
        const e = this,
          { params: t, el: n } = e;
        if (n && 0 === n.offsetWidth) return;
        t.breakpoints && e.setBreakpoint();
        const { allowSlideNext: i, allowSlidePrev: r, snapGrid: s } = e;
        (e.allowSlideNext = !0),
          (e.allowSlidePrev = !0),
          e.updateSize(),
          e.updateSlides(),
          e.updateSlidesClasses(),
          ("auto" === t.slidesPerView || t.slidesPerView > 1) &&
          e.isEnd &&
          !e.isBeginning &&
          !e.params.centeredSlides
            ? e.slideTo(e.slides.length - 1, 0, !1, !0)
            : e.slideTo(e.activeIndex, 0, !1, !0),
          e.autoplay &&
            e.autoplay.running &&
            e.autoplay.paused &&
            e.autoplay.run(),
          (e.allowSlidePrev = r),
          (e.allowSlideNext = i),
          e.params.watchOverflow && s !== e.snapGrid && e.checkOverflow();
      }
      function za(e) {
        const t = this;
        t.enabled &&
          (t.allowClick ||
            (t.params.preventClicks && e.preventDefault(),
            t.params.preventClicksPropagation &&
              t.animating &&
              (e.stopPropagation(), e.stopImmediatePropagation())));
      }
      function Ba() {
        const e = this,
          { wrapperEl: t, rtlTranslate: n, enabled: i } = e;
        if (!i) return;
        let r;
        (e.previousTranslate = e.translate),
          e.isHorizontal()
            ? (e.translate = -t.scrollLeft)
            : (e.translate = -t.scrollTop),
          0 === e.translate && (e.translate = 0),
          e.updateActiveIndex(),
          e.updateSlidesClasses();
        const s = e.maxTranslate() - e.minTranslate();
        (r = 0 === s ? 0 : (e.translate - e.minTranslate()) / s),
          r !== e.progress && e.updateProgress(n ? -e.translate : e.translate),
          e.emit("setTranslate", e.translate, !1);
      }
      let Ua = !1;
      function Va() {}
      const Ga = (e, t) => {
          const n = oa(),
            {
              params: i,
              touchEvents: r,
              el: s,
              wrapperEl: a,
              device: o,
              support: l,
            } = e,
            c = !!i.nested,
            u = "on" === t ? "addEventListener" : "removeEventListener",
            h = t;
          if (l.touch) {
            const t = !(
              "touchstart" !== r.start ||
              !l.passiveListener ||
              !i.passiveListeners
            ) && { passive: !0, capture: !1 };
            s[u](r.start, e.onTouchStart, t),
              s[u](
                r.move,
                e.onTouchMove,
                l.passiveListener ? { passive: !1, capture: c } : c
              ),
              s[u](r.end, e.onTouchEnd, t),
              r.cancel && s[u](r.cancel, e.onTouchEnd, t);
          } else
            s[u](r.start, e.onTouchStart, !1),
              n[u](r.move, e.onTouchMove, c),
              n[u](r.end, e.onTouchEnd, !1);
          (i.preventClicks || i.preventClicksPropagation) &&
            s[u]("click", e.onClick, !0),
            i.cssMode && a[u]("scroll", e.onScroll),
            i.updateOnWindowResize
              ? e[h](
                  o.ios || o.android
                    ? "resize orientationchange observerUpdate"
                    : "resize observerUpdate",
                  Na,
                  !0
                )
              : e[h]("observerUpdate", Na, !0);
        },
        Ha = {
          attachEvents: function () {
            const e = this,
              t = oa(),
              { params: n, support: i } = e;
            (e.onTouchStart = Ia.bind(e)),
              (e.onTouchMove = Fa.bind(e)),
              (e.onTouchEnd = Oa.bind(e)),
              n.cssMode && (e.onScroll = Ba.bind(e)),
              (e.onClick = za.bind(e)),
              i.touch &&
                !Ua &&
                (t.addEventListener("touchstart", Va), (Ua = !0)),
              Ga(e, "on");
          },
          detachEvents: function () {
            Ga(this, "off");
          },
        },
        Wa = (e, t) => e.grid && t.grid && t.grid.rows > 1,
        ja = {
          addClasses: function () {
            const e = this,
              {
                classNames: t,
                params: n,
                rtl: i,
                $el: r,
                device: s,
                support: a,
              } = e,
              o = (function (e, t) {
                const n = [];
                return (
                  e.forEach((e) => {
                    "object" == typeof e
                      ? Object.keys(e).forEach((i) => {
                          e[i] && n.push(t + i);
                        })
                      : "string" == typeof e && n.push(t + e);
                  }),
                  n
                );
              })(
                [
                  "initialized",
                  n.direction,
                  { "pointer-events": !a.touch },
                  { "free-mode": e.params.freeMode && n.freeMode.enabled },
                  { autoheight: n.autoHeight },
                  { rtl: i },
                  { grid: n.grid && n.grid.rows > 1 },
                  {
                    "grid-column":
                      n.grid && n.grid.rows > 1 && "column" === n.grid.fill,
                  },
                  { android: s.android },
                  { ios: s.ios },
                  { "css-mode": n.cssMode },
                  { centered: n.cssMode && n.centeredSlides },
                  { "watch-progress": n.watchSlidesProgress },
                ],
                n.containerModifierClass
              );
            t.push(...o),
              r.addClass([...t].join(" ")),
              e.emitContainerClasses();
          },
          removeClasses: function () {
            const { $el: e, classNames: t } = this;
            e.removeClass(t.join(" ")), this.emitContainerClasses();
          },
        },
        qa = {
          init: !0,
          direction: "horizontal",
          touchEventsTarget: "wrapper",
          initialSlide: 0,
          speed: 300,
          cssMode: !1,
          updateOnWindowResize: !0,
          resizeObserver: !0,
          nested: !1,
          createElements: !1,
          enabled: !0,
          focusableElements:
            "input, select, option, textarea, button, video, label",
          width: null,
          height: null,
          preventInteractionOnTransition: !1,
          userAgent: null,
          url: null,
          edgeSwipeDetection: !1,
          edgeSwipeThreshold: 20,
          autoHeight: !1,
          setWrapperSize: !1,
          virtualTranslate: !1,
          effect: "slide",
          breakpoints: void 0,
          breakpointsBase: "window",
          spaceBetween: 0,
          slidesPerView: 1,
          slidesPerGroup: 1,
          slidesPerGroupSkip: 0,
          slidesPerGroupAuto: !1,
          centeredSlides: !1,
          centeredSlidesBounds: !1,
          slidesOffsetBefore: 0,
          slidesOffsetAfter: 0,
          normalizeSlideIndex: !0,
          centerInsufficientSlides: !1,
          watchOverflow: !0,
          roundLengths: !1,
          touchRatio: 1,
          touchAngle: 45,
          simulateTouch: !0,
          shortSwipes: !0,
          longSwipes: !0,
          longSwipesRatio: 0.5,
          longSwipesMs: 300,
          followFinger: !0,
          allowTouchMove: !0,
          threshold: 0,
          touchMoveStopPropagation: !1,
          touchStartPreventDefault: !0,
          touchStartForcePreventDefault: !1,
          touchReleaseOnEdges: !1,
          uniqueNavElements: !0,
          resistance: !0,
          resistanceRatio: 0.85,
          watchSlidesProgress: !1,
          grabCursor: !1,
          preventClicks: !0,
          preventClicksPropagation: !0,
          slideToClickedSlide: !1,
          preloadImages: !0,
          updateOnImagesReady: !0,
          loop: !1,
          loopAdditionalSlides: 0,
          loopedSlides: null,
          loopFillGroupWithBlank: !1,
          loopPreventsSlide: !0,
          rewind: !1,
          allowSlidePrev: !0,
          allowSlideNext: !0,
          swipeHandler: null,
          noSwiping: !0,
          noSwipingClass: "swiper-no-swiping",
          noSwipingSelector: null,
          passiveListeners: !0,
          maxBackfaceHiddenSlides: 10,
          containerModifierClass: "swiper-",
          slideClass: "swiper-slide",
          slideBlankClass: "swiper-slide-invisible-blank",
          slideActiveClass: "swiper-slide-active",
          slideDuplicateActiveClass: "swiper-slide-duplicate-active",
          slideVisibleClass: "swiper-slide-visible",
          slideDuplicateClass: "swiper-slide-duplicate",
          slideNextClass: "swiper-slide-next",
          slideDuplicateNextClass: "swiper-slide-duplicate-next",
          slidePrevClass: "swiper-slide-prev",
          slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
          wrapperClass: "swiper-wrapper",
          runCallbacksOnInit: !0,
          _emitClasses: !1,
        };
      function Xa(e, t) {
        return function (n) {
          void 0 === n && (n = {});
          const i = Object.keys(n)[0],
            r = n[i];
          "object" == typeof r && null !== r
            ? (["navigation", "pagination", "scrollbar"].indexOf(i) >= 0 &&
                !0 === e[i] &&
                (e[i] = { auto: !0 }),
              i in e && "enabled" in r
                ? (!0 === e[i] && (e[i] = { enabled: !0 }),
                  "object" != typeof e[i] ||
                    "enabled" in e[i] ||
                    (e[i].enabled = !0),
                  e[i] || (e[i] = { enabled: !1 }),
                  wa(t, n))
                : wa(t, n))
            : wa(t, n);
        };
      }
      const Ya = {
          eventsEmitter: La,
          update: Pa,
          translate: {
            getTranslate: function (e) {
              void 0 === e && (e = this.isHorizontal() ? "x" : "y");
              const {
                params: t,
                rtlTranslate: n,
                translate: i,
                $wrapperEl: r,
              } = this;
              if (t.virtualTranslate) return n ? -i : i;
              if (t.cssMode) return i;
              let s = (function (e, t) {
                void 0 === t && (t = "x");
                const n = ca();
                let i, r, s;
                const a = (function (e) {
                  const t = ca();
                  let n;
                  return (
                    t.getComputedStyle && (n = t.getComputedStyle(e, null)),
                    !n && e.currentStyle && (n = e.currentStyle),
                    n || (n = e.style),
                    n
                  );
                })(e);
                return (
                  n.WebKitCSSMatrix
                    ? ((r = a.transform || a.webkitTransform),
                      r.split(",").length > 6 &&
                        (r = r
                          .split(", ")
                          .map((e) => e.replace(",", "."))
                          .join(", ")),
                      (s = new n.WebKitCSSMatrix("none" === r ? "" : r)))
                    : ((s =
                        a.MozTransform ||
                        a.OTransform ||
                        a.MsTransform ||
                        a.msTransform ||
                        a.transform ||
                        a
                          .getPropertyValue("transform")
                          .replace("translate(", "matrix(1, 0, 0, 1,")),
                      (i = s.toString().split(","))),
                  "x" === t &&
                    (r = n.WebKitCSSMatrix
                      ? s.m41
                      : 16 === i.length
                      ? parseFloat(i[12])
                      : parseFloat(i[4])),
                  "y" === t &&
                    (r = n.WebKitCSSMatrix
                      ? s.m42
                      : 16 === i.length
                      ? parseFloat(i[13])
                      : parseFloat(i[5])),
                  r || 0
                );
              })(r[0], e);
              return n && (s = -s), s || 0;
            },
            setTranslate: function (e, t) {
              const n = this,
                {
                  rtlTranslate: i,
                  params: r,
                  $wrapperEl: s,
                  wrapperEl: a,
                  progress: o,
                } = n;
              let l,
                c = 0,
                u = 0;
              n.isHorizontal() ? (c = i ? -e : e) : (u = e),
                r.roundLengths && ((c = Math.floor(c)), (u = Math.floor(u))),
                r.cssMode
                  ? (a[n.isHorizontal() ? "scrollLeft" : "scrollTop"] =
                      n.isHorizontal() ? -c : -u)
                  : r.virtualTranslate ||
                    s.transform(`translate3d(${c}px, ${u}px, 0px)`),
                (n.previousTranslate = n.translate),
                (n.translate = n.isHorizontal() ? c : u);
              const h = n.maxTranslate() - n.minTranslate();
              (l = 0 === h ? 0 : (e - n.minTranslate()) / h),
                l !== o && n.updateProgress(e),
                n.emit("setTranslate", n.translate, t);
            },
            minTranslate: function () {
              return -this.snapGrid[0];
            },
            maxTranslate: function () {
              return -this.snapGrid[this.snapGrid.length - 1];
            },
            translateTo: function (e, t, n, i, r) {
              void 0 === e && (e = 0),
                void 0 === t && (t = this.params.speed),
                void 0 === n && (n = !0),
                void 0 === i && (i = !0);
              const s = this,
                { params: a, wrapperEl: o } = s;
              if (s.animating && a.preventInteractionOnTransition) return !1;
              const l = s.minTranslate(),
                c = s.maxTranslate();
              let u;
              if (
                ((u = i && e > l ? l : i && e < c ? c : e),
                s.updateProgress(u),
                a.cssMode)
              ) {
                const e = s.isHorizontal();
                if (0 === t) o[e ? "scrollLeft" : "scrollTop"] = -u;
                else {
                  if (!s.support.smoothScroll)
                    return (
                      Ma({
                        swiper: s,
                        targetPosition: -u,
                        side: e ? "left" : "top",
                      }),
                      !0
                    );
                  o.scrollTo({ [e ? "left" : "top"]: -u, behavior: "smooth" });
                }
                return !0;
              }
              return (
                0 === t
                  ? (s.setTransition(0),
                    s.setTranslate(u),
                    n &&
                      (s.emit("beforeTransitionStart", t, r),
                      s.emit("transitionEnd")))
                  : (s.setTransition(t),
                    s.setTranslate(u),
                    n &&
                      (s.emit("beforeTransitionStart", t, r),
                      s.emit("transitionStart")),
                    s.animating ||
                      ((s.animating = !0),
                      s.onTranslateToWrapperTransitionEnd ||
                        (s.onTranslateToWrapperTransitionEnd = function (e) {
                          s &&
                            !s.destroyed &&
                            e.target === this &&
                            (s.$wrapperEl[0].removeEventListener(
                              "transitionend",
                              s.onTranslateToWrapperTransitionEnd
                            ),
                            s.$wrapperEl[0].removeEventListener(
                              "webkitTransitionEnd",
                              s.onTranslateToWrapperTransitionEnd
                            ),
                            (s.onTranslateToWrapperTransitionEnd = null),
                            delete s.onTranslateToWrapperTransitionEnd,
                            n && s.emit("transitionEnd"));
                        }),
                      s.$wrapperEl[0].addEventListener(
                        "transitionend",
                        s.onTranslateToWrapperTransitionEnd
                      ),
                      s.$wrapperEl[0].addEventListener(
                        "webkitTransitionEnd",
                        s.onTranslateToWrapperTransitionEnd
                      ))),
                !0
              );
            },
          },
          transition: {
            setTransition: function (e, t) {
              const n = this;
              n.params.cssMode || n.$wrapperEl.transition(e),
                n.emit("setTransition", e, t);
            },
            transitionStart: function (e, t) {
              void 0 === e && (e = !0);
              const n = this,
                { params: i } = n;
              i.cssMode ||
                (i.autoHeight && n.updateAutoHeight(),
                Da({
                  swiper: n,
                  runCallbacks: e,
                  direction: t,
                  step: "Start",
                }));
            },
            transitionEnd: function (e, t) {
              void 0 === e && (e = !0);
              const n = this,
                { params: i } = n;
              (n.animating = !1),
                i.cssMode ||
                  (n.setTransition(0),
                  Da({
                    swiper: n,
                    runCallbacks: e,
                    direction: t,
                    step: "End",
                  }));
            },
          },
          slide: ka,
          loop: Ra,
          grabCursor: {
            setGrabCursor: function (e) {
              const t = this;
              if (
                t.support.touch ||
                !t.params.simulateTouch ||
                (t.params.watchOverflow && t.isLocked) ||
                t.params.cssMode
              )
                return;
              const n =
                "container" === t.params.touchEventsTarget ? t.el : t.wrapperEl;
              (n.style.cursor = "move"),
                (n.style.cursor = e ? "grabbing" : "grab");
            },
            unsetGrabCursor: function () {
              const e = this;
              e.support.touch ||
                (e.params.watchOverflow && e.isLocked) ||
                e.params.cssMode ||
                (e[
                  "container" === e.params.touchEventsTarget
                    ? "el"
                    : "wrapperEl"
                ].style.cursor = "");
            },
          },
          events: Ha,
          breakpoints: {
            setBreakpoint: function () {
              const e = this,
                {
                  activeIndex: t,
                  initialized: n,
                  loopedSlides: i = 0,
                  params: r,
                  $el: s,
                } = e,
                a = r.breakpoints;
              if (!a || (a && 0 === Object.keys(a).length)) return;
              const o = e.getBreakpoint(a, e.params.breakpointsBase, e.el);
              if (!o || e.currentBreakpoint === o) return;
              const l = (o in a ? a[o] : void 0) || e.originalParams,
                c = Wa(e, r),
                u = Wa(e, l),
                h = r.enabled;
              c && !u
                ? (s.removeClass(
                    `${r.containerModifierClass}grid ${r.containerModifierClass}grid-column`
                  ),
                  e.emitContainerClasses())
                : !c &&
                  u &&
                  (s.addClass(`${r.containerModifierClass}grid`),
                  ((l.grid.fill && "column" === l.grid.fill) ||
                    (!l.grid.fill && "column" === r.grid.fill)) &&
                    s.addClass(`${r.containerModifierClass}grid-column`),
                  e.emitContainerClasses()),
                ["navigation", "pagination", "scrollbar"].forEach((t) => {
                  const n = r[t] && r[t].enabled,
                    i = l[t] && l[t].enabled;
                  n && !i && e[t].disable(), !n && i && e[t].enable();
                });
              const d = l.direction && l.direction !== r.direction,
                p = r.loop && (l.slidesPerView !== r.slidesPerView || d);
              d && n && e.changeDirection(), wa(e.params, l);
              const f = e.params.enabled;
              Object.assign(e, {
                allowTouchMove: e.params.allowTouchMove,
                allowSlideNext: e.params.allowSlideNext,
                allowSlidePrev: e.params.allowSlidePrev,
              }),
                h && !f ? e.disable() : !h && f && e.enable(),
                (e.currentBreakpoint = o),
                e.emit("_beforeBreakpoint", l),
                p &&
                  n &&
                  (e.loopDestroy(),
                  e.loopCreate(),
                  e.updateSlides(),
                  e.slideTo(t - i + e.loopedSlides, 0, !1)),
                e.emit("breakpoint", l);
            },
            getBreakpoint: function (e, t, n) {
              if (
                (void 0 === t && (t = "window"),
                !e || ("container" === t && !n))
              )
                return;
              let i = !1;
              const r = ca(),
                s = "window" === t ? r.innerHeight : n.clientHeight,
                a = Object.keys(e).map((e) => {
                  if ("string" == typeof e && 0 === e.indexOf("@")) {
                    const t = parseFloat(e.substr(1));
                    return { value: s * t, point: e };
                  }
                  return { value: e, point: e };
                });
              a.sort((e, t) => parseInt(e.value, 10) - parseInt(t.value, 10));
              for (let e = 0; e < a.length; e += 1) {
                const { point: s, value: o } = a[e];
                "window" === t
                  ? r.matchMedia(`(min-width: ${o}px)`).matches && (i = s)
                  : o <= n.clientWidth && (i = s);
              }
              return i || "max";
            },
          },
          checkOverflow: {
            checkOverflow: function () {
              const e = this,
                { isLocked: t, params: n } = e,
                { slidesOffsetBefore: i } = n;
              if (i) {
                const t = e.slides.length - 1,
                  n = e.slidesGrid[t] + e.slidesSizesGrid[t] + 2 * i;
                e.isLocked = e.size > n;
              } else e.isLocked = 1 === e.snapGrid.length;
              !0 === n.allowSlideNext && (e.allowSlideNext = !e.isLocked),
                !0 === n.allowSlidePrev && (e.allowSlidePrev = !e.isLocked),
                t && t !== e.isLocked && (e.isEnd = !1),
                t !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock");
            },
          },
          classes: ja,
          images: {
            loadImage: function (e, t, n, i, r, s) {
              const a = ca();
              let o;
              function l() {
                s && s();
              }
              va(e).parent("picture")[0] || (e.complete && r)
                ? l()
                : t
                ? ((o = new a.Image()),
                  (o.onload = l),
                  (o.onerror = l),
                  i && (o.sizes = i),
                  n && (o.srcset = n),
                  t && (o.src = t))
                : l();
            },
            preloadImages: function () {
              const e = this;
              function t() {
                null != e &&
                  e &&
                  !e.destroyed &&
                  (void 0 !== e.imagesLoaded && (e.imagesLoaded += 1),
                  e.imagesLoaded === e.imagesToLoad.length &&
                    (e.params.updateOnImagesReady && e.update(),
                    e.emit("imagesReady")));
              }
              e.imagesToLoad = e.$el.find("img");
              for (let n = 0; n < e.imagesToLoad.length; n += 1) {
                const i = e.imagesToLoad[n];
                e.loadImage(
                  i,
                  i.currentSrc || i.getAttribute("src"),
                  i.srcset || i.getAttribute("srcset"),
                  i.sizes || i.getAttribute("sizes"),
                  !0,
                  t
                );
              }
            },
          },
        },
        Za = {};
      class $a {
        constructor() {
          let e, t;
          for (var n = arguments.length, i = new Array(n), r = 0; r < n; r++)
            i[r] = arguments[r];
          if (
            (1 === i.length &&
            i[0].constructor &&
            "Object" === Object.prototype.toString.call(i[0]).slice(8, -1)
              ? (t = i[0])
              : ([e, t] = i),
            t || (t = {}),
            (t = wa({}, t)),
            e && !t.el && (t.el = e),
            t.el && va(t.el).length > 1)
          ) {
            const e = [];
            return (
              va(t.el).each((n) => {
                const i = wa({}, t, { el: n });
                e.push(new $a(i));
              }),
              e
            );
          }
          const s = this;
          var a;
          (s.__swiper__ = !0),
            (s.support = Ca()),
            (s.device =
              (void 0 === (a = { userAgent: t.userAgent }) && (a = {}),
              Ta ||
                (Ta = (function (e) {
                  let { userAgent: t } = void 0 === e ? {} : e;
                  const n = Ca(),
                    i = ca(),
                    r = i.navigator.platform,
                    s = t || i.navigator.userAgent,
                    a = { ios: !1, android: !1 },
                    o = i.screen.width,
                    l = i.screen.height,
                    c = s.match(/(Android);?[\s\/]+([\d.]+)?/);
                  let u = s.match(/(iPad).*OS\s([\d_]+)/);
                  const h = s.match(/(iPod)(.*OS\s([\d_]+))?/),
                    d = !u && s.match(/(iPhone\sOS|iOS)\s([\d_]+)/),
                    p = "Win32" === r;
                  let f = "MacIntel" === r;
                  return (
                    !u &&
                      f &&
                      n.touch &&
                      [
                        "1024x1366",
                        "1366x1024",
                        "834x1194",
                        "1194x834",
                        "834x1112",
                        "1112x834",
                        "768x1024",
                        "1024x768",
                        "820x1180",
                        "1180x820",
                        "810x1080",
                        "1080x810",
                      ].indexOf(`${o}x${l}`) >= 0 &&
                      ((u = s.match(/(Version)\/([\d.]+)/)),
                      u || (u = [0, 1, "13_0_0"]),
                      (f = !1)),
                    c && !p && ((a.os = "android"), (a.android = !0)),
                    (u || d || h) && ((a.os = "ios"), (a.ios = !0)),
                    a
                  );
                })(a)),
              Ta)),
            (s.browser =
              (Aa ||
                (Aa = (function () {
                  const e = ca();
                  return {
                    isSafari: (function () {
                      const t = e.navigator.userAgent.toLowerCase();
                      return (
                        t.indexOf("safari") >= 0 &&
                        t.indexOf("chrome") < 0 &&
                        t.indexOf("android") < 0
                      );
                    })(),
                    isWebView:
                      /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(
                        e.navigator.userAgent
                      ),
                  };
                })()),
              Aa)),
            (s.eventsListeners = {}),
            (s.eventsAnyListeners = []),
            (s.modules = [...s.__modules__]),
            t.modules &&
              Array.isArray(t.modules) &&
              s.modules.push(...t.modules);
          const o = {};
          s.modules.forEach((e) => {
            e({
              swiper: s,
              extendParams: Xa(t, o),
              on: s.on.bind(s),
              once: s.once.bind(s),
              off: s.off.bind(s),
              emit: s.emit.bind(s),
            });
          });
          const l = wa({}, qa, o);
          return (
            (s.params = wa({}, l, Za, t)),
            (s.originalParams = wa({}, s.params)),
            (s.passedParams = wa({}, t)),
            s.params &&
              s.params.on &&
              Object.keys(s.params.on).forEach((e) => {
                s.on(e, s.params.on[e]);
              }),
            s.params && s.params.onAny && s.onAny(s.params.onAny),
            (s.$ = va),
            Object.assign(s, {
              enabled: s.params.enabled,
              el: e,
              classNames: [],
              slides: va(),
              slidesGrid: [],
              snapGrid: [],
              slidesSizesGrid: [],
              isHorizontal: () => "horizontal" === s.params.direction,
              isVertical: () => "vertical" === s.params.direction,
              activeIndex: 0,
              realIndex: 0,
              isBeginning: !0,
              isEnd: !1,
              translate: 0,
              previousTranslate: 0,
              progress: 0,
              velocity: 0,
              animating: !1,
              allowSlideNext: s.params.allowSlideNext,
              allowSlidePrev: s.params.allowSlidePrev,
              touchEvents: (function () {
                const e = [
                    "touchstart",
                    "touchmove",
                    "touchend",
                    "touchcancel",
                  ],
                  t = ["pointerdown", "pointermove", "pointerup"];
                return (
                  (s.touchEventsTouch = {
                    start: e[0],
                    move: e[1],
                    end: e[2],
                    cancel: e[3],
                  }),
                  (s.touchEventsDesktop = {
                    start: t[0],
                    move: t[1],
                    end: t[2],
                  }),
                  s.support.touch || !s.params.simulateTouch
                    ? s.touchEventsTouch
                    : s.touchEventsDesktop
                );
              })(),
              touchEventsData: {
                isTouched: void 0,
                isMoved: void 0,
                allowTouchCallbacks: void 0,
                touchStartTime: void 0,
                isScrolling: void 0,
                currentTranslate: void 0,
                startTranslate: void 0,
                allowThresholdMove: void 0,
                focusableElements: s.params.focusableElements,
                lastClickTime: xa(),
                clickTimeout: void 0,
                velocities: [],
                allowMomentumBounce: void 0,
                isTouchEvent: void 0,
                startMoving: void 0,
              },
              allowClick: !0,
              allowTouchMove: s.params.allowTouchMove,
              touches: {
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0,
                diff: 0,
              },
              imagesToLoad: [],
              imagesLoaded: 0,
            }),
            s.emit("_swiper"),
            s.params.init && s.init(),
            s
          );
        }
        enable() {
          const e = this;
          e.enabled ||
            ((e.enabled = !0),
            e.params.grabCursor && e.setGrabCursor(),
            e.emit("enable"));
        }
        disable() {
          const e = this;
          e.enabled &&
            ((e.enabled = !1),
            e.params.grabCursor && e.unsetGrabCursor(),
            e.emit("disable"));
        }
        setProgress(e, t) {
          const n = this;
          e = Math.min(Math.max(e, 0), 1);
          const i = n.minTranslate(),
            r = (n.maxTranslate() - i) * e + i;
          n.translateTo(r, void 0 === t ? 0 : t),
            n.updateActiveIndex(),
            n.updateSlidesClasses();
        }
        emitContainerClasses() {
          const e = this;
          if (!e.params._emitClasses || !e.el) return;
          const t = e.el.className
            .split(" ")
            .filter(
              (t) =>
                0 === t.indexOf("swiper") ||
                0 === t.indexOf(e.params.containerModifierClass)
            );
          e.emit("_containerClasses", t.join(" "));
        }
        getSlideClasses(e) {
          const t = this;
          return t.destroyed
            ? ""
            : e.className
                .split(" ")
                .filter(
                  (e) =>
                    0 === e.indexOf("swiper-slide") ||
                    0 === e.indexOf(t.params.slideClass)
                )
                .join(" ");
        }
        emitSlidesClasses() {
          const e = this;
          if (!e.params._emitClasses || !e.el) return;
          const t = [];
          e.slides.each((n) => {
            const i = e.getSlideClasses(n);
            t.push({ slideEl: n, classNames: i }), e.emit("_slideClass", n, i);
          }),
            e.emit("_slideClasses", t);
        }
        slidesPerViewDynamic(e, t) {
          void 0 === e && (e = "current"), void 0 === t && (t = !1);
          const {
            params: n,
            slides: i,
            slidesGrid: r,
            slidesSizesGrid: s,
            size: a,
            activeIndex: o,
          } = this;
          let l = 1;
          if (n.centeredSlides) {
            let e,
              t = i[o].swiperSlideSize;
            for (let n = o + 1; n < i.length; n += 1)
              i[n] &&
                !e &&
                ((t += i[n].swiperSlideSize), (l += 1), t > a && (e = !0));
            for (let n = o - 1; n >= 0; n -= 1)
              i[n] &&
                !e &&
                ((t += i[n].swiperSlideSize), (l += 1), t > a && (e = !0));
          } else if ("current" === e)
            for (let e = o + 1; e < i.length; e += 1)
              (t ? r[e] + s[e] - r[o] < a : r[e] - r[o] < a) && (l += 1);
          else for (let e = o - 1; e >= 0; e -= 1) r[o] - r[e] < a && (l += 1);
          return l;
        }
        update() {
          const e = this;
          if (!e || e.destroyed) return;
          const { snapGrid: t, params: n } = e;
          function i() {
            const t = e.rtlTranslate ? -1 * e.translate : e.translate,
              n = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate());
            e.setTranslate(n), e.updateActiveIndex(), e.updateSlidesClasses();
          }
          let r;
          n.breakpoints && e.setBreakpoint(),
            e.updateSize(),
            e.updateSlides(),
            e.updateProgress(),
            e.updateSlidesClasses(),
            e.params.freeMode && e.params.freeMode.enabled
              ? (i(), e.params.autoHeight && e.updateAutoHeight())
              : ((r =
                  ("auto" === e.params.slidesPerView ||
                    e.params.slidesPerView > 1) &&
                  e.isEnd &&
                  !e.params.centeredSlides
                    ? e.slideTo(e.slides.length - 1, 0, !1, !0)
                    : e.slideTo(e.activeIndex, 0, !1, !0)),
                r || i()),
            n.watchOverflow && t !== e.snapGrid && e.checkOverflow(),
            e.emit("update");
        }
        changeDirection(e, t) {
          void 0 === t && (t = !0);
          const n = this,
            i = n.params.direction;
          return (
            e || (e = "horizontal" === i ? "vertical" : "horizontal"),
            e === i ||
              ("horizontal" !== e && "vertical" !== e) ||
              (n.$el
                .removeClass(`${n.params.containerModifierClass}${i}`)
                .addClass(`${n.params.containerModifierClass}${e}`),
              n.emitContainerClasses(),
              (n.params.direction = e),
              n.slides.each((t) => {
                "vertical" === e ? (t.style.width = "") : (t.style.height = "");
              }),
              n.emit("changeDirection"),
              t && n.update()),
            n
          );
        }
        changeLanguageDirection(e) {
          const t = this;
          (t.rtl && "rtl" === e) ||
            (!t.rtl && "ltr" === e) ||
            ((t.rtl = "rtl" === e),
            (t.rtlTranslate = "horizontal" === t.params.direction && t.rtl),
            t.rtl
              ? (t.$el.addClass(`${t.params.containerModifierClass}rtl`),
                (t.el.dir = "rtl"))
              : (t.$el.removeClass(`${t.params.containerModifierClass}rtl`),
                (t.el.dir = "ltr")),
            t.update());
        }
        mount(e) {
          const t = this;
          if (t.mounted) return !0;
          const n = va(e || t.params.el);
          if (!(e = n[0])) return !1;
          e.swiper = t;
          const i = () =>
            `.${(t.params.wrapperClass || "").trim().split(" ").join(".")}`;
          let r = (() => {
            if (e && e.shadowRoot && e.shadowRoot.querySelector) {
              const t = va(e.shadowRoot.querySelector(i()));
              return (t.children = (e) => n.children(e)), t;
            }
            return n.children ? n.children(i()) : va(n).children(i());
          })();
          if (0 === r.length && t.params.createElements) {
            const e = oa().createElement("div");
            (r = va(e)),
              (e.className = t.params.wrapperClass),
              n.append(e),
              n.children(`.${t.params.slideClass}`).each((e) => {
                r.append(e);
              });
          }
          return (
            Object.assign(t, {
              $el: n,
              el: e,
              $wrapperEl: r,
              wrapperEl: r[0],
              mounted: !0,
              rtl:
                "rtl" === e.dir.toLowerCase() || "rtl" === n.css("direction"),
              rtlTranslate:
                "horizontal" === t.params.direction &&
                ("rtl" === e.dir.toLowerCase() || "rtl" === n.css("direction")),
              wrongRTL: "-webkit-box" === r.css("display"),
            }),
            !0
          );
        }
        init(e) {
          const t = this;
          return (
            t.initialized ||
              !1 === t.mount(e) ||
              (t.emit("beforeInit"),
              t.params.breakpoints && t.setBreakpoint(),
              t.addClasses(),
              t.params.loop && t.loopCreate(),
              t.updateSize(),
              t.updateSlides(),
              t.params.watchOverflow && t.checkOverflow(),
              t.params.grabCursor && t.enabled && t.setGrabCursor(),
              t.params.preloadImages && t.preloadImages(),
              t.params.loop
                ? t.slideTo(
                    t.params.initialSlide + t.loopedSlides,
                    0,
                    t.params.runCallbacksOnInit,
                    !1,
                    !0
                  )
                : t.slideTo(
                    t.params.initialSlide,
                    0,
                    t.params.runCallbacksOnInit,
                    !1,
                    !0
                  ),
              t.attachEvents(),
              (t.initialized = !0),
              t.emit("init"),
              t.emit("afterInit")),
            t
          );
        }
        destroy(e, t) {
          void 0 === e && (e = !0), void 0 === t && (t = !0);
          const n = this,
            { params: i, $el: r, $wrapperEl: s, slides: a } = n;
          return (
            void 0 === n.params ||
              n.destroyed ||
              (n.emit("beforeDestroy"),
              (n.initialized = !1),
              n.detachEvents(),
              i.loop && n.loopDestroy(),
              t &&
                (n.removeClasses(),
                r.removeAttr("style"),
                s.removeAttr("style"),
                a &&
                  a.length &&
                  a
                    .removeClass(
                      [
                        i.slideVisibleClass,
                        i.slideActiveClass,
                        i.slideNextClass,
                        i.slidePrevClass,
                      ].join(" ")
                    )
                    .removeAttr("style")
                    .removeAttr("data-swiper-slide-index")),
              n.emit("destroy"),
              Object.keys(n.eventsListeners).forEach((e) => {
                n.off(e);
              }),
              !1 !== e &&
                ((n.$el[0].swiper = null),
                (function (e) {
                  const t = e;
                  Object.keys(t).forEach((e) => {
                    try {
                      t[e] = null;
                    } catch (e) {}
                    try {
                      delete t[e];
                    } catch (e) {}
                  });
                })(n)),
              (n.destroyed = !0)),
            null
          );
        }
        static extendDefaults(e) {
          wa(Za, e);
        }
        static get extendedDefaults() {
          return Za;
        }
        static get defaults() {
          return qa;
        }
        static installModule(e) {
          $a.prototype.__modules__ || ($a.prototype.__modules__ = []);
          const t = $a.prototype.__modules__;
          "function" == typeof e && t.indexOf(e) < 0 && t.push(e);
        }
        static use(e) {
          return Array.isArray(e)
            ? (e.forEach((e) => $a.installModule(e)), $a)
            : ($a.installModule(e), $a);
        }
      }
      Object.keys(Ya).forEach((e) => {
        Object.keys(Ya[e]).forEach((t) => {
          $a.prototype[t] = Ya[e][t];
        });
      }),
        $a.use([
          function (e) {
            let { swiper: t, on: n, emit: i } = e;
            const r = ca();
            let s = null,
              a = null;
            const o = () => {
                t &&
                  !t.destroyed &&
                  t.initialized &&
                  (i("beforeResize"), i("resize"));
              },
              l = () => {
                t && !t.destroyed && t.initialized && i("orientationchange");
              };
            n("init", () => {
              t.params.resizeObserver && void 0 !== r.ResizeObserver
                ? t &&
                  !t.destroyed &&
                  t.initialized &&
                  ((s = new ResizeObserver((e) => {
                    a = r.requestAnimationFrame(() => {
                      const { width: n, height: i } = t;
                      let r = n,
                        s = i;
                      e.forEach((e) => {
                        let {
                          contentBoxSize: n,
                          contentRect: i,
                          target: a,
                        } = e;
                        (a && a !== t.el) ||
                          ((r = i ? i.width : (n[0] || n).inlineSize),
                          (s = i ? i.height : (n[0] || n).blockSize));
                      }),
                        (r === n && s === i) || o();
                    });
                  })),
                  s.observe(t.el))
                : (r.addEventListener("resize", o),
                  r.addEventListener("orientationchange", l));
            }),
              n("destroy", () => {
                a && r.cancelAnimationFrame(a),
                  s && s.unobserve && t.el && (s.unobserve(t.el), (s = null)),
                  r.removeEventListener("resize", o),
                  r.removeEventListener("orientationchange", l);
              });
          },
          function (e) {
            let { swiper: t, extendParams: n, on: i, emit: r } = e;
            const s = [],
              a = ca(),
              o = function (e, t) {
                void 0 === t && (t = {});
                const n = new (a.MutationObserver || a.WebkitMutationObserver)(
                  (e) => {
                    if (1 === e.length) return void r("observerUpdate", e[0]);
                    const t = function () {
                      r("observerUpdate", e[0]);
                    };
                    a.requestAnimationFrame
                      ? a.requestAnimationFrame(t)
                      : a.setTimeout(t, 0);
                  }
                );
                n.observe(e, {
                  attributes: void 0 === t.attributes || t.attributes,
                  childList: void 0 === t.childList || t.childList,
                  characterData: void 0 === t.characterData || t.characterData,
                }),
                  s.push(n);
              };
            n({ observer: !1, observeParents: !1, observeSlideChildren: !1 }),
              i("init", () => {
                if (t.params.observer) {
                  if (t.params.observeParents) {
                    const e = t.$el.parents();
                    for (let t = 0; t < e.length; t += 1) o(e[t]);
                  }
                  o(t.$el[0], { childList: t.params.observeSlideChildren }),
                    o(t.$wrapperEl[0], { attributes: !1 });
                }
              }),
              i("destroy", () => {
                s.forEach((e) => {
                  e.disconnect();
                }),
                  s.splice(0, s.length);
              });
          },
        ]);
      const Ka = $a;
      var Ja = n(379),
        Qa = n.n(Ja),
        eo = n(795),
        to = n.n(eo),
        no = n(569),
        io = n.n(no),
        ro = n(565),
        so = n.n(ro),
        ao = n(216),
        oo = n.n(ao),
        lo = n(589),
        co = n.n(lo),
        uo = n(147),
        ho = {};
      (ho.styleTagTransform = co()),
        (ho.setAttributes = so()),
        (ho.insert = io().bind(null, "head")),
        (ho.domAPI = to()),
        (ho.insertStyleElement = oo()),
        Qa()(uo.Z, ho),
        uo.Z && uo.Z.locals && uo.Z.locals;
      var po = (function () {
        var e = function (t, n) {
          return (
            (e =
              Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array &&
                function (e, t) {
                  e.__proto__ = t;
                }) ||
              function (e, t) {
                for (var n in t)
                  Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
              }),
            e(t, n)
          );
        };
        return function (t, n) {
          if ("function" != typeof n && null !== n)
            throw new TypeError(
              "Class extends value " +
                String(n) +
                " is not a constructor or null"
            );
          function i() {
            this.constructor = t;
          }
          e(t, n),
            (t.prototype =
              null === n
                ? Object.create(n)
                : ((i.prototype = n.prototype), new i()));
        };
      })();
      Ka.use([
        function (e) {
          let t,
            { swiper: n, extendParams: i, on: r, emit: s } = e;
          function a() {
            const e = n.slides.eq(n.activeIndex);
            let i = n.params.autoplay.delay;
            e.attr("data-swiper-autoplay") &&
              (i = e.attr("data-swiper-autoplay") || n.params.autoplay.delay),
              clearTimeout(t),
              (t = _a(() => {
                let e;
                n.params.autoplay.reverseDirection
                  ? n.params.loop
                    ? (n.loopFix(),
                      (e = n.slidePrev(n.params.speed, !0, !0)),
                      s("autoplay"))
                    : n.isBeginning
                    ? n.params.autoplay.stopOnLastSlide
                      ? l()
                      : ((e = n.slideTo(
                          n.slides.length - 1,
                          n.params.speed,
                          !0,
                          !0
                        )),
                        s("autoplay"))
                    : ((e = n.slidePrev(n.params.speed, !0, !0)), s("autoplay"))
                  : n.params.loop
                  ? (n.loopFix(),
                    (e = n.slideNext(n.params.speed, !0, !0)),
                    s("autoplay"))
                  : n.isEnd
                  ? n.params.autoplay.stopOnLastSlide
                    ? l()
                    : ((e = n.slideTo(0, n.params.speed, !0, !0)),
                      s("autoplay"))
                  : ((e = n.slideNext(n.params.speed, !0, !0)), s("autoplay")),
                  ((n.params.cssMode && n.autoplay.running) || !1 === e) && a();
              }, i));
          }
          function o() {
            return (
              void 0 === t &&
              !n.autoplay.running &&
              ((n.autoplay.running = !0), s("autoplayStart"), a(), !0)
            );
          }
          function l() {
            return (
              !!n.autoplay.running &&
              void 0 !== t &&
              (t && (clearTimeout(t), (t = void 0)),
              (n.autoplay.running = !1),
              s("autoplayStop"),
              !0)
            );
          }
          function c(e) {
            n.autoplay.running &&
              (n.autoplay.paused ||
                (t && clearTimeout(t),
                (n.autoplay.paused = !0),
                0 !== e && n.params.autoplay.waitForTransition
                  ? ["transitionend", "webkitTransitionEnd"].forEach((e) => {
                      n.$wrapperEl[0].addEventListener(e, h);
                    })
                  : ((n.autoplay.paused = !1), a())));
          }
          function u() {
            const e = oa();
            "hidden" === e.visibilityState && n.autoplay.running && c(),
              "visible" === e.visibilityState &&
                n.autoplay.paused &&
                (a(), (n.autoplay.paused = !1));
          }
          function h(e) {
            n &&
              !n.destroyed &&
              n.$wrapperEl &&
              e.target === n.$wrapperEl[0] &&
              (["transitionend", "webkitTransitionEnd"].forEach((e) => {
                n.$wrapperEl[0].removeEventListener(e, h);
              }),
              (n.autoplay.paused = !1),
              n.autoplay.running ? a() : l());
          }
          function d() {
            n.params.autoplay.disableOnInteraction
              ? l()
              : (s("autoplayPause"), c()),
              ["transitionend", "webkitTransitionEnd"].forEach((e) => {
                n.$wrapperEl[0].removeEventListener(e, h);
              });
          }
          function p() {
            n.params.autoplay.disableOnInteraction ||
              ((n.autoplay.paused = !1), s("autoplayResume"), a());
          }
          (n.autoplay = { running: !1, paused: !1 }),
            i({
              autoplay: {
                enabled: !1,
                delay: 3e3,
                waitForTransition: !0,
                disableOnInteraction: !0,
                stopOnLastSlide: !1,
                reverseDirection: !1,
                pauseOnMouseEnter: !1,
              },
            }),
            r("init", () => {
              n.params.autoplay.enabled &&
                (o(),
                oa().addEventListener("visibilitychange", u),
                n.params.autoplay.pauseOnMouseEnter &&
                  (n.$el.on("mouseenter", d), n.$el.on("mouseleave", p)));
            }),
            r("beforeTransitionStart", (e, t, i) => {
              n.autoplay.running &&
                (i || !n.params.autoplay.disableOnInteraction
                  ? n.autoplay.pause(t)
                  : l());
            }),
            r("sliderFirstMove", () => {
              n.autoplay.running &&
                (n.params.autoplay.disableOnInteraction ? l() : c());
            }),
            r("touchEnd", () => {
              n.params.cssMode &&
                n.autoplay.paused &&
                !n.params.autoplay.disableOnInteraction &&
                a();
            }),
            r("destroy", () => {
              n.$el.off("mouseenter", d),
                n.$el.off("mouseleave", p),
                n.autoplay.running && l(),
                oa().removeEventListener("visibilitychange", u);
            }),
            Object.assign(n.autoplay, { pause: c, run: a, start: o, stop: l });
        },
      ]);
      const fo = (function (e) {
        function t(t) {
          var n = e.call(this, t) || this,
            i = document.querySelector(".".concat("inwork"));
          if (!i) throw new Error("Cant initialize Inwork Screen");
          return (n.root = i), n.initializeSlider(), n;
        }
        return (
          po(t, e),
          (t.prototype.isCanBeChanged = function (e) {
            return !0;
          }),
          (t.prototype.initializeSlider = function () {
            new Ka(".".concat("inwork__slider"), {
              autoplay: { delay: 2e3 },
              loop: !0,
              observer: !0,
              speed: 1e3,
              breakpoints: {
                940: { slidesPerView: 2, spaceBetween: 100 },
                0: { slidesPerView: 1, spaceBetween: 60 },
              },
            });
          }),
          t
        );
      })(t);
      var mo = (function () {
        var e = function (t, n) {
          return (
            (e =
              Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array &&
                function (e, t) {
                  e.__proto__ = t;
                }) ||
              function (e, t) {
                for (var n in t)
                  Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
              }),
            e(t, n)
          );
        };
        return function (t, n) {
          if ("function" != typeof n && null !== n)
            throw new TypeError(
              "Class extends value " +
                String(n) +
                " is not a constructor or null"
            );
          function i() {
            this.constructor = t;
          }
          e(t, n),
            (t.prototype =
              null === n
                ? Object.create(n)
                : ((i.prototype = n.prototype), new i()));
        };
      })();
      const go = (function (e) {
        function t(t) {
          var n = e.call(this, t) || this,
            i = document.querySelector(".".concat("clients"));
          if (!i) throw new Error("Cant initialize Clients Screen");
          return (n.root = i), n;
        }
        return (
          mo(t, e),
          (t.prototype.isCanBeChanged = function (e) {
            return !0;
          }),
          t
        );
      })(t);
      function vo(e) {
        return (
          (vo =
            "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
              ? function (e) {
                  return typeof e;
                }
              : function (e) {
                  return e &&
                    "function" == typeof Symbol &&
                    e.constructor === Symbol &&
                    e !== Symbol.prototype
                    ? "symbol"
                    : typeof e;
                }),
          vo(e)
        );
      }
      function _o(e, t) {
        if (!(e instanceof t))
          throw new TypeError("Cannot call a class as a function");
      }
      function xo(e, t) {
        for (var n = 0; n < t.length; n++) {
          var i = t[n];
          (i.enumerable = i.enumerable || !1),
            (i.configurable = !0),
            "value" in i && (i.writable = !0),
            Object.defineProperty(e, i.key, i);
        }
      }
      function yo(e, t, n) {
        return (
          t && xo(e.prototype, t),
          n && xo(e, n),
          Object.defineProperty(e, "prototype", { writable: !1 }),
          e
        );
      }
      function bo(e, t) {
        if ("function" != typeof t && null !== t)
          throw new TypeError(
            "Super expression must either be null or a function"
          );
        (e.prototype = Object.create(t && t.prototype, {
          constructor: { value: e, writable: !0, configurable: !0 },
        })),
          Object.defineProperty(e, "prototype", { writable: !1 }),
          t && So(e, t);
      }
      function wo(e) {
        return (
          (wo = Object.setPrototypeOf
            ? Object.getPrototypeOf
            : function (e) {
                return e.__proto__ || Object.getPrototypeOf(e);
              }),
          wo(e)
        );
      }
      function So(e, t) {
        return (
          (So =
            Object.setPrototypeOf ||
            function (e, t) {
              return (e.__proto__ = t), e;
            }),
          So(e, t)
        );
      }
      function Mo(e, t) {
        if (null == e) return {};
        var n,
          i,
          r = (function (e, t) {
            if (null == e) return {};
            var n,
              i,
              r = {},
              s = Object.keys(e);
            for (i = 0; i < s.length; i++)
              (n = s[i]), t.indexOf(n) >= 0 || (r[n] = e[n]);
            return r;
          })(e, t);
        if (Object.getOwnPropertySymbols) {
          var s = Object.getOwnPropertySymbols(e);
          for (i = 0; i < s.length; i++)
            (n = s[i]),
              t.indexOf(n) >= 0 ||
                (Object.prototype.propertyIsEnumerable.call(e, n) &&
                  (r[n] = e[n]));
        }
        return r;
      }
      function Eo(e, t) {
        if (t && ("object" == typeof t || "function" == typeof t)) return t;
        if (void 0 !== t)
          throw new TypeError(
            "Derived constructors may only return object or undefined"
          );
        return (function (e) {
          if (void 0 === e)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          return e;
        })(e);
      }
      function To(e) {
        var t = (function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;
          try {
            return (
              Boolean.prototype.valueOf.call(
                Reflect.construct(Boolean, [], function () {})
              ),
              !0
            );
          } catch (e) {
            return !1;
          }
        })();
        return function () {
          var n,
            i = wo(e);
          if (t) {
            var r = wo(this).constructor;
            n = Reflect.construct(i, arguments, r);
          } else n = i.apply(this, arguments);
          return Eo(this, n);
        };
      }
      function Ao(e, t) {
        for (
          ;
          !Object.prototype.hasOwnProperty.call(e, t) && null !== (e = wo(e));

        );
        return e;
      }
      function Co() {
        return (
          (Co =
            "undefined" != typeof Reflect && Reflect.get
              ? Reflect.get
              : function (e, t, n) {
                  var i = Ao(e, t);
                  if (i) {
                    var r = Object.getOwnPropertyDescriptor(i, t);
                    return r.get
                      ? r.get.call(arguments.length < 3 ? e : n)
                      : r.value;
                  }
                }),
          Co.apply(this, arguments)
        );
      }
      function Lo(e, t, n, i) {
        return (
          (Lo =
            "undefined" != typeof Reflect && Reflect.set
              ? Reflect.set
              : function (e, t, n, i) {
                  var r,
                    s = Ao(e, t);
                  if (s) {
                    if ((r = Object.getOwnPropertyDescriptor(s, t)).set)
                      return r.set.call(i, n), !0;
                    if (!r.writable) return !1;
                  }
                  if ((r = Object.getOwnPropertyDescriptor(i, t))) {
                    if (!r.writable) return !1;
                    (r.value = n), Object.defineProperty(i, t, r);
                  } else
                    !(function (e, t, n) {
                      t in e
                        ? Object.defineProperty(e, t, {
                            value: n,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                          })
                        : (e[t] = n);
                    })(i, t, n);
                  return !0;
                }),
          Lo(e, t, n, i)
        );
      }
      function Po(e, t, n, i, r) {
        if (!Lo(e, t, n, i || e) && r)
          throw new Error("failed to set property");
        return n;
      }
      function Do(e, t) {
        return (
          (function (e) {
            if (Array.isArray(e)) return e;
          })(e) ||
          (function (e, t) {
            var n =
              null == e
                ? null
                : ("undefined" != typeof Symbol && e[Symbol.iterator]) ||
                  e["@@iterator"];
            if (null != n) {
              var i,
                r,
                s = [],
                a = !0,
                o = !1;
              try {
                for (
                  n = n.call(e);
                  !(a = (i = n.next()).done) &&
                  (s.push(i.value), !t || s.length !== t);
                  a = !0
                );
              } catch (e) {
                (o = !0), (r = e);
              } finally {
                try {
                  a || null == n.return || n.return();
                } finally {
                  if (o) throw r;
                }
              }
              return s;
            }
          })(e, t) ||
          (function (e, t) {
            if (e) {
              if ("string" == typeof e) return ko(e, t);
              var n = Object.prototype.toString.call(e).slice(8, -1);
              return (
                "Object" === n && e.constructor && (n = e.constructor.name),
                "Map" === n || "Set" === n
                  ? Array.from(e)
                  : "Arguments" === n ||
                    /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
                  ? ko(e, t)
                  : void 0
              );
            }
          })(e, t) ||
          (function () {
            throw new TypeError(
              "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
            );
          })()
        );
      }
      function ko(e, t) {
        (null == t || t > e.length) && (t = e.length);
        for (var n = 0, i = new Array(t); n < t; n++) i[n] = e[n];
        return i;
      }
      var Ro = (function () {
        function e(t) {
          _o(this, e),
            Object.assign(
              this,
              { inserted: "", rawInserted: "", skip: !1, tailShift: 0 },
              t
            );
        }
        return (
          yo(e, [
            {
              key: "aggregate",
              value: function (e) {
                return (
                  (this.rawInserted += e.rawInserted),
                  (this.skip = this.skip || e.skip),
                  (this.inserted += e.inserted),
                  (this.tailShift += e.tailShift),
                  this
                );
              },
            },
            {
              key: "offset",
              get: function () {
                return this.tailShift + this.inserted.length;
              },
            },
          ]),
          e
        );
      })();
      function Io(e) {
        return "string" == typeof e || e instanceof String;
      }
      var Fo = "NONE",
        Oo = "LEFT",
        No = "FORCE_LEFT",
        zo = "RIGHT",
        Bo = "FORCE_RIGHT";
      function Uo(e) {
        return e.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
      }
      function Vo(e) {
        return Array.isArray(e) ? e : [e, new Ro()];
      }
      function Go(e, t) {
        if (t === e) return !0;
        var n,
          i = Array.isArray(t),
          r = Array.isArray(e);
        if (i && r) {
          if (t.length != e.length) return !1;
          for (n = 0; n < t.length; n++) if (!Go(t[n], e[n])) return !1;
          return !0;
        }
        if (i != r) return !1;
        if (t && e && "object" === vo(t) && "object" === vo(e)) {
          var s = t instanceof Date,
            a = e instanceof Date;
          if (s && a) return t.getTime() == e.getTime();
          if (s != a) return !1;
          var o = t instanceof RegExp,
            l = e instanceof RegExp;
          if (o && l) return t.toString() == e.toString();
          if (o != l) return !1;
          var c = Object.keys(t);
          for (n = 0; n < c.length; n++)
            if (!Object.prototype.hasOwnProperty.call(e, c[n])) return !1;
          for (n = 0; n < c.length; n++) if (!Go(e[c[n]], t[c[n]])) return !1;
          return !0;
        }
        return (
          !(!t || !e || "function" != typeof t || "function" != typeof e) &&
          t.toString() === e.toString()
        );
      }
      var Ho = (function () {
          function e(t, n, i, r) {
            for (
              _o(this, e),
                this.value = t,
                this.cursorPos = n,
                this.oldValue = i,
                this.oldSelection = r;
              this.value.slice(0, this.startChangePos) !==
              this.oldValue.slice(0, this.startChangePos);

            )
              --this.oldSelection.start;
          }
          return (
            yo(e, [
              {
                key: "startChangePos",
                get: function () {
                  return Math.min(this.cursorPos, this.oldSelection.start);
                },
              },
              {
                key: "insertedCount",
                get: function () {
                  return this.cursorPos - this.startChangePos;
                },
              },
              {
                key: "inserted",
                get: function () {
                  return this.value.substr(
                    this.startChangePos,
                    this.insertedCount
                  );
                },
              },
              {
                key: "removedCount",
                get: function () {
                  return Math.max(
                    this.oldSelection.end - this.startChangePos ||
                      this.oldValue.length - this.value.length,
                    0
                  );
                },
              },
              {
                key: "removed",
                get: function () {
                  return this.oldValue.substr(
                    this.startChangePos,
                    this.removedCount
                  );
                },
              },
              {
                key: "head",
                get: function () {
                  return this.value.substring(0, this.startChangePos);
                },
              },
              {
                key: "tail",
                get: function () {
                  return this.value.substring(
                    this.startChangePos + this.insertedCount
                  );
                },
              },
              {
                key: "removeDirection",
                get: function () {
                  return !this.removedCount || this.insertedCount
                    ? Fo
                    : (this.oldSelection.end !== this.cursorPos &&
                        this.oldSelection.start !== this.cursorPos) ||
                      this.oldSelection.end !== this.oldSelection.start
                    ? Oo
                    : zo;
                },
              },
            ]),
            e
          );
        })(),
        Wo = (function () {
          function e() {
            var t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : "",
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 0,
              i = arguments.length > 2 ? arguments[2] : void 0;
            _o(this, e), (this.value = t), (this.from = n), (this.stop = i);
          }
          return (
            yo(e, [
              {
                key: "toString",
                value: function () {
                  return this.value;
                },
              },
              {
                key: "extend",
                value: function (e) {
                  this.value += String(e);
                },
              },
              {
                key: "appendTo",
                value: function (e) {
                  return e
                    .append(this.toString(), { tail: !0 })
                    .aggregate(e._appendPlaceholder());
                },
              },
              {
                key: "state",
                get: function () {
                  return {
                    value: this.value,
                    from: this.from,
                    stop: this.stop,
                  };
                },
                set: function (e) {
                  Object.assign(this, e);
                },
              },
              {
                key: "unshift",
                value: function (e) {
                  if (!this.value.length || (null != e && this.from >= e))
                    return "";
                  var t = this.value[0];
                  return (this.value = this.value.slice(1)), t;
                },
              },
              {
                key: "shift",
                value: function () {
                  if (!this.value.length) return "";
                  var e = this.value[this.value.length - 1];
                  return (this.value = this.value.slice(0, -1)), e;
                },
              },
            ]),
            e
          );
        })();
      function jo(e) {
        var t =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        return new jo.InputMask(e, t);
      }
      var qo = (function () {
        function e(t) {
          _o(this, e),
            (this._value = ""),
            this._update(Object.assign({}, e.DEFAULTS, t)),
            (this.isInitialized = !0);
        }
        return (
          yo(e, [
            {
              key: "updateOptions",
              value: function (e) {
                Object.keys(e).length &&
                  this.withValueRefresh(this._update.bind(this, e));
              },
            },
            {
              key: "_update",
              value: function (e) {
                Object.assign(this, e);
              },
            },
            {
              key: "state",
              get: function () {
                return { _value: this.value };
              },
              set: function (e) {
                this._value = e._value;
              },
            },
            {
              key: "reset",
              value: function () {
                this._value = "";
              },
            },
            {
              key: "value",
              get: function () {
                return this._value;
              },
              set: function (e) {
                this.resolve(e);
              },
            },
            {
              key: "resolve",
              value: function (e) {
                return (
                  this.reset(),
                  this.append(e, { input: !0 }, ""),
                  this.doCommit(),
                  this.value
                );
              },
            },
            {
              key: "unmaskedValue",
              get: function () {
                return this.value;
              },
              set: function (e) {
                this.reset(), this.append(e, {}, ""), this.doCommit();
              },
            },
            {
              key: "typedValue",
              get: function () {
                return this.doParse(this.value);
              },
              set: function (e) {
                this.value = this.doFormat(e);
              },
            },
            {
              key: "rawInputValue",
              get: function () {
                return this.extractInput(0, this.value.length, { raw: !0 });
              },
              set: function (e) {
                this.reset(), this.append(e, { raw: !0 }, ""), this.doCommit();
              },
            },
            {
              key: "isComplete",
              get: function () {
                return !0;
              },
            },
            {
              key: "isFilled",
              get: function () {
                return this.isComplete;
              },
            },
            {
              key: "nearestInputPos",
              value: function (e, t) {
                return e;
              },
            },
            {
              key: "extractInput",
              value: function () {
                var e =
                    arguments.length > 0 && void 0 !== arguments[0]
                      ? arguments[0]
                      : 0,
                  t =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : this.value.length;
                return this.value.slice(e, t);
              },
            },
            {
              key: "extractTail",
              value: function () {
                var e =
                    arguments.length > 0 && void 0 !== arguments[0]
                      ? arguments[0]
                      : 0,
                  t =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : this.value.length;
                return new Wo(this.extractInput(e, t), e);
              },
            },
            {
              key: "appendTail",
              value: function (e) {
                return Io(e) && (e = new Wo(String(e))), e.appendTo(this);
              },
            },
            {
              key: "_appendCharRaw",
              value: function (e) {
                return e
                  ? ((this._value += e),
                    new Ro({ inserted: e, rawInserted: e }))
                  : new Ro();
              },
            },
            {
              key: "_appendChar",
              value: function (e) {
                var t,
                  n =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : {},
                  i = arguments.length > 2 ? arguments[2] : void 0,
                  r = this.state,
                  s = Vo(this.doPrepare(e, n)),
                  a = Do(s, 2);
                if (
                  ((e = a[0]),
                  (t = (t = a[1]).aggregate(this._appendCharRaw(e, n)))
                    .inserted)
                ) {
                  var o,
                    l = !1 !== this.doValidate(n);
                  if (l && null != i) {
                    var c = this.state;
                    !0 === this.overwrite &&
                      ((o = i.state), i.unshift(this.value.length));
                    var u = this.appendTail(i);
                    ((l = u.rawInserted === i.toString()) && u.inserted) ||
                      "shift" !== this.overwrite ||
                      ((this.state = c),
                      (o = i.state),
                      i.shift(),
                      (l =
                        (u = this.appendTail(i)).rawInserted === i.toString())),
                      l && u.inserted && (this.state = c);
                  }
                  l ||
                    ((t = new Ro()), (this.state = r), i && o && (i.state = o));
                }
                return t;
              },
            },
            {
              key: "_appendPlaceholder",
              value: function () {
                return new Ro();
              },
            },
            {
              key: "_appendEager",
              value: function () {
                return new Ro();
              },
            },
            {
              key: "append",
              value: function (e, t, n) {
                if (!Io(e)) throw new Error("value should be string");
                var i = new Ro(),
                  r = Io(n) ? new Wo(String(n)) : n;
                t && t.tail && (t._beforeTailState = this.state);
                for (var s = 0; s < e.length; ++s)
                  i.aggregate(this._appendChar(e[s], t, r));
                return (
                  null != r && (i.tailShift += this.appendTail(r).tailShift),
                  this.eager &&
                    null != t &&
                    t.input &&
                    e &&
                    i.aggregate(this._appendEager()),
                  i
                );
              },
            },
            {
              key: "remove",
              value: function () {
                var e =
                    arguments.length > 0 && void 0 !== arguments[0]
                      ? arguments[0]
                      : 0,
                  t =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : this.value.length;
                return (
                  (this._value = this.value.slice(0, e) + this.value.slice(t)),
                  new Ro()
                );
              },
            },
            {
              key: "withValueRefresh",
              value: function (e) {
                if (this._refreshing || !this.isInitialized) return e();
                this._refreshing = !0;
                var t = this.rawInputValue,
                  n = this.value,
                  i = e();
                return (
                  (this.rawInputValue = t),
                  this.value &&
                    this.value !== n &&
                    0 === n.indexOf(this.value) &&
                    this.append(n.slice(this.value.length), {}, ""),
                  delete this._refreshing,
                  i
                );
              },
            },
            {
              key: "runIsolated",
              value: function (e) {
                if (this._isolated || !this.isInitialized) return e(this);
                this._isolated = !0;
                var t = this.state,
                  n = e(this);
                return (this.state = t), delete this._isolated, n;
              },
            },
            {
              key: "doPrepare",
              value: function (e) {
                var t =
                  arguments.length > 1 && void 0 !== arguments[1]
                    ? arguments[1]
                    : {};
                return this.prepare ? this.prepare(e, this, t) : e;
              },
            },
            {
              key: "doValidate",
              value: function (e) {
                return (
                  (!this.validate || this.validate(this.value, this, e)) &&
                  (!this.parent || this.parent.doValidate(e))
                );
              },
            },
            {
              key: "doCommit",
              value: function () {
                this.commit && this.commit(this.value, this);
              },
            },
            {
              key: "doFormat",
              value: function (e) {
                return this.format ? this.format(e, this) : e;
              },
            },
            {
              key: "doParse",
              value: function (e) {
                return this.parse ? this.parse(e, this) : e;
              },
            },
            {
              key: "splice",
              value: function (e, t, n, i) {
                var r,
                  s = e + t,
                  a = this.extractTail(s);
                this.eager &&
                  ((i = (function (e) {
                    switch (e) {
                      case Oo:
                        return No;
                      case zo:
                        return Bo;
                      default:
                        return e;
                    }
                  })(i)),
                  (r = this.extractInput(0, s, { raw: !0 })));
                var o = this.nearestInputPos(
                    e,
                    t > 1 && 0 !== e && !this.eager ? Fo : i
                  ),
                  l = new Ro({ tailShift: o - e }).aggregate(this.remove(o));
                if (this.eager && i !== Fo && r === this.rawInputValue)
                  if (i === No)
                    for (
                      var c;
                      r === this.rawInputValue && (c = this.value.length);

                    )
                      l.aggregate(new Ro({ tailShift: -1 })).aggregate(
                        this.remove(c - 1)
                      );
                  else i === Bo && a.unshift();
                return l.aggregate(this.append(n, { input: !0 }, a));
              },
            },
            {
              key: "maskEquals",
              value: function (e) {
                return this.mask === e;
              },
            },
          ]),
          e
        );
      })();
      function Xo(e) {
        if (null == e) throw new Error("mask property should be defined");
        return e instanceof RegExp
          ? jo.MaskedRegExp
          : Io(e)
          ? jo.MaskedPattern
          : e instanceof Date || e === Date
          ? jo.MaskedDate
          : e instanceof Number || "number" == typeof e || e === Number
          ? jo.MaskedNumber
          : Array.isArray(e) || e === Array
          ? jo.MaskedDynamic
          : jo.Masked && e.prototype instanceof jo.Masked
          ? e
          : e instanceof jo.Masked
          ? e.constructor
          : e instanceof Function
          ? jo.MaskedFunction
          : (console.warn("Mask not found for mask", e), jo.Masked);
      }
      function Yo(e) {
        if (jo.Masked && e instanceof jo.Masked) return e;
        var t = (e = Object.assign({}, e)).mask;
        if (jo.Masked && t instanceof jo.Masked) return t;
        var n = Xo(t);
        if (!n)
          throw new Error(
            "Masked class is not found for provided mask, appropriate module needs to be import manually before creating mask."
          );
        return new n(e);
      }
      (qo.DEFAULTS = {
        format: function (e) {
          return e;
        },
        parse: function (e) {
          return e;
        },
      }),
        (jo.Masked = qo),
        (jo.createMask = Yo);
      var Zo = ["mask"],
        $o = {
          0: /\d/,
          a: /[\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
          "*": /./,
        },
        Ko = (function () {
          function e(t) {
            _o(this, e);
            var n = t.mask,
              i = Mo(t, Zo);
            (this.masked = Yo({ mask: n })), Object.assign(this, i);
          }
          return (
            yo(e, [
              {
                key: "reset",
                value: function () {
                  (this.isFilled = !1), this.masked.reset();
                },
              },
              {
                key: "remove",
                value: function () {
                  var e =
                      arguments.length > 0 && void 0 !== arguments[0]
                        ? arguments[0]
                        : 0,
                    t =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : this.value.length;
                  return 0 === e && t >= 1
                    ? ((this.isFilled = !1), this.masked.remove(e, t))
                    : new Ro();
                },
              },
              {
                key: "value",
                get: function () {
                  return (
                    this.masked.value ||
                    (this.isFilled && !this.isOptional
                      ? this.placeholderChar
                      : "")
                  );
                },
              },
              {
                key: "unmaskedValue",
                get: function () {
                  return this.masked.unmaskedValue;
                },
              },
              {
                key: "isComplete",
                get: function () {
                  return Boolean(this.masked.value) || this.isOptional;
                },
              },
              {
                key: "_appendChar",
                value: function (e) {
                  var t =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : {};
                  if (this.isFilled) return new Ro();
                  var n = this.masked.state,
                    i = this.masked._appendChar(e, t);
                  return (
                    i.inserted &&
                      !1 === this.doValidate(t) &&
                      ((i.inserted = i.rawInserted = ""),
                      (this.masked.state = n)),
                    i.inserted ||
                      this.isOptional ||
                      this.lazy ||
                      t.input ||
                      (i.inserted = this.placeholderChar),
                    (i.skip = !i.inserted && !this.isOptional),
                    (this.isFilled = Boolean(i.inserted)),
                    i
                  );
                },
              },
              {
                key: "append",
                value: function () {
                  var e;
                  return (e = this.masked).append.apply(e, arguments);
                },
              },
              {
                key: "_appendPlaceholder",
                value: function () {
                  var e = new Ro();
                  return (
                    this.isFilled ||
                      this.isOptional ||
                      ((this.isFilled = !0),
                      (e.inserted = this.placeholderChar)),
                    e
                  );
                },
              },
              {
                key: "_appendEager",
                value: function () {
                  return new Ro();
                },
              },
              {
                key: "extractTail",
                value: function () {
                  var e;
                  return (e = this.masked).extractTail.apply(e, arguments);
                },
              },
              {
                key: "appendTail",
                value: function () {
                  var e;
                  return (e = this.masked).appendTail.apply(e, arguments);
                },
              },
              {
                key: "extractInput",
                value: function () {
                  var e =
                      arguments.length > 0 && void 0 !== arguments[0]
                        ? arguments[0]
                        : 0,
                    t =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : this.value.length,
                    n = arguments.length > 2 ? arguments[2] : void 0;
                  return this.masked.extractInput(e, t, n);
                },
              },
              {
                key: "nearestInputPos",
                value: function (e) {
                  var t =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : Fo,
                    n = 0,
                    i = this.value.length,
                    r = Math.min(Math.max(e, n), i);
                  switch (t) {
                    case Oo:
                    case No:
                      return this.isComplete ? r : n;
                    case zo:
                    case Bo:
                      return this.isComplete ? r : i;
                    default:
                      return r;
                  }
                },
              },
              {
                key: "doValidate",
                value: function () {
                  var e, t;
                  return (
                    (e = this.masked).doValidate.apply(e, arguments) &&
                    (!this.parent ||
                      (t = this.parent).doValidate.apply(t, arguments))
                  );
                },
              },
              {
                key: "doCommit",
                value: function () {
                  this.masked.doCommit();
                },
              },
              {
                key: "state",
                get: function () {
                  return { masked: this.masked.state, isFilled: this.isFilled };
                },
                set: function (e) {
                  (this.masked.state = e.masked), (this.isFilled = e.isFilled);
                },
              },
            ]),
            e
          );
        })(),
        Jo = (function () {
          function e(t) {
            _o(this, e),
              Object.assign(this, t),
              (this._value = ""),
              (this.isFixed = !0);
          }
          return (
            yo(e, [
              {
                key: "value",
                get: function () {
                  return this._value;
                },
              },
              {
                key: "unmaskedValue",
                get: function () {
                  return this.isUnmasking ? this.value : "";
                },
              },
              {
                key: "reset",
                value: function () {
                  (this._isRawInput = !1), (this._value = "");
                },
              },
              {
                key: "remove",
                value: function () {
                  var e =
                      arguments.length > 0 && void 0 !== arguments[0]
                        ? arguments[0]
                        : 0,
                    t =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : this._value.length;
                  return (
                    (this._value =
                      this._value.slice(0, e) + this._value.slice(t)),
                    this._value || (this._isRawInput = !1),
                    new Ro()
                  );
                },
              },
              {
                key: "nearestInputPos",
                value: function (e) {
                  var t =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : Fo,
                    n = 0,
                    i = this._value.length;
                  switch (t) {
                    case Oo:
                    case No:
                      return n;
                    default:
                      return i;
                  }
                },
              },
              {
                key: "extractInput",
                value: function () {
                  var e =
                      arguments.length > 0 && void 0 !== arguments[0]
                        ? arguments[0]
                        : 0,
                    t =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : this._value.length,
                    n =
                      arguments.length > 2 && void 0 !== arguments[2]
                        ? arguments[2]
                        : {};
                  return (
                    (n.raw && this._isRawInput && this._value.slice(e, t)) || ""
                  );
                },
              },
              {
                key: "isComplete",
                get: function () {
                  return !0;
                },
              },
              {
                key: "isFilled",
                get: function () {
                  return Boolean(this._value);
                },
              },
              {
                key: "_appendChar",
                value: function (e) {
                  var t =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : {},
                    n = new Ro();
                  if (this._value) return n;
                  var i = this.char === e,
                    r =
                      i &&
                      (this.isUnmasking || t.input || t.raw) &&
                      !this.eager &&
                      !t.tail;
                  return (
                    r && (n.rawInserted = this.char),
                    (this._value = n.inserted = this.char),
                    (this._isRawInput = r && (t.raw || t.input)),
                    n
                  );
                },
              },
              {
                key: "_appendEager",
                value: function () {
                  return this._appendChar(this.char);
                },
              },
              {
                key: "_appendPlaceholder",
                value: function () {
                  var e = new Ro();
                  return (
                    this._value || (this._value = e.inserted = this.char), e
                  );
                },
              },
              {
                key: "extractTail",
                value: function () {
                  return (
                    (arguments.length > 1 && void 0 !== arguments[1]) ||
                      this.value.length,
                    new Wo("")
                  );
                },
              },
              {
                key: "appendTail",
                value: function (e) {
                  return Io(e) && (e = new Wo(String(e))), e.appendTo(this);
                },
              },
              {
                key: "append",
                value: function (e, t, n) {
                  var i = this._appendChar(e[0], t);
                  return (
                    null != n && (i.tailShift += this.appendTail(n).tailShift),
                    i
                  );
                },
              },
              { key: "doCommit", value: function () {} },
              {
                key: "state",
                get: function () {
                  return { _value: this._value, _isRawInput: this._isRawInput };
                },
                set: function (e) {
                  Object.assign(this, e);
                },
              },
            ]),
            e
          );
        })(),
        Qo = ["chunks"],
        el = (function () {
          function e() {
            var t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : [],
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 0;
            _o(this, e), (this.chunks = t), (this.from = n);
          }
          return (
            yo(e, [
              {
                key: "toString",
                value: function () {
                  return this.chunks.map(String).join("");
                },
              },
              {
                key: "extend",
                value: function (t) {
                  if (String(t)) {
                    Io(t) && (t = new Wo(String(t)));
                    var n = this.chunks[this.chunks.length - 1],
                      i =
                        n &&
                        (n.stop === t.stop || null == t.stop) &&
                        t.from === n.from + n.toString().length;
                    if (t instanceof Wo)
                      i ? n.extend(t.toString()) : this.chunks.push(t);
                    else if (t instanceof e) {
                      if (null == t.stop)
                        for (
                          var r;
                          t.chunks.length && null == t.chunks[0].stop;

                        )
                          ((r = t.chunks.shift()).from += t.from),
                            this.extend(r);
                      t.toString() &&
                        ((t.stop = t.blockIndex), this.chunks.push(t));
                    }
                  }
                },
              },
              {
                key: "appendTo",
                value: function (t) {
                  if (!(t instanceof jo.MaskedPattern))
                    return new Wo(this.toString()).appendTo(t);
                  for (
                    var n = new Ro(), i = 0;
                    i < this.chunks.length && !n.skip;
                    ++i
                  ) {
                    var r = this.chunks[i],
                      s = t._mapPosToBlock(t.value.length),
                      a = r.stop,
                      o = void 0;
                    if (
                      (null != a &&
                        (!s || s.index <= a) &&
                        ((r instanceof e || t._stops.indexOf(a) >= 0) &&
                          n.aggregate(t._appendPlaceholder(a)),
                        (o = r instanceof e && t._blocks[a])),
                      o)
                    ) {
                      var l = o.appendTail(r);
                      (l.skip = !1), n.aggregate(l), (t._value += l.inserted);
                      var c = r.toString().slice(l.rawInserted.length);
                      c && n.aggregate(t.append(c, { tail: !0 }));
                    } else n.aggregate(t.append(r.toString(), { tail: !0 }));
                  }
                  return n;
                },
              },
              {
                key: "state",
                get: function () {
                  return {
                    chunks: this.chunks.map(function (e) {
                      return e.state;
                    }),
                    from: this.from,
                    stop: this.stop,
                    blockIndex: this.blockIndex,
                  };
                },
                set: function (t) {
                  var n = t.chunks,
                    i = Mo(t, Qo);
                  Object.assign(this, i),
                    (this.chunks = n.map(function (t) {
                      var n = "chunks" in t ? new e() : new Wo();
                      return (n.state = t), n;
                    }));
                },
              },
              {
                key: "unshift",
                value: function (e) {
                  if (!this.chunks.length || (null != e && this.from >= e))
                    return "";
                  for (
                    var t = null != e ? e - this.from : e, n = 0;
                    n < this.chunks.length;

                  ) {
                    var i = this.chunks[n],
                      r = i.unshift(t);
                    if (i.toString()) {
                      if (!r) break;
                      ++n;
                    } else this.chunks.splice(n, 1);
                    if (r) return r;
                  }
                  return "";
                },
              },
              {
                key: "shift",
                value: function () {
                  if (!this.chunks.length) return "";
                  for (var e = this.chunks.length - 1; 0 <= e; ) {
                    var t = this.chunks[e],
                      n = t.shift();
                    if (t.toString()) {
                      if (!n) break;
                      --e;
                    } else this.chunks.splice(e, 1);
                    if (n) return n;
                  }
                  return "";
                },
              },
            ]),
            e
          );
        })(),
        tl = (function () {
          function e(t, n) {
            _o(this, e), (this.masked = t), (this._log = []);
            var i =
                t._mapPosToBlock(n) ||
                (n < 0
                  ? { index: 0, offset: 0 }
                  : { index: this.masked._blocks.length, offset: 0 }),
              r = i.offset,
              s = i.index;
            (this.offset = r), (this.index = s), (this.ok = !1);
          }
          return (
            yo(e, [
              {
                key: "block",
                get: function () {
                  return this.masked._blocks[this.index];
                },
              },
              {
                key: "pos",
                get: function () {
                  return this.masked._blockStartPos(this.index) + this.offset;
                },
              },
              {
                key: "state",
                get: function () {
                  return {
                    index: this.index,
                    offset: this.offset,
                    ok: this.ok,
                  };
                },
                set: function (e) {
                  Object.assign(this, e);
                },
              },
              {
                key: "pushState",
                value: function () {
                  this._log.push(this.state);
                },
              },
              {
                key: "popState",
                value: function () {
                  var e = this._log.pop();
                  return (this.state = e), e;
                },
              },
              {
                key: "bindBlock",
                value: function () {
                  this.block ||
                    (this.index < 0 && ((this.index = 0), (this.offset = 0)),
                    this.index >= this.masked._blocks.length &&
                      ((this.index = this.masked._blocks.length - 1),
                      (this.offset = this.block.value.length)));
                },
              },
              {
                key: "_pushLeft",
                value: function (e) {
                  for (
                    this.pushState(), this.bindBlock();
                    0 <= this.index;
                    --this.index,
                      this.offset =
                        (null === (t = this.block) || void 0 === t
                          ? void 0
                          : t.value.length) || 0
                  ) {
                    var t;
                    if (e()) return (this.ok = !0);
                  }
                  return (this.ok = !1);
                },
              },
              {
                key: "_pushRight",
                value: function (e) {
                  for (
                    this.pushState(), this.bindBlock();
                    this.index < this.masked._blocks.length;
                    ++this.index, this.offset = 0
                  )
                    if (e()) return (this.ok = !0);
                  return (this.ok = !1);
                },
              },
              {
                key: "pushLeftBeforeFilled",
                value: function () {
                  var e = this;
                  return this._pushLeft(function () {
                    if (!e.block.isFixed && e.block.value)
                      return (
                        (e.offset = e.block.nearestInputPos(e.offset, No)),
                        0 !== e.offset || void 0
                      );
                  });
                },
              },
              {
                key: "pushLeftBeforeInput",
                value: function () {
                  var e = this;
                  return this._pushLeft(function () {
                    if (!e.block.isFixed)
                      return (
                        (e.offset = e.block.nearestInputPos(e.offset, Oo)), !0
                      );
                  });
                },
              },
              {
                key: "pushLeftBeforeRequired",
                value: function () {
                  var e = this;
                  return this._pushLeft(function () {
                    if (
                      !(
                        e.block.isFixed ||
                        (e.block.isOptional && !e.block.value)
                      )
                    )
                      return (
                        (e.offset = e.block.nearestInputPos(e.offset, Oo)), !0
                      );
                  });
                },
              },
              {
                key: "pushRightBeforeFilled",
                value: function () {
                  var e = this;
                  return this._pushRight(function () {
                    if (!e.block.isFixed && e.block.value)
                      return (
                        (e.offset = e.block.nearestInputPos(e.offset, Bo)),
                        e.offset !== e.block.value.length || void 0
                      );
                  });
                },
              },
              {
                key: "pushRightBeforeInput",
                value: function () {
                  var e = this;
                  return this._pushRight(function () {
                    if (!e.block.isFixed)
                      return (
                        (e.offset = e.block.nearestInputPos(e.offset, Fo)), !0
                      );
                  });
                },
              },
              {
                key: "pushRightBeforeRequired",
                value: function () {
                  var e = this;
                  return this._pushRight(function () {
                    if (
                      !(
                        e.block.isFixed ||
                        (e.block.isOptional && !e.block.value)
                      )
                    )
                      return (
                        (e.offset = e.block.nearestInputPos(e.offset, Fo)), !0
                      );
                  });
                },
              },
            ]),
            e
          );
        })(),
        nl = (function (e) {
          bo(n, e);
          var t = To(n);
          function n() {
            return _o(this, n), t.apply(this, arguments);
          }
          return (
            yo(n, [
              {
                key: "_update",
                value: function (e) {
                  e.mask &&
                    (e.validate = function (t) {
                      return t.search(e.mask) >= 0;
                    }),
                    Co(wo(n.prototype), "_update", this).call(this, e);
                },
              },
            ]),
            n
          );
        })(qo);
      jo.MaskedRegExp = nl;
      var il = ["_blocks"],
        rl = (function (e) {
          bo(n, e);
          var t = To(n);
          function n() {
            var e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : {};
            return (
              _o(this, n),
              (e.definitions = Object.assign({}, $o, e.definitions)),
              t.call(this, Object.assign({}, n.DEFAULTS, e))
            );
          }
          return (
            yo(n, [
              {
                key: "_update",
                value: function () {
                  var e =
                    arguments.length > 0 && void 0 !== arguments[0]
                      ? arguments[0]
                      : {};
                  (e.definitions = Object.assign(
                    {},
                    this.definitions,
                    e.definitions
                  )),
                    Co(wo(n.prototype), "_update", this).call(this, e),
                    this._rebuildMask();
                },
              },
              {
                key: "_rebuildMask",
                value: function () {
                  var e = this,
                    t = this.definitions;
                  (this._blocks = []),
                    (this._stops = []),
                    (this._maskedBlocks = {});
                  var i = this.mask;
                  if (i && t)
                    for (var r = !1, s = !1, a = 0; a < i.length; ++a)
                      if (
                        !this.blocks ||
                        "continue" !==
                          (function () {
                            var t = i.slice(a),
                              n = Object.keys(e.blocks).filter(function (e) {
                                return 0 === t.indexOf(e);
                              });
                            n.sort(function (e, t) {
                              return t.length - e.length;
                            });
                            var r = n[0];
                            if (r) {
                              var s = Yo(
                                Object.assign(
                                  {
                                    parent: e,
                                    lazy: e.lazy,
                                    eager: e.eager,
                                    placeholderChar: e.placeholderChar,
                                    overwrite: e.overwrite,
                                  },
                                  e.blocks[r]
                                )
                              );
                              return (
                                s &&
                                  (e._blocks.push(s),
                                  e._maskedBlocks[r] ||
                                    (e._maskedBlocks[r] = []),
                                  e._maskedBlocks[r].push(
                                    e._blocks.length - 1
                                  )),
                                (a += r.length - 1),
                                "continue"
                              );
                            }
                          })()
                      ) {
                        var o = i[a],
                          l = o in t;
                        if (o !== n.STOP_CHAR)
                          if ("{" !== o && "}" !== o)
                            if ("[" !== o && "]" !== o) {
                              if (o === n.ESCAPE_CHAR) {
                                if ((++a, !(o = i[a]))) break;
                                l = !1;
                              }
                              var c = l
                                ? new Ko({
                                    parent: this,
                                    lazy: this.lazy,
                                    eager: this.eager,
                                    placeholderChar: this.placeholderChar,
                                    mask: t[o],
                                    isOptional: s,
                                  })
                                : new Jo({
                                    char: o,
                                    eager: this.eager,
                                    isUnmasking: r,
                                  });
                              this._blocks.push(c);
                            } else s = !s;
                          else r = !r;
                        else this._stops.push(this._blocks.length);
                      }
                },
              },
              {
                key: "state",
                get: function () {
                  return Object.assign({}, Co(wo(n.prototype), "state", this), {
                    _blocks: this._blocks.map(function (e) {
                      return e.state;
                    }),
                  });
                },
                set: function (e) {
                  var t = e._blocks,
                    i = Mo(e, il);
                  this._blocks.forEach(function (e, n) {
                    return (e.state = t[n]);
                  }),
                    Po(wo(n.prototype), "state", i, this, !0);
                },
              },
              {
                key: "reset",
                value: function () {
                  Co(wo(n.prototype), "reset", this).call(this),
                    this._blocks.forEach(function (e) {
                      return e.reset();
                    });
                },
              },
              {
                key: "isComplete",
                get: function () {
                  return this._blocks.every(function (e) {
                    return e.isComplete;
                  });
                },
              },
              {
                key: "isFilled",
                get: function () {
                  return this._blocks.every(function (e) {
                    return e.isFilled;
                  });
                },
              },
              {
                key: "isFixed",
                get: function () {
                  return this._blocks.every(function (e) {
                    return e.isFixed;
                  });
                },
              },
              {
                key: "isOptional",
                get: function () {
                  return this._blocks.every(function (e) {
                    return e.isOptional;
                  });
                },
              },
              {
                key: "doCommit",
                value: function () {
                  this._blocks.forEach(function (e) {
                    return e.doCommit();
                  }),
                    Co(wo(n.prototype), "doCommit", this).call(this);
                },
              },
              {
                key: "unmaskedValue",
                get: function () {
                  return this._blocks.reduce(function (e, t) {
                    return e + t.unmaskedValue;
                  }, "");
                },
                set: function (e) {
                  Po(wo(n.prototype), "unmaskedValue", e, this, !0);
                },
              },
              {
                key: "value",
                get: function () {
                  return this._blocks.reduce(function (e, t) {
                    return e + t.value;
                  }, "");
                },
                set: function (e) {
                  Po(wo(n.prototype), "value", e, this, !0);
                },
              },
              {
                key: "appendTail",
                value: function (e) {
                  return Co(wo(n.prototype), "appendTail", this)
                    .call(this, e)
                    .aggregate(this._appendPlaceholder());
                },
              },
              {
                key: "_appendEager",
                value: function () {
                  var e,
                    t = new Ro(),
                    n =
                      null === (e = this._mapPosToBlock(this.value.length)) ||
                      void 0 === e
                        ? void 0
                        : e.index;
                  if (null == n) return t;
                  this._blocks[n].isFilled && ++n;
                  for (var i = n; i < this._blocks.length; ++i) {
                    var r = this._blocks[i]._appendEager();
                    if (!r.inserted) break;
                    t.aggregate(r);
                  }
                  return t;
                },
              },
              {
                key: "_appendCharRaw",
                value: function (e) {
                  var t =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : {},
                    n = this._mapPosToBlock(this.value.length),
                    i = new Ro();
                  if (!n) return i;
                  for (var r = n.index; ; ++r) {
                    var s,
                      a = this._blocks[r];
                    if (!a) break;
                    var o = a._appendChar(
                        e,
                        Object.assign({}, t, {
                          _beforeTailState:
                            null === (s = t._beforeTailState) || void 0 === s
                              ? void 0
                              : s._blocks[r],
                        })
                      ),
                      l = o.skip;
                    if ((i.aggregate(o), l || o.rawInserted)) break;
                  }
                  return i;
                },
              },
              {
                key: "extractTail",
                value: function () {
                  var e = this,
                    t =
                      arguments.length > 0 && void 0 !== arguments[0]
                        ? arguments[0]
                        : 0,
                    n =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : this.value.length,
                    i = new el();
                  return (
                    t === n ||
                      this._forEachBlocksInRange(t, n, function (t, n, r, s) {
                        var a = t.extractTail(r, s);
                        (a.stop = e._findStopBefore(n)),
                          (a.from = e._blockStartPos(n)),
                          a instanceof el && (a.blockIndex = n),
                          i.extend(a);
                      }),
                    i
                  );
                },
              },
              {
                key: "extractInput",
                value: function () {
                  var e =
                      arguments.length > 0 && void 0 !== arguments[0]
                        ? arguments[0]
                        : 0,
                    t =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : this.value.length,
                    n =
                      arguments.length > 2 && void 0 !== arguments[2]
                        ? arguments[2]
                        : {};
                  if (e === t) return "";
                  var i = "";
                  return (
                    this._forEachBlocksInRange(e, t, function (e, t, r, s) {
                      i += e.extractInput(r, s, n);
                    }),
                    i
                  );
                },
              },
              {
                key: "_findStopBefore",
                value: function (e) {
                  for (var t, n = 0; n < this._stops.length; ++n) {
                    var i = this._stops[n];
                    if (!(i <= e)) break;
                    t = i;
                  }
                  return t;
                },
              },
              {
                key: "_appendPlaceholder",
                value: function (e) {
                  var t = this,
                    n = new Ro();
                  if (this.lazy && null == e) return n;
                  var i = this._mapPosToBlock(this.value.length);
                  if (!i) return n;
                  var r = i.index,
                    s = null != e ? e : this._blocks.length;
                  return (
                    this._blocks.slice(r, s).forEach(function (i) {
                      if (!i.lazy || null != e) {
                        var r = null != i._blocks ? [i._blocks.length] : [],
                          s = i._appendPlaceholder.apply(i, r);
                        (t._value += s.inserted), n.aggregate(s);
                      }
                    }),
                    n
                  );
                },
              },
              {
                key: "_mapPosToBlock",
                value: function (e) {
                  for (var t = "", n = 0; n < this._blocks.length; ++n) {
                    var i = this._blocks[n],
                      r = t.length;
                    if (e <= (t += i.value).length)
                      return { index: n, offset: e - r };
                  }
                },
              },
              {
                key: "_blockStartPos",
                value: function (e) {
                  return this._blocks.slice(0, e).reduce(function (e, t) {
                    return e + t.value.length;
                  }, 0);
                },
              },
              {
                key: "_forEachBlocksInRange",
                value: function (e) {
                  var t =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : this.value.length,
                    n = arguments.length > 2 ? arguments[2] : void 0,
                    i = this._mapPosToBlock(e);
                  if (i) {
                    var r = this._mapPosToBlock(t),
                      s = r && i.index === r.index,
                      a = i.offset,
                      o =
                        r && s ? r.offset : this._blocks[i.index].value.length;
                    if ((n(this._blocks[i.index], i.index, a, o), r && !s)) {
                      for (var l = i.index + 1; l < r.index; ++l)
                        n(this._blocks[l], l, 0, this._blocks[l].value.length);
                      n(this._blocks[r.index], r.index, 0, r.offset);
                    }
                  }
                },
              },
              {
                key: "remove",
                value: function () {
                  var e =
                      arguments.length > 0 && void 0 !== arguments[0]
                        ? arguments[0]
                        : 0,
                    t =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : this.value.length,
                    i = Co(wo(n.prototype), "remove", this).call(this, e, t);
                  return (
                    this._forEachBlocksInRange(e, t, function (e, t, n, r) {
                      i.aggregate(e.remove(n, r));
                    }),
                    i
                  );
                },
              },
              {
                key: "nearestInputPos",
                value: function (e) {
                  var t =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : Fo;
                  if (!this._blocks.length) return 0;
                  var n = new tl(this, e);
                  if (t === Fo)
                    return n.pushRightBeforeInput()
                      ? n.pos
                      : (n.popState(),
                        n.pushLeftBeforeInput() ? n.pos : this.value.length);
                  if (t === Oo || t === No) {
                    if (t === Oo) {
                      if ((n.pushRightBeforeFilled(), n.ok && n.pos === e))
                        return e;
                      n.popState();
                    }
                    if (
                      (n.pushLeftBeforeInput(),
                      n.pushLeftBeforeRequired(),
                      n.pushLeftBeforeFilled(),
                      t === Oo)
                    ) {
                      if (
                        (n.pushRightBeforeInput(),
                        n.pushRightBeforeRequired(),
                        n.ok && n.pos <= e)
                      )
                        return n.pos;
                      if ((n.popState(), n.ok && n.pos <= e)) return n.pos;
                      n.popState();
                    }
                    return n.ok
                      ? n.pos
                      : t === No
                      ? 0
                      : (n.popState(),
                        n.ok ? n.pos : (n.popState(), n.ok ? n.pos : 0));
                  }
                  return t === zo || t === Bo
                    ? (n.pushRightBeforeInput(),
                      n.pushRightBeforeRequired(),
                      n.pushRightBeforeFilled()
                        ? n.pos
                        : t === Bo
                        ? this.value.length
                        : (n.popState(),
                          n.ok
                            ? n.pos
                            : (n.popState(),
                              n.ok ? n.pos : this.nearestInputPos(e, Oo))))
                    : e;
                },
              },
              {
                key: "maskedBlock",
                value: function (e) {
                  return this.maskedBlocks(e)[0];
                },
              },
              {
                key: "maskedBlocks",
                value: function (e) {
                  var t = this,
                    n = this._maskedBlocks[e];
                  return n
                    ? n.map(function (e) {
                        return t._blocks[e];
                      })
                    : [];
                },
              },
            ]),
            n
          );
        })(qo);
      (rl.DEFAULTS = { lazy: !0, placeholderChar: "_" }),
        (rl.STOP_CHAR = "`"),
        (rl.ESCAPE_CHAR = "\\"),
        (rl.InputDefinition = Ko),
        (rl.FixedDefinition = Jo),
        (jo.MaskedPattern = rl);
      var sl = (function (e) {
        bo(n, e);
        var t = To(n);
        function n() {
          return _o(this, n), t.apply(this, arguments);
        }
        return (
          yo(n, [
            {
              key: "_matchFrom",
              get: function () {
                return this.maxLength - String(this.from).length;
              },
            },
            {
              key: "_update",
              value: function (e) {
                e = Object.assign(
                  {
                    to: this.to || 0,
                    from: this.from || 0,
                    maxLength: this.maxLength || 0,
                  },
                  e
                );
                var t = String(e.to).length;
                null != e.maxLength && (t = Math.max(t, e.maxLength)),
                  (e.maxLength = t);
                for (
                  var i = String(e.from).padStart(t, "0"),
                    r = String(e.to).padStart(t, "0"),
                    s = 0;
                  s < r.length && r[s] === i[s];

                )
                  ++s;
                (e.mask =
                  r.slice(0, s).replace(/0/g, "\\0") + "0".repeat(t - s)),
                  Co(wo(n.prototype), "_update", this).call(this, e);
              },
            },
            {
              key: "isComplete",
              get: function () {
                return (
                  Co(wo(n.prototype), "isComplete", this) && Boolean(this.value)
                );
              },
            },
            {
              key: "boundaries",
              value: function (e) {
                var t = "",
                  n = "",
                  i = Do(e.match(/^(\D*)(\d*)(\D*)/) || [], 3),
                  r = i[1],
                  s = i[2];
                return (
                  s &&
                    ((t = "0".repeat(r.length) + s),
                    (n = "9".repeat(r.length) + s)),
                  [
                    (t = t.padEnd(this.maxLength, "0")),
                    (n = n.padEnd(this.maxLength, "9")),
                  ]
                );
              },
            },
            {
              key: "doPrepare",
              value: function (e) {
                var t,
                  i =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : {},
                  r = Vo(
                    Co(wo(n.prototype), "doPrepare", this).call(
                      this,
                      e.replace(/\D/g, ""),
                      i
                    )
                  ),
                  s = Do(r, 2);
                if (((e = s[0]), (t = s[1]), !this.autofix || !e)) return e;
                var a = String(this.from).padStart(this.maxLength, "0"),
                  o = String(this.to).padStart(this.maxLength, "0"),
                  l = this.value + e;
                if (l.length > this.maxLength) return "";
                var c = this.boundaries(l),
                  u = Do(c, 2),
                  h = u[0],
                  d = u[1];
                return Number(d) < this.from
                  ? a[l.length - 1]
                  : Number(h) > this.to
                  ? "pad" === this.autofix && l.length < this.maxLength
                    ? ["", t.aggregate(this.append(a[l.length - 1] + e, i))]
                    : o[l.length - 1]
                  : e;
              },
            },
            {
              key: "doValidate",
              value: function () {
                var e,
                  t = this.value,
                  i = t.search(/[^0]/);
                if (-1 === i && t.length <= this._matchFrom) return !0;
                for (
                  var r = this.boundaries(t),
                    s = Do(r, 2),
                    a = s[0],
                    o = s[1],
                    l = arguments.length,
                    c = new Array(l),
                    u = 0;
                  u < l;
                  u++
                )
                  c[u] = arguments[u];
                return (
                  this.from <= Number(o) &&
                  Number(a) <= this.to &&
                  (e = Co(wo(n.prototype), "doValidate", this)).call.apply(
                    e,
                    [this].concat(c)
                  )
                );
              },
            },
          ]),
          n
        );
      })(rl);
      jo.MaskedRange = sl;
      var al = (function (e) {
        bo(n, e);
        var t = To(n);
        function n(e) {
          return _o(this, n), t.call(this, Object.assign({}, n.DEFAULTS, e));
        }
        return (
          yo(n, [
            {
              key: "_update",
              value: function (e) {
                e.mask === Date && delete e.mask,
                  e.pattern && (e.mask = e.pattern);
                var t = e.blocks;
                (e.blocks = Object.assign({}, n.GET_DEFAULT_BLOCKS())),
                  e.min && (e.blocks.Y.from = e.min.getFullYear()),
                  e.max && (e.blocks.Y.to = e.max.getFullYear()),
                  e.min &&
                    e.max &&
                    e.blocks.Y.from === e.blocks.Y.to &&
                    ((e.blocks.m.from = e.min.getMonth() + 1),
                    (e.blocks.m.to = e.max.getMonth() + 1),
                    e.blocks.m.from === e.blocks.m.to &&
                      ((e.blocks.d.from = e.min.getDate()),
                      (e.blocks.d.to = e.max.getDate()))),
                  Object.assign(e.blocks, this.blocks, t),
                  Object.keys(e.blocks).forEach(function (t) {
                    var n = e.blocks[t];
                    !("autofix" in n) &&
                      "autofix" in e &&
                      (n.autofix = e.autofix);
                  }),
                  Co(wo(n.prototype), "_update", this).call(this, e);
              },
            },
            {
              key: "doValidate",
              value: function () {
                for (
                  var e,
                    t = this.date,
                    i = arguments.length,
                    r = new Array(i),
                    s = 0;
                  s < i;
                  s++
                )
                  r[s] = arguments[s];
                return (
                  (e = Co(wo(n.prototype), "doValidate", this)).call.apply(
                    e,
                    [this].concat(r)
                  ) &&
                  (!this.isComplete ||
                    (this.isDateExist(this.value) &&
                      null != t &&
                      (null == this.min || this.min <= t) &&
                      (null == this.max || t <= this.max)))
                );
              },
            },
            {
              key: "isDateExist",
              value: function (e) {
                return this.format(this.parse(e, this), this).indexOf(e) >= 0;
              },
            },
            {
              key: "date",
              get: function () {
                return this.typedValue;
              },
              set: function (e) {
                this.typedValue = e;
              },
            },
            {
              key: "typedValue",
              get: function () {
                return this.isComplete
                  ? Co(wo(n.prototype), "typedValue", this)
                  : null;
              },
              set: function (e) {
                Po(wo(n.prototype), "typedValue", e, this, !0);
              },
            },
            {
              key: "maskEquals",
              value: function (e) {
                return (
                  e === Date ||
                  Co(wo(n.prototype), "maskEquals", this).call(this, e)
                );
              },
            },
          ]),
          n
        );
      })(rl);
      (al.DEFAULTS = {
        pattern: "d{.}`m{.}`Y",
        format: function (e) {
          return e
            ? [
                String(e.getDate()).padStart(2, "0"),
                String(e.getMonth() + 1).padStart(2, "0"),
                e.getFullYear(),
              ].join(".")
            : "";
        },
        parse: function (e) {
          var t = Do(e.split("."), 3),
            n = t[0],
            i = t[1],
            r = t[2];
          return new Date(r, i - 1, n);
        },
      }),
        (al.GET_DEFAULT_BLOCKS = function () {
          return {
            d: { mask: sl, from: 1, to: 31, maxLength: 2 },
            m: { mask: sl, from: 1, to: 12, maxLength: 2 },
            Y: { mask: sl, from: 1900, to: 9999 },
          };
        }),
        (jo.MaskedDate = al);
      var ol = (function () {
        function e() {
          _o(this, e);
        }
        return (
          yo(e, [
            {
              key: "selectionStart",
              get: function () {
                var e;
                try {
                  e = this._unsafeSelectionStart;
                } catch (e) {}
                return null != e ? e : this.value.length;
              },
            },
            {
              key: "selectionEnd",
              get: function () {
                var e;
                try {
                  e = this._unsafeSelectionEnd;
                } catch (e) {}
                return null != e ? e : this.value.length;
              },
            },
            {
              key: "select",
              value: function (e, t) {
                if (
                  null != e &&
                  null != t &&
                  (e !== this.selectionStart || t !== this.selectionEnd)
                )
                  try {
                    this._unsafeSelect(e, t);
                  } catch (e) {}
              },
            },
            { key: "_unsafeSelect", value: function (e, t) {} },
            {
              key: "isActive",
              get: function () {
                return !1;
              },
            },
            { key: "bindEvents", value: function (e) {} },
            { key: "unbindEvents", value: function () {} },
          ]),
          e
        );
      })();
      jo.MaskElement = ol;
      var ll = (function (e) {
        bo(n, e);
        var t = To(n);
        function n(e) {
          var i;
          return (
            _o(this, n), ((i = t.call(this)).input = e), (i._handlers = {}), i
          );
        }
        return (
          yo(n, [
            {
              key: "rootElement",
              get: function () {
                var e, t, n;
                return null !==
                  (e =
                    null === (t = (n = this.input).getRootNode) || void 0 === t
                      ? void 0
                      : t.call(n)) && void 0 !== e
                  ? e
                  : document;
              },
            },
            {
              key: "isActive",
              get: function () {
                return this.input === this.rootElement.activeElement;
              },
            },
            {
              key: "_unsafeSelectionStart",
              get: function () {
                return this.input.selectionStart;
              },
            },
            {
              key: "_unsafeSelectionEnd",
              get: function () {
                return this.input.selectionEnd;
              },
            },
            {
              key: "_unsafeSelect",
              value: function (e, t) {
                this.input.setSelectionRange(e, t);
              },
            },
            {
              key: "value",
              get: function () {
                return this.input.value;
              },
              set: function (e) {
                this.input.value = e;
              },
            },
            {
              key: "bindEvents",
              value: function (e) {
                var t = this;
                Object.keys(e).forEach(function (i) {
                  return t._toggleEventHandler(n.EVENTS_MAP[i], e[i]);
                });
              },
            },
            {
              key: "unbindEvents",
              value: function () {
                var e = this;
                Object.keys(this._handlers).forEach(function (t) {
                  return e._toggleEventHandler(t);
                });
              },
            },
            {
              key: "_toggleEventHandler",
              value: function (e, t) {
                this._handlers[e] &&
                  (this.input.removeEventListener(e, this._handlers[e]),
                  delete this._handlers[e]),
                  t &&
                    (this.input.addEventListener(e, t),
                    (this._handlers[e] = t));
              },
            },
          ]),
          n
        );
      })(ol);
      (ll.EVENTS_MAP = {
        selectionChange: "keydown",
        input: "input",
        drop: "drop",
        click: "click",
        focus: "focus",
        commit: "blur",
      }),
        (jo.HTMLMaskElement = ll);
      var cl = (function (e) {
        bo(n, e);
        var t = To(n);
        function n() {
          return _o(this, n), t.apply(this, arguments);
        }
        return (
          yo(n, [
            {
              key: "_unsafeSelectionStart",
              get: function () {
                var e = this.rootElement,
                  t = e.getSelection && e.getSelection(),
                  n = t && t.anchorOffset,
                  i = t && t.focusOffset;
                return null == i || null == n || n < i ? n : i;
              },
            },
            {
              key: "_unsafeSelectionEnd",
              get: function () {
                var e = this.rootElement,
                  t = e.getSelection && e.getSelection(),
                  n = t && t.anchorOffset,
                  i = t && t.focusOffset;
                return null == i || null == n || n > i ? n : i;
              },
            },
            {
              key: "_unsafeSelect",
              value: function (e, t) {
                if (this.rootElement.createRange) {
                  var n = this.rootElement.createRange();
                  n.setStart(this.input.firstChild || this.input, e),
                    n.setEnd(this.input.lastChild || this.input, t);
                  var i = this.rootElement,
                    r = i.getSelection && i.getSelection();
                  r && (r.removeAllRanges(), r.addRange(n));
                }
              },
            },
            {
              key: "value",
              get: function () {
                return this.input.textContent;
              },
              set: function (e) {
                this.input.textContent = e;
              },
            },
          ]),
          n
        );
      })(ll);
      jo.HTMLContenteditableMaskElement = cl;
      var ul = ["mask"],
        hl = (function () {
          function e(t, n) {
            _o(this, e),
              (this.el =
                t instanceof ol
                  ? t
                  : t.isContentEditable &&
                    "INPUT" !== t.tagName &&
                    "TEXTAREA" !== t.tagName
                  ? new cl(t)
                  : new ll(t)),
              (this.masked = Yo(n)),
              (this._listeners = {}),
              (this._value = ""),
              (this._unmaskedValue = ""),
              (this._saveSelection = this._saveSelection.bind(this)),
              (this._onInput = this._onInput.bind(this)),
              (this._onChange = this._onChange.bind(this)),
              (this._onDrop = this._onDrop.bind(this)),
              (this._onFocus = this._onFocus.bind(this)),
              (this._onClick = this._onClick.bind(this)),
              (this.alignCursor = this.alignCursor.bind(this)),
              (this.alignCursorFriendly = this.alignCursorFriendly.bind(this)),
              this._bindEvents(),
              this.updateValue(),
              this._onChange();
          }
          return (
            yo(e, [
              {
                key: "mask",
                get: function () {
                  return this.masked.mask;
                },
                set: function (e) {
                  if (!this.maskEquals(e))
                    if (
                      e instanceof jo.Masked ||
                      this.masked.constructor !== Xo(e)
                    ) {
                      var t = Yo({ mask: e });
                      (t.unmaskedValue = this.masked.unmaskedValue),
                        (this.masked = t);
                    } else this.masked.updateOptions({ mask: e });
                },
              },
              {
                key: "maskEquals",
                value: function (e) {
                  var t;
                  return (
                    null == e ||
                    (null === (t = this.masked) || void 0 === t
                      ? void 0
                      : t.maskEquals(e))
                  );
                },
              },
              {
                key: "value",
                get: function () {
                  return this._value;
                },
                set: function (e) {
                  (this.masked.value = e),
                    this.updateControl(),
                    this.alignCursor();
                },
              },
              {
                key: "unmaskedValue",
                get: function () {
                  return this._unmaskedValue;
                },
                set: function (e) {
                  (this.masked.unmaskedValue = e),
                    this.updateControl(),
                    this.alignCursor();
                },
              },
              {
                key: "typedValue",
                get: function () {
                  return this.masked.typedValue;
                },
                set: function (e) {
                  (this.masked.typedValue = e),
                    this.updateControl(),
                    this.alignCursor();
                },
              },
              {
                key: "_bindEvents",
                value: function () {
                  this.el.bindEvents({
                    selectionChange: this._saveSelection,
                    input: this._onInput,
                    drop: this._onDrop,
                    click: this._onClick,
                    focus: this._onFocus,
                    commit: this._onChange,
                  });
                },
              },
              {
                key: "_unbindEvents",
                value: function () {
                  this.el && this.el.unbindEvents();
                },
              },
              {
                key: "_fireEvent",
                value: function (e) {
                  for (
                    var t = arguments.length,
                      n = new Array(t > 1 ? t - 1 : 0),
                      i = 1;
                    i < t;
                    i++
                  )
                    n[i - 1] = arguments[i];
                  var r = this._listeners[e];
                  r &&
                    r.forEach(function (e) {
                      return e.apply(void 0, n);
                    });
                },
              },
              {
                key: "selectionStart",
                get: function () {
                  return this._cursorChanging
                    ? this._changingCursorPos
                    : this.el.selectionStart;
                },
              },
              {
                key: "cursorPos",
                get: function () {
                  return this._cursorChanging
                    ? this._changingCursorPos
                    : this.el.selectionEnd;
                },
                set: function (e) {
                  this.el &&
                    this.el.isActive &&
                    (this.el.select(e, e), this._saveSelection());
                },
              },
              {
                key: "_saveSelection",
                value: function () {
                  this.value !== this.el.value &&
                    console.warn(
                      "Element value was changed outside of mask. Syncronize mask using `mask.updateValue()` to work properly."
                    ),
                    (this._selection = {
                      start: this.selectionStart,
                      end: this.cursorPos,
                    });
                },
              },
              {
                key: "updateValue",
                value: function () {
                  (this.masked.value = this.el.value),
                    (this._value = this.masked.value);
                },
              },
              {
                key: "updateControl",
                value: function () {
                  var e = this.masked.unmaskedValue,
                    t = this.masked.value,
                    n = this.unmaskedValue !== e || this.value !== t;
                  (this._unmaskedValue = e),
                    (this._value = t),
                    this.el.value !== t && (this.el.value = t),
                    n && this._fireChangeEvents();
                },
              },
              {
                key: "updateOptions",
                value: function (e) {
                  var t = e.mask,
                    n = Mo(e, ul),
                    i = !this.maskEquals(t),
                    r = !Go(this.masked, n);
                  i && (this.mask = t),
                    r && this.masked.updateOptions(n),
                    (i || r) && this.updateControl();
                },
              },
              {
                key: "updateCursor",
                value: function (e) {
                  null != e &&
                    ((this.cursorPos = e), this._delayUpdateCursor(e));
                },
              },
              {
                key: "_delayUpdateCursor",
                value: function (e) {
                  var t = this;
                  this._abortUpdateCursor(),
                    (this._changingCursorPos = e),
                    (this._cursorChanging = setTimeout(function () {
                      t.el &&
                        ((t.cursorPos = t._changingCursorPos),
                        t._abortUpdateCursor());
                    }, 10));
                },
              },
              {
                key: "_fireChangeEvents",
                value: function () {
                  this._fireEvent("accept", this._inputEvent),
                    this.masked.isComplete &&
                      this._fireEvent("complete", this._inputEvent);
                },
              },
              {
                key: "_abortUpdateCursor",
                value: function () {
                  this._cursorChanging &&
                    (clearTimeout(this._cursorChanging),
                    delete this._cursorChanging);
                },
              },
              {
                key: "alignCursor",
                value: function () {
                  this.cursorPos = this.masked.nearestInputPos(
                    this.masked.nearestInputPos(this.cursorPos, Oo)
                  );
                },
              },
              {
                key: "alignCursorFriendly",
                value: function () {
                  this.selectionStart === this.cursorPos && this.alignCursor();
                },
              },
              {
                key: "on",
                value: function (e, t) {
                  return (
                    this._listeners[e] || (this._listeners[e] = []),
                    this._listeners[e].push(t),
                    this
                  );
                },
              },
              {
                key: "off",
                value: function (e, t) {
                  if (!this._listeners[e]) return this;
                  if (!t) return delete this._listeners[e], this;
                  var n = this._listeners[e].indexOf(t);
                  return n >= 0 && this._listeners[e].splice(n, 1), this;
                },
              },
              {
                key: "_onInput",
                value: function (e) {
                  if (
                    ((this._inputEvent = e),
                    this._abortUpdateCursor(),
                    !this._selection)
                  )
                    return this.updateValue();
                  var t = new Ho(
                      this.el.value,
                      this.cursorPos,
                      this.value,
                      this._selection
                    ),
                    n = this.masked.rawInputValue,
                    i = this.masked.splice(
                      t.startChangePos,
                      t.removed.length,
                      t.inserted,
                      t.removeDirection
                    ).offset,
                    r =
                      n === this.masked.rawInputValue ? t.removeDirection : Fo,
                    s = this.masked.nearestInputPos(t.startChangePos + i, r);
                  r !== Fo && (s = this.masked.nearestInputPos(s, Fo)),
                    this.updateControl(),
                    this.updateCursor(s),
                    delete this._inputEvent;
                },
              },
              {
                key: "_onChange",
                value: function () {
                  this.value !== this.el.value && this.updateValue(),
                    this.masked.doCommit(),
                    this.updateControl(),
                    this._saveSelection();
                },
              },
              {
                key: "_onDrop",
                value: function (e) {
                  e.preventDefault(), e.stopPropagation();
                },
              },
              {
                key: "_onFocus",
                value: function (e) {
                  this.alignCursorFriendly();
                },
              },
              {
                key: "_onClick",
                value: function (e) {
                  this.alignCursorFriendly();
                },
              },
              {
                key: "destroy",
                value: function () {
                  this._unbindEvents(),
                    (this._listeners.length = 0),
                    delete this.el;
                },
              },
            ]),
            e
          );
        })();
      jo.InputMask = hl;
      var dl = (function (e) {
        bo(n, e);
        var t = To(n);
        function n() {
          return _o(this, n), t.apply(this, arguments);
        }
        return (
          yo(n, [
            {
              key: "_update",
              value: function (e) {
                e.enum && (e.mask = "*".repeat(e.enum[0].length)),
                  Co(wo(n.prototype), "_update", this).call(this, e);
              },
            },
            {
              key: "doValidate",
              value: function () {
                for (
                  var e,
                    t = this,
                    i = arguments.length,
                    r = new Array(i),
                    s = 0;
                  s < i;
                  s++
                )
                  r[s] = arguments[s];
                return (
                  this.enum.some(function (e) {
                    return e.indexOf(t.unmaskedValue) >= 0;
                  }) &&
                  (e = Co(wo(n.prototype), "doValidate", this)).call.apply(
                    e,
                    [this].concat(r)
                  )
                );
              },
            },
          ]),
          n
        );
      })(rl);
      jo.MaskedEnum = dl;
      var pl = (function (e) {
        bo(n, e);
        var t = To(n);
        function n(e) {
          return _o(this, n), t.call(this, Object.assign({}, n.DEFAULTS, e));
        }
        return (
          yo(n, [
            {
              key: "_update",
              value: function (e) {
                Co(wo(n.prototype), "_update", this).call(this, e),
                  this._updateRegExps();
              },
            },
            {
              key: "_updateRegExps",
              value: function () {
                var e = "^" + (this.allowNegative ? "[+|\\-]?" : ""),
                  t =
                    (this.scale
                      ? "(" + Uo(this.radix) + "\\d{0," + this.scale + "})?"
                      : "") + "$";
                (this._numberRegExpInput = new RegExp(
                  e + "(0|([1-9]+\\d*))?" + t
                )),
                  (this._numberRegExp = new RegExp(e + "\\d*" + t)),
                  (this._mapToRadixRegExp = new RegExp(
                    "[" + this.mapToRadix.map(Uo).join("") + "]",
                    "g"
                  )),
                  (this._thousandsSeparatorRegExp = new RegExp(
                    Uo(this.thousandsSeparator),
                    "g"
                  ));
              },
            },
            {
              key: "_removeThousandsSeparators",
              value: function (e) {
                return e.replace(this._thousandsSeparatorRegExp, "");
              },
            },
            {
              key: "_insertThousandsSeparators",
              value: function (e) {
                var t = e.split(this.radix);
                return (
                  (t[0] = t[0].replace(
                    /\B(?=(\d{3})+(?!\d))/g,
                    this.thousandsSeparator
                  )),
                  t.join(this.radix)
                );
              },
            },
            {
              key: "doPrepare",
              value: function (e) {
                var t;
                e = e.replace(this._mapToRadixRegExp, this.radix);
                for (
                  var i = this._removeThousandsSeparators(e),
                    r = arguments.length,
                    s = new Array(r > 1 ? r - 1 : 0),
                    a = 1;
                  a < r;
                  a++
                )
                  s[a - 1] = arguments[a];
                var o = Vo(
                    (t = Co(wo(n.prototype), "doPrepare", this)).call.apply(
                      t,
                      [this, i].concat(s)
                    )
                  ),
                  l = Do(o, 2),
                  c = l[0],
                  u = l[1];
                return e && !i && (u.skip = !0), [c, u];
              },
            },
            {
              key: "_separatorsCount",
              value: function (e) {
                for (
                  var t =
                      arguments.length > 1 &&
                      void 0 !== arguments[1] &&
                      arguments[1],
                    n = 0,
                    i = 0;
                  i < e;
                  ++i
                )
                  this._value.indexOf(this.thousandsSeparator, i) === i &&
                    (++n, t && (e += this.thousandsSeparator.length));
                return n;
              },
            },
            {
              key: "_separatorsCountFromSlice",
              value: function () {
                var e =
                  arguments.length > 0 && void 0 !== arguments[0]
                    ? arguments[0]
                    : this._value;
                return this._separatorsCount(
                  this._removeThousandsSeparators(e).length,
                  !0
                );
              },
            },
            {
              key: "extractInput",
              value: function () {
                var e =
                    arguments.length > 0 && void 0 !== arguments[0]
                      ? arguments[0]
                      : 0,
                  t =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : this.value.length,
                  i = arguments.length > 2 ? arguments[2] : void 0,
                  r = this._adjustRangeWithSeparators(e, t),
                  s = Do(r, 2);
                return (
                  (e = s[0]),
                  (t = s[1]),
                  this._removeThousandsSeparators(
                    Co(wo(n.prototype), "extractInput", this).call(
                      this,
                      e,
                      t,
                      i
                    )
                  )
                );
              },
            },
            {
              key: "_appendCharRaw",
              value: function (e) {
                var t =
                  arguments.length > 1 && void 0 !== arguments[1]
                    ? arguments[1]
                    : {};
                if (!this.thousandsSeparator)
                  return Co(wo(n.prototype), "_appendCharRaw", this).call(
                    this,
                    e,
                    t
                  );
                var i =
                    t.tail && t._beforeTailState
                      ? t._beforeTailState._value
                      : this._value,
                  r = this._separatorsCountFromSlice(i);
                this._value = this._removeThousandsSeparators(this.value);
                var s = Co(wo(n.prototype), "_appendCharRaw", this).call(
                  this,
                  e,
                  t
                );
                this._value = this._insertThousandsSeparators(this._value);
                var a =
                    t.tail && t._beforeTailState
                      ? t._beforeTailState._value
                      : this._value,
                  o = this._separatorsCountFromSlice(a);
                return (
                  (s.tailShift += (o - r) * this.thousandsSeparator.length),
                  (s.skip = !s.rawInserted && e === this.thousandsSeparator),
                  s
                );
              },
            },
            {
              key: "_findSeparatorAround",
              value: function (e) {
                if (this.thousandsSeparator) {
                  var t = e - this.thousandsSeparator.length + 1,
                    n = this.value.indexOf(this.thousandsSeparator, t);
                  if (n <= e) return n;
                }
                return -1;
              },
            },
            {
              key: "_adjustRangeWithSeparators",
              value: function (e, t) {
                var n = this._findSeparatorAround(e);
                n >= 0 && (e = n);
                var i = this._findSeparatorAround(t);
                return (
                  i >= 0 && (t = i + this.thousandsSeparator.length), [e, t]
                );
              },
            },
            {
              key: "remove",
              value: function () {
                var e =
                    arguments.length > 0 && void 0 !== arguments[0]
                      ? arguments[0]
                      : 0,
                  t =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : this.value.length,
                  n = this._adjustRangeWithSeparators(e, t),
                  i = Do(n, 2);
                (e = i[0]), (t = i[1]);
                var r = this.value.slice(0, e),
                  s = this.value.slice(t),
                  a = this._separatorsCount(r.length);
                this._value = this._insertThousandsSeparators(
                  this._removeThousandsSeparators(r + s)
                );
                var o = this._separatorsCountFromSlice(r);
                return new Ro({
                  tailShift: (o - a) * this.thousandsSeparator.length,
                });
              },
            },
            {
              key: "nearestInputPos",
              value: function (e, t) {
                if (!this.thousandsSeparator) return e;
                switch (t) {
                  case Fo:
                  case Oo:
                  case No:
                    var n = this._findSeparatorAround(e - 1);
                    if (n >= 0) {
                      var i = n + this.thousandsSeparator.length;
                      if (e < i || this.value.length <= i || t === No) return n;
                    }
                    break;
                  case zo:
                  case Bo:
                    var r = this._findSeparatorAround(e);
                    if (r >= 0) return r + this.thousandsSeparator.length;
                }
                return e;
              },
            },
            {
              key: "doValidate",
              value: function (e) {
                var t = (
                  e.input ? this._numberRegExpInput : this._numberRegExp
                ).test(this._removeThousandsSeparators(this.value));
                if (t) {
                  var i = this.number;
                  t =
                    t &&
                    !isNaN(i) &&
                    (null == this.min ||
                      this.min >= 0 ||
                      this.min <= this.number) &&
                    (null == this.max ||
                      this.max <= 0 ||
                      this.number <= this.max);
                }
                return (
                  t && Co(wo(n.prototype), "doValidate", this).call(this, e)
                );
              },
            },
            {
              key: "doCommit",
              value: function () {
                if (this.value) {
                  var e = this.number,
                    t = e;
                  null != this.min && (t = Math.max(t, this.min)),
                    null != this.max && (t = Math.min(t, this.max)),
                    t !== e && (this.unmaskedValue = String(t));
                  var i = this.value;
                  this.normalizeZeros && (i = this._normalizeZeros(i)),
                    this.padFractionalZeros &&
                      this.scale > 0 &&
                      (i = this._padFractionalZeros(i)),
                    (this._value = i);
                }
                Co(wo(n.prototype), "doCommit", this).call(this);
              },
            },
            {
              key: "_normalizeZeros",
              value: function (e) {
                var t = this._removeThousandsSeparators(e).split(this.radix);
                return (
                  (t[0] = t[0].replace(
                    /^(\D*)(0*)(\d*)/,
                    function (e, t, n, i) {
                      return t + i;
                    }
                  )),
                  e.length && !/\d$/.test(t[0]) && (t[0] = t[0] + "0"),
                  t.length > 1 &&
                    ((t[1] = t[1].replace(/0*$/, "")),
                    t[1].length || (t.length = 1)),
                  this._insertThousandsSeparators(t.join(this.radix))
                );
              },
            },
            {
              key: "_padFractionalZeros",
              value: function (e) {
                if (!e) return e;
                var t = e.split(this.radix);
                return (
                  t.length < 2 && t.push(""),
                  (t[1] = t[1].padEnd(this.scale, "0")),
                  t.join(this.radix)
                );
              },
            },
            {
              key: "unmaskedValue",
              get: function () {
                return this._removeThousandsSeparators(
                  this._normalizeZeros(this.value)
                ).replace(this.radix, ".");
              },
              set: function (e) {
                Po(
                  wo(n.prototype),
                  "unmaskedValue",
                  e.replace(".", this.radix),
                  this,
                  !0
                );
              },
            },
            {
              key: "typedValue",
              get: function () {
                return Number(this.unmaskedValue);
              },
              set: function (e) {
                Po(wo(n.prototype), "unmaskedValue", String(e), this, !0);
              },
            },
            {
              key: "number",
              get: function () {
                return this.typedValue;
              },
              set: function (e) {
                this.typedValue = e;
              },
            },
            {
              key: "allowNegative",
              get: function () {
                return (
                  this.signed ||
                  (null != this.min && this.min < 0) ||
                  (null != this.max && this.max < 0)
                );
              },
            },
          ]),
          n
        );
      })(qo);
      (pl.DEFAULTS = {
        radix: ",",
        thousandsSeparator: "",
        mapToRadix: ["."],
        scale: 2,
        signed: !1,
        normalizeZeros: !0,
        padFractionalZeros: !1,
      }),
        (jo.MaskedNumber = pl);
      var fl = (function (e) {
        bo(n, e);
        var t = To(n);
        function n() {
          return _o(this, n), t.apply(this, arguments);
        }
        return (
          yo(n, [
            {
              key: "_update",
              value: function (e) {
                e.mask && (e.validate = e.mask),
                  Co(wo(n.prototype), "_update", this).call(this, e);
              },
            },
          ]),
          n
        );
      })(qo);
      jo.MaskedFunction = fl;
      var ml = ["compiledMasks", "currentMaskRef", "currentMask"],
        gl = (function (e) {
          bo(n, e);
          var t = To(n);
          function n(e) {
            var i;
            return (
              _o(this, n),
              ((i = t.call(
                this,
                Object.assign({}, n.DEFAULTS, e)
              )).currentMask = null),
              i
            );
          }
          return (
            yo(n, [
              {
                key: "_update",
                value: function (e) {
                  Co(wo(n.prototype), "_update", this).call(this, e),
                    "mask" in e &&
                      (this.compiledMasks = Array.isArray(e.mask)
                        ? e.mask.map(function (e) {
                            return Yo(e);
                          })
                        : []);
                },
              },
              {
                key: "_appendCharRaw",
                value: function (e) {
                  var t =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : {},
                    n = this._applyDispatch(e, t);
                  return (
                    this.currentMask &&
                      n.aggregate(this.currentMask._appendChar(e, t)),
                    n
                  );
                },
              },
              {
                key: "_applyDispatch",
                value: function () {
                  var e =
                      arguments.length > 0 && void 0 !== arguments[0]
                        ? arguments[0]
                        : "",
                    t =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : {},
                    n =
                      t.tail && null != t._beforeTailState
                        ? t._beforeTailState._value
                        : this.value,
                    i = this.rawInputValue,
                    r =
                      t.tail && null != t._beforeTailState
                        ? t._beforeTailState._rawInputValue
                        : i,
                    s = i.slice(r.length),
                    a = this.currentMask,
                    o = new Ro(),
                    l = a && a.state;
                  if (
                    ((this.currentMask = this.doDispatch(
                      e,
                      Object.assign({}, t)
                    )),
                    this.currentMask)
                  )
                    if (this.currentMask !== a) {
                      if ((this.currentMask.reset(), r)) {
                        var c = this.currentMask.append(r, { raw: !0 });
                        o.tailShift = c.inserted.length - n.length;
                      }
                      s &&
                        (o.tailShift += this.currentMask.append(s, {
                          raw: !0,
                          tail: !0,
                        }).tailShift);
                    } else this.currentMask.state = l;
                  return o;
                },
              },
              {
                key: "_appendPlaceholder",
                value: function () {
                  var e = this._applyDispatch.apply(this, arguments);
                  return (
                    this.currentMask &&
                      e.aggregate(this.currentMask._appendPlaceholder()),
                    e
                  );
                },
              },
              {
                key: "_appendEager",
                value: function () {
                  var e = this._applyDispatch.apply(this, arguments);
                  return (
                    this.currentMask &&
                      e.aggregate(this.currentMask._appendEager()),
                    e
                  );
                },
              },
              {
                key: "doDispatch",
                value: function (e) {
                  var t =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : {};
                  return this.dispatch(e, this, t);
                },
              },
              {
                key: "doValidate",
                value: function () {
                  for (
                    var e, t, i = arguments.length, r = new Array(i), s = 0;
                    s < i;
                    s++
                  )
                    r[s] = arguments[s];
                  return (
                    (e = Co(wo(n.prototype), "doValidate", this)).call.apply(
                      e,
                      [this].concat(r)
                    ) &&
                    (!this.currentMask ||
                      (t = this.currentMask).doValidate.apply(t, r))
                  );
                },
              },
              {
                key: "reset",
                value: function () {
                  var e;
                  null === (e = this.currentMask) || void 0 === e || e.reset(),
                    this.compiledMasks.forEach(function (e) {
                      return e.reset();
                    });
                },
              },
              {
                key: "value",
                get: function () {
                  return this.currentMask ? this.currentMask.value : "";
                },
                set: function (e) {
                  Po(wo(n.prototype), "value", e, this, !0);
                },
              },
              {
                key: "unmaskedValue",
                get: function () {
                  return this.currentMask ? this.currentMask.unmaskedValue : "";
                },
                set: function (e) {
                  Po(wo(n.prototype), "unmaskedValue", e, this, !0);
                },
              },
              {
                key: "typedValue",
                get: function () {
                  return this.currentMask ? this.currentMask.typedValue : "";
                },
                set: function (e) {
                  var t = String(e);
                  this.currentMask &&
                    ((this.currentMask.typedValue = e),
                    (t = this.currentMask.unmaskedValue)),
                    (this.unmaskedValue = t);
                },
              },
              {
                key: "isComplete",
                get: function () {
                  var e;
                  return Boolean(
                    null === (e = this.currentMask) || void 0 === e
                      ? void 0
                      : e.isComplete
                  );
                },
              },
              {
                key: "isFilled",
                get: function () {
                  var e;
                  return Boolean(
                    null === (e = this.currentMask) || void 0 === e
                      ? void 0
                      : e.isFilled
                  );
                },
              },
              {
                key: "remove",
                value: function () {
                  var e,
                    t = new Ro();
                  return (
                    this.currentMask &&
                      t
                        .aggregate(
                          (e = this.currentMask).remove.apply(e, arguments)
                        )
                        .aggregate(this._applyDispatch()),
                    t
                  );
                },
              },
              {
                key: "state",
                get: function () {
                  return Object.assign({}, Co(wo(n.prototype), "state", this), {
                    _rawInputValue: this.rawInputValue,
                    compiledMasks: this.compiledMasks.map(function (e) {
                      return e.state;
                    }),
                    currentMaskRef: this.currentMask,
                    currentMask: this.currentMask && this.currentMask.state,
                  });
                },
                set: function (e) {
                  var t = e.compiledMasks,
                    i = e.currentMaskRef,
                    r = e.currentMask,
                    s = Mo(e, ml);
                  this.compiledMasks.forEach(function (e, n) {
                    return (e.state = t[n]);
                  }),
                    null != i &&
                      ((this.currentMask = i), (this.currentMask.state = r)),
                    Po(wo(n.prototype), "state", s, this, !0);
                },
              },
              {
                key: "extractInput",
                value: function () {
                  var e;
                  return this.currentMask
                    ? (e = this.currentMask).extractInput.apply(e, arguments)
                    : "";
                },
              },
              {
                key: "extractTail",
                value: function () {
                  for (
                    var e, t, i = arguments.length, r = new Array(i), s = 0;
                    s < i;
                    s++
                  )
                    r[s] = arguments[s];
                  return this.currentMask
                    ? (e = this.currentMask).extractTail.apply(e, r)
                    : (t = Co(wo(n.prototype), "extractTail", this)).call.apply(
                        t,
                        [this].concat(r)
                      );
                },
              },
              {
                key: "doCommit",
                value: function () {
                  this.currentMask && this.currentMask.doCommit(),
                    Co(wo(n.prototype), "doCommit", this).call(this);
                },
              },
              {
                key: "nearestInputPos",
                value: function () {
                  for (
                    var e, t, i = arguments.length, r = new Array(i), s = 0;
                    s < i;
                    s++
                  )
                    r[s] = arguments[s];
                  return this.currentMask
                    ? (e = this.currentMask).nearestInputPos.apply(e, r)
                    : (t = Co(
                        wo(n.prototype),
                        "nearestInputPos",
                        this
                      )).call.apply(t, [this].concat(r));
                },
              },
              {
                key: "overwrite",
                get: function () {
                  return this.currentMask
                    ? this.currentMask.overwrite
                    : Co(wo(n.prototype), "overwrite", this);
                },
                set: function (e) {
                  console.warn(
                    '"overwrite" option is not available in dynamic mask, use this option in siblings'
                  );
                },
              },
              {
                key: "eager",
                get: function () {
                  return this.currentMask
                    ? this.currentMask.eager
                    : Co(wo(n.prototype), "eager", this);
                },
                set: function (e) {
                  console.warn(
                    '"eager" option is not available in dynamic mask, use this option in siblings'
                  );
                },
              },
              {
                key: "maskEquals",
                value: function (e) {
                  return (
                    Array.isArray(e) &&
                    this.compiledMasks.every(function (t, n) {
                      var i;
                      return t.maskEquals(
                        null === (i = e[n]) || void 0 === i ? void 0 : i.mask
                      );
                    })
                  );
                },
              },
            ]),
            n
          );
        })(qo);
      (gl.DEFAULTS = {
        dispatch: function (e, t, n) {
          if (t.compiledMasks.length) {
            var i = t.rawInputValue,
              r = t.compiledMasks.map(function (t, r) {
                return (
                  t.reset(),
                  t.append(i, { raw: !0 }),
                  t.append(e, n),
                  { weight: t.rawInputValue.length, index: r }
                );
              });
            return (
              r.sort(function (e, t) {
                return t.weight - e.weight;
              }),
              t.compiledMasks[r[0].index]
            );
          }
        },
      }),
        (jo.MaskedDynamic = gl);
      var vl = {
        MASKED: "value",
        UNMASKED: "unmaskedValue",
        TYPED: "typedValue",
      };
      function _l(e) {
        var t =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : vl.MASKED,
          n =
            arguments.length > 2 && void 0 !== arguments[2]
              ? arguments[2]
              : vl.MASKED,
          i = Yo(e);
        return function (e) {
          return i.runIsolated(function (i) {
            return (i[t] = e), i[n];
          });
        };
      }
      (jo.PIPE_TYPE = vl),
        (jo.createPipe = _l),
        (jo.pipe = function (e) {
          for (
            var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1;
            i < t;
            i++
          )
            n[i - 1] = arguments[i];
          return _l.apply(void 0, n)(e);
        });
      try {
        globalThis.IMask = jo;
      } catch (e) {}
      var xl = (function () {
          function e() {
            this.mobileMask = null;
            var e = document.querySelector(".".concat("form"));
            if (!e) throw new Error("Cant initialize Form");
            this.formRoot = e;
            var t = this.formRoot.querySelector(
              "."
                .concat("form__field-input-wrapper", ".")
                .concat("mobile", " input")
            );
            if (!t) throw new Error("Cant find mobile input");
            (this.mobileInput = t), this.initializeMasks();
          }
          return (
            (e.prototype.initializeMasks = function () {
              this.mobileMask = jo(this.mobileInput, {
                mask: "+{7} (000) 000-00-00",
              });
            }),
            (e.prototype.submit = function () {}),
            e
          );
        })(),
        yl = "tiny";
      const bl =
        ((wl = document.querySelector(".".concat("header"))),
        (Sl =
          null == wl ? void 0 : wl.querySelector(".".concat("header__btn"))),
        (Ml =
          null == wl ? void 0 : wl.querySelector(".".concat("header__logo"))),
        (El = !1),
        window.addEventListener("scroll", function () {
          El || null == wl || wl.classList.toggle(yl, window.scrollY > 0);
        }),
        {
          onBtnClick: function (e) {
            null == Sl ||
              Sl.addEventListener("click", function (t) {
                return e(t);
              });
          },
          onLogoClick: function (e) {
            null == Ml ||
              Ml.addEventListener("click", function () {
                return e();
              });
          },
          forceSmall: function () {
            (El = !0), null == wl || wl.classList.add(yl);
          },
        });
      var wl,
        Sl,
        Ml,
        El,
        Tl = (function () {
          var e = function (t, n) {
            return (
              (e =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (e, t) {
                    e.__proto__ = t;
                  }) ||
                function (e, t) {
                  for (var n in t)
                    Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
                }),
              e(t, n)
            );
          };
          return function (t, n) {
            if ("function" != typeof n && null !== n)
              throw new TypeError(
                "Class extends value " +
                  String(n) +
                  " is not a constructor or null"
              );
            function i() {
              this.constructor = t;
            }
            e(t, n),
              (t.prototype =
                null === n
                  ? Object.create(n)
                  : ((i.prototype = n.prototype), new i()));
          };
        })();
      const Al = (function (e) {
        function t(t) {
          var n = e.call(this, t) || this;
          (n.finish = !1), (n.lastTouch = null), (n.canBeShowed = !0);
          var i = document.querySelector(".".concat("create"));
          if (!i) throw new Error("Cant initialize Create Screen");
          n.root = i;
          var r = document.querySelector(".".concat("create__circle"));
          if (!r) throw new Error("Cant initialize Dot");
          n.point = r;
          var s = document.querySelector(".".concat("create__transition"));
          if (!s) throw new Error("Cant initialize transition");
          n.transition = s;
          var a = n.transition.querySelector(".create__transition-button");
          if (!a) throw new Error("Cant initialize transition button");
          return (
            (n.transitionButton = a),
            n.handlePoint(),
            n.handleLastScroll(),
            (n.formController = new xl()),
            n.addListeners(),
            n
          );
        }
        return (
          Tl(t, e),
          (t.prototype.show = function () {
            e.prototype.show.call(this), this.point.classList.add("visible");
          }),
          (t.prototype.hide = function () {
            e.prototype.hide.call(this), this.point.classList.remove("visible");
          }),
          (t.prototype.isCanBeChanged = function (e) {
            return !0;
          }),
          (t.prototype.addListeners = function () {
            var e = this;
            bl.onBtnClick(function () {
              document.body.classList.contains("point-active") || e.showForm();
            }),
              this.root
                .querySelectorAll(".".concat("create__item-btn"))
                .forEach(function (t) {
                  return t.addEventListener("click", function (t) {
                    t.preventDefault(), e.showForm();
                  });
                }),
              bl.onLogoClick(function () {
                e.hideForm();
              });
          }),
          (t.prototype.handlePoint = function () {
            var e = this;
            new IntersectionObserver(
              function (t) {
                t.forEach(function (t) {
                  (e.finish = t.isIntersecting),
                    e.point.classList.toggle("visible", t.isIntersecting);
                });
              },
              { threshold: 0.8 }
            ).observe(this.root),
              this.transitionButton.addEventListener("click", function () {
                document.body.classList.add("form-visible"),
                  e.transitionButton.classList.add("full");
              });
          }),
          (t.prototype.handleLastScroll = function () {
            var e = this;
            window.addEventListener("wheel", function (t) {
              window.scrollY + window.innerHeight >=
                document.body.scrollHeight &&
                t.deltaY > 0 &&
                e.showForm();
            }),
              window.addEventListener("touchstart", function (t) {
                return (e.lastTouch = t.touches[0].clientY);
              }),
              window.addEventListener("touchmove", function (t) {
                var n = e.lastTouch - t.touches[0].clientY;
                window.scrollY + window.innerHeight >=
                  document.body.scrollHeight &&
                  n > 0 &&
                  e.showForm();
              });
          }),
          (t.prototype.showForm = function () {
            var e = this;
            if (this.canBeShowed) {
              bl.forceSmall();
              var t = window.innerWidth > 940 ? 2e3 : 0;
              this.point.classList.add("visible"),
                document.body.classList.add("point-active"),
                this.point.classList.add("moved"),
                setTimeout(
                  function () {
                    e.transitionButton.classList.add("partial-visible"),
                      setTimeout(function () {
                        e.transitionButton.classList.add("moved");
                      }, 1e3);
                  },
                  t ? 1500 : 0
                ),
                setTimeout(function () {
                  e.point.classList.add("full"),
                    e.transition.classList.add("visible");
                }, t),
                setTimeout(function () {
                  e.transitionButton.classList.add("text-visible");
                }, t + 500);
            }
          }),
          (t.prototype.hideForm = function () {
            var e = this;
            (this.canBeShowed = !1),
              document.body.classList.add("form-hide"),
              setTimeout(function () {
                document.body.classList.remove("point-active"),
                  document.body.classList.remove("form-visible"),
                  document.body.classList.remove("point-active"),
                  e.point.classList.remove("visible"),
                  e.point.classList.remove("moved"),
                  e.transitionButton.classList.remove("text-visible"),
                  e.point.classList.remove("full"),
                  e.transition.classList.remove("visible"),
                  e.transitionButton.classList.remove("moved"),
                  e.transitionButton.classList.remove("full"),
                  e.transitionButton.classList.remove("partial-visible"),
                  setTimeout(function () {
                    document.body.classList.remove("form-hide"),
                      (e.canBeShowed = !0);
                  }, 500);
              }, 1e3);
          }),
          t
        );
      })(t);


      var Cl = (function () {
          function e() {
            var e = document.querySelector(".scroll");
            if (!e) throw new Error("Cant initialize scroll");
            (this.scrollElm = e)
            this.addListeners();
          }
          return (
            (e.prototype.addListeners = function () {
              this.scrollElm.addEventListener("click", function () {
                var e;
                null === (e = document.querySelector(".steps")) ||
                  void 0 === e ||
                  e.scrollIntoView({ behavior: "smooth" });
              });
            }),
            e
          );
        })(),

        Ll = location.hash,
        Pl = [
          { current: "" === Ll || "#welcome" === Ll, screen: ea },
          { current: "#steps" === Ll, screen: ia },
          { current: "#inwork" === Ll, screen: fo },
          { current: "#clients" === Ll, screen: go },
          { current: "#create" === Ll, screen: Al },
        ];

      
        window.onload = function () {
        document.body.classList.add("initialized"),
        new e(Pl)
        new Cl()
        bl.onLogoClick(function () {
            window.scroll({ top: 0, behavior: "smooth" });
          });
      };
    })();



})();
